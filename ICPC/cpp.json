{
  "ini": {
    "prefix": "ini",
    "body": "#include<bits/stdc++.h>\n#include<_internal/cpp-dump-main/cpp-dump.hpp>\nusing namespace std;\nusing ll=long long;\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  $0\n}"
  },
  "ini2": {
    "prefix": "ini2",
    "body": "#include<bits/stdc++.h>\n#include<_internal/cpp-dump-main/cpp-dump.hpp>\nusing namespace std;\nusing ll=long long;\n\nvoid solve(){\n  $0\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  ll t;\n  cin>>t;\n  while(t--){ solve(); }\n}"
  },
  "inib": {
    "prefix": "inib",
    "body": "#include<bits/stdc++.h>\n#include<_internal/cpp-dump-main/cpp-dump.hpp>\nusing namespace std;\nusing ll=long long;\n\nbool solve(){\n  $0\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  ll t;\n  cin>>t;\n  while(t--){ cout << (solve() ? \"Yes\" : \"No\") << \"\\\\n\"; }\n}"
  },
  "inil": {
    "prefix": "inil",
    "body": "#include <bits/stdc++.h>\n#include<_internal/cpp-dump-main/cpp-dump.hpp>\nusing namespace std;\nusing ll = long long;\n\nll solve() {\n  $0\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  ll t;\n  cin >> t;\n  while(t--) { cout << solve() << \"\\\\n\"; }\n}"
  },
  "ini0": {
    "prefix": "ini0",
    "body": "#include<bits/stdc++.h>\n#include<atcoder/modint>\n#include<_internal/cpp-dump-main/cpp-dump.hpp>\nusing namespace std;\nusing namespace atcoder;\nusing ll=long long;\nusing mint=modint1000000007;\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  $0\n}"
  },
  "ini9": {
    "prefix": "ini9",
    "body": "#include<bits/stdc++.h>\n#include<atcoder/modint>\n#include<_internal/cpp-dump-main/cpp-dump.hpp>\nusing namespace std;\nusing namespace atcoder;\nusing ll=long long;\nusing mint=modint998244353;\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  $0\n}"
  },
  "ini_arbitrary": {
    "prefix": "ini_arbitrary",
    "body": "#include<bits/stdc++.h>\n#include<atcoder/modint>\n#include<_internal/cpp-dump-main/cpp-dump.hpp>\nusing namespace std;\nusing namespace atcoder;\nusing ll=long long;\nusing mint=modint;\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  $0\n  modint::set_mod();\n}"
  },
  "atcoder": {
    "prefix": "atcoder",
    "body": "#include<atcoder/${1|convolution,dsu,fenwicktree,lazysegtree,math,maxflow,mincostflow,modint,scc,segtree,string,twosat|}>\nusing namespace atcoder;$0"
  },
  "main": {
    "prefix": "main",
    "body": "int main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  $0\n}"
  },
  ";": {
    "prefix": "l",
    "body": ";"
  },
  "ll": {
    "prefix": "ll",
    "body": "ll $0"
  },
  "double": {
    "prefix": "db",
    "body": "long double $0"
  },
  "string": {
    "prefix": "string",
    "body": "string $0"
  },
  "str": {
    "prefix": "str",
    "body": "string $0"
  },
  "char": {
    "prefix": "char",
    "body": "char $0"
  },
  "bool": {
    "prefix": "bl",
    "body": "bool $0"
  },
  "mint": {
    "prefix": "mint",
    "body": "mint $0"
  },
  "cin": {
    "prefix": "cin",
    "body": "cin>>$0"
  },
  "l1": {
    "prefix": "l1",
    "body": "ll $1;\ncin>>$1;$0"
  },
  "l2": {
    "prefix": "l2",
    "body": "ll $1,$2;\ncin>>$1>>$2;$0"
  },
  "l3": {
    "prefix": "l3",
    "body": "ll $1,$2,$3;\ncin>>$1>>$2>>$3;$0"
  },
  "l4": {
    "prefix": "l4",
    "body": "ll $1,$2,$3,$4;\ncin>>$1>>$2>>$3>>$4;$0"
  },
  "l5": {
    "prefix": "l5",
    "body": "ll $1,$2,$3,$4,$5;\ncin>>$1>>$2>>$3>>$4>>$5;$0"
  },
  "STR": {
    "prefix": "STR",
    "body": "string ${1:S}; cin>>${1:S};$0"
  },
  "ns": {
    "prefix": "ns",
    "body": "ll N; string S; cin>>N>>S;"
  },
  "vin": {
    "prefix": "vin",
    "body": "for(auto &i:$1) {cin>>i;}$0"
  },
  "vpin": {
    "prefix": "vpin",
    "body": "for(auto &[x,y]:$1) {cin>>x>>y;}$0"
  },
  "vvin": {
    "prefix": "vvin",
    "body": "for(auto &i:$1){for(auto &j:i) {cin>>j;}}$0"
  },
  "cout": {
    "prefix": "c",
    "body": "cout<<${0:ans}<<\"\\\\n\";"
  },
  "cout_": {
    "prefix": "cout",
    "body": "cout<<${1:ans}<<\"\\\\n\";$0"
  },
  "cout2": {
    "prefix": "c2",
    "body": "cout<<$1<<\" \"<<$2<<\"\\\\n\";$0"
  },
  "cout3": {
    "prefix": "c3",
    "body": "cout<<$1<<\" \"<<$2<<\" \"<<$3<<\"\\\\n\";$0"
  },
  "cout4": {
    "prefix": "c4",
    "body": "cout<<$1<<\" \"<<$2<<\" \"<<$3<<\" \"<<$4<<\"\\\\n\";$0"
  },
  "cout5": {
    "prefix": "c5",
    "body": "cout<<$1<<\" \"<<$2<<\" \"<<$3<<\" \"<<$4<<\" \"<<$5<<\"\\\\n\";$0"
  },
  "print": {
    "prefix": "print",
    "body": "cout<<$0"
  },
  "vout": {
    "prefix": "vout",
    "body": "for(auto &${2:i}:$1) {cout<<${2:i}<<\" \";}$0"
  },
  "vpout": {
    "prefix": "vpout",
    "body": "for(auto &[${2:x},${3:y}]:$1) {cout<<${2:x}<<\" \"<<${3:y}<<\"\\\\n\";}$0"
  },
  "vvout": {
    "prefix": "vvout",
    "body": "for(auto &${2:i}:$1) {for(auto &${3:j}:${2:i}){cout<<${3:j}<<\" \";}cout<<\"\\\\n\";}$0"
  },
  "sout": {
    "prefix": "sout",
    "body": "cout<<\"$1\\\\n\";$0"
  },
  "iout": {
    "prefix": "iout",
    "body": "cout<<($1==1e18?-1:$1)<<\"\\\\n\";$0"
  },
  "debug": {
    "prefix": "debug1",
    "body": "cerr<<\"\\\\033[33m$1 : \"<<$1<<\"\\\\n\\\\033[m\";$0"
  },
  "debug2": {
    "prefix": "debug2",
    "body": "cerr<<\"\\\\033[33m($1, $2) : (\"<<$1<<\", \"<<$2<<\")\\\\n\\\\033[m\";$0"
  },
  "debug3": {
    "prefix": "debug3",
    "body": "cerr<<\"\\\\033[33m($1, $2, $3) : (\"<<$1<<\", \"<<$2<<\", \"<<$3<<\")\\\\n\\\\033[m\";$0"
  },
  "debug4": {
    "prefix": "debug4",
    "body": "cerr<<\"\\\\033[33m($1, $2, $3, $4) : (\"<<$1<<\", \"<<$2<<\", \"<<$3<<\", \"<<$4<<\")\\\\n\\\\033[m\";$0"
  },
  "debug5": {
    "prefix": "debug5",
    "body": "cerr<<\"\\\\033[33m($1, $2, $3, $4, $5) : (\"<<$1<<\", \"<<$2<<\", \"<<$3<<\", \"<<$4<<\", \"<<$5<<\")\\\\n\\\\033[m\";$0"
  },
  "debug_pair": {
    "prefix": "debugp",
    "body": "cerr<<\"\\\\033[33m$1 : (\"<<$1.first<<\", \"<<$1.second<<\")\\\\n\\\\033[m\";$0"
  },
  "debug_vector": {
    "prefix": "debugv",
    "body": "for(ll I=0;I<ssize($1);I++) {cerr<<(I?\"\":\"\\\\033[33m$1 : [\")<<$1[I]<<(I==ssize($1)-1?\"]\\\\n\\\\033[m\":\", \");}$0"
  },
  "debug_vector_pair": {
    "prefix": "debugvp",
    "body": "for(ll I=0;I<ssize($1);I++) {cerr<<(I?\"(\":\"\\\\033[33m$1 : [(\")<<$1[I].first<<\", \"<<$1[I].second<<(I==ssize($1)-1?\")]\\\\n\\\\033[m\":\"), \");}$0"
  },
  "debug_vector_2": {
    "prefix": "debugvv",
    "body": "for(ll I = 0; I < ssize($1); I++) {\n  for(ll J = 0; J < ssize($1[I]); J++) {cerr << (J ? \"\" : \"\\\\033[33m[\") << $1[I][J] << (J == ssize($1[I]) - 1 ? \"]\\\\n\\\\033[m\" : \", \");}\n}$0"
  },
  "debug_set": {
    "prefix": "debugset",
    "body": "for(auto it = $1.begin(); it != $1.end(); it++) {cerr << (it == $1.begin() ? \"\\\\033[33m$1 : {\" : \"\") << *it << (it == prev($1.end()) ? \"}\\\\n\\\\033[m\" : \", \");}$0"
  },
  "debug_map": {
    "prefix": "debugmap",
    "body": "for(auto it = $1.begin(); it != $1.end(); it++) { cerr << (it == $1.begin() ? \"\\\\033[33m$1 : [(\" : \"(\") << it->first << \", \" << it->second << (it == prev($1.end()) ? \")]\\\\n\\\\033[m\" : \"), \"); }$0"
  },
  "endl": {
    "prefix": "en",
    "body": "cout<<\"\\\\n\";"
  },
  "Yes": {
    "prefix": "yes",
    "body": "cout<<\"Yes\\\\n\";"
  },
  "No": {
    "prefix": "no",
    "body": "cout<<\"No\\\\n\";"
  },
  "yesno": {
    "prefix": "yesno",
    "body": "cout<<(${1:flag}?\"${2:Yes}\\\\n\":\"${3:No}\\\\n\");$0"
  },
  "first": {
    "prefix": "fi",
    "body": "first"
  },
  "second": {
    "prefix": "sc",
    "body": "second"
  },
  "make_pair": {
    "prefix": "mp",
    "body": "make_pair($1)$0"
  },
  "size": {
    "prefix": "siz",
    "body": "size()"
  },
  "ssize": {
    "prefix": "ssiz",
    "body": "ssize($1)$0"
  },
  "back": {
    "prefix": "back",
    "body": "back()"
  },
  "empty": {
    "prefix": "empty",
    "body": "empty()"
  },
  "while": {
    "prefix": "while",
    "body": "while(${1:Q--}){$0}"
  },
  "while!empty": {
    "prefix": "whileempty",
    "body": "while(!$1.empty()){$0}"
  },
  "and": {
    "prefix": "and",
    "body": "&&"
  },
  "or": {
    "prefix": "or",
    "body": "||"
  },
  "not": {
    "prefix": "not",
    "body": "!="
  },
  "emplace_back": {
    "prefix": "push_back",
    "body": "emplace_back($1);$0"
  },
  "pop_back": {
    "prefix": "pop_back",
    "body": "pop_back()"
  },
  "emplace": {
    "prefix": "emplace",
    "body": "emplace($1);$0"
  },
  "insert": {
    "prefix": "insert",
    "body": "insert($1);$0"
  },
  "erase": {
    "prefix": "erase",
    "body": "erase($1);$0"
  },
  "break": {
    "prefix": "bre",
    "body": "break;"
  },
  "continue": {
    "prefix": "continue",
    "body": "continue;"
  },
  "exit": {
    "prefix": "exit",
    "body": "return 0;"
  },
  "return": {
    "prefix": "return",
    "body": "return "
  },
  "for": {
    "prefix": "for",
    "body": "for(ll ${1:i}=0;${1:i}<${2:N};${1:i}++){$0}"
  },
  "for_": {
    "prefix": "for1",
    "body": "for(ll ${1:i}=1;${1:i}<=${2:N};${1:i}++){$0}"
  },
  "lp": {
    "prefix": "lp",
    "body": "for(ll ${1:i}=0;${1:i}<${2:N};${1:i}++){$0}"
  },
  "lpi": {
    "prefix": "lpi",
    "body": "for(int ${1:i}=0;${1:i}<${2:N};${1:i}++){$0}"
  },
  "lp_": {
    "prefix": "lp_",
    "body": "for(ll ${1:i}=1;${1:i}<=${2:N};${1:i}++){$0}"
  },
  "lpv": {
    "prefix": "lpv",
    "body": "for(ll ${1:i}=0;${1:i}<ssize($2);${1:i}++){$0}"
  },
  "lpa": {
    "prefix": "lpa",
    "body": "for(auto &${1:i}:$2){$0}"
  },
  "lpa2": {
    "prefix": "lpa2",
    "body": "for(auto &[${1:x},${2:y}]:$3){$0}"
  },
  "forauto": {
    "prefix": "fora",
    "body": "for(auto &${1:i}:$2){$0}"
  },
  "pl": {
    "prefix": "pl",
    "body": "for(ll ${1:i}=$2;${1:i}>=0;${1:i}--){$0}"
  },
  "mint_ini1000000007": {
    "prefix": "mint0",
    "body": "using mint=modint1000000007;"
  },
  "mint_ini998244353": {
    "prefix": "mint9",
    "body": "using mint=modint998244353;"
  },
  "mint_ini_arbitrary": {
    "prefix": "minta",
    "body": "using mint=modint;"
  },
  "mod_option": {
    "prefix": "mod_option",
    "body": "istream &operator>>(istream &is,mint &m) {ll n;is>>n;m=n;return is;}\nostream &operator<<(ostream &os,const mint &m) {return os<<m.val();}\nmint operator^(const mint &x,const ll &n) {return x.pow(n);}\nmint operator^=(mint &x,const ll &n) {return x=x.pow(n);}"
  },
  "setmod": {
    "prefix": "setmod",
    "body": "mint::set_mod($1);$0"
  },
  "pair": {
    "prefix": "pair",
    "body": "pair<${1:ll},${2:ll}> $0"
  },
  "pi": {
    "prefix": "pi",
    "body": "pair<ll,ll> $0"
  },
  "pd": {
    "prefix": "pd",
    "body": "pair<long double,long double> $0"
  },
  "pm": {
    "prefix": "pm",
    "body": "pair<mint,mint> $0"
  },
  "vector": {
    "prefix": "vector",
    "body": "vector<$1>$0"
  },
  "v": {
    "prefix": "v",
    "body": "vector<ll> ${0:v}"
  },
  "vi": {
    "prefix": "vi",
    "body": "vector<ll> ${0:v}"
  },
  "vvi": {
    "prefix": "vvi",
    "body": "vector<vector<ll>> ${1:v}(${2:H},vector<ll>(${3:W}))$0"
  },
  "vd": {
    "prefix": "vd",
    "body": "vector<long double> ${0:v}"
  },
  "vvd": {
    "prefix": "vvd",
    "body": "vector<vector<long double>> ${1:v}(${2:h},vector<long double>(${3:w}))$0"
  },
  "vc": {
    "prefix": "vc",
    "body": "vector<char> ${0:v}"
  },
  "vvc": {
    "prefix": "vvc",
    "body": "vector<vector<char>> ${1:v}(${2:h},vector<char>(${3:w}))$0"
  },
  "vs": {
    "prefix": "vs",
    "body": "vector<string> ${0:v}"
  },
  "vvs": {
    "prefix": "vvs",
    "body": "vector<vector<string>> ${1:v}($2,vector<string>($3))$0"
  },
  "vm": {
    "prefix": "vm",
    "body": "vector<mint> ${0:v}"
  },
  "vvm": {
    "prefix": "vvm",
    "body": "vector<vector<mint>> ${1:v}(${2:H},vector<mint>(${3:W}))$0"
  },
  "vp": {
    "prefix": "vp",
    "body": "vector<pair<${1:ll},${2:ll}>> ${3:v}"
  },
  "vv": {
    "prefix": "vv",
    "body": "vector<vector<${1:ll}>> $0"
  },
  "vvv": {
    "prefix": "vvv",
    "body": "vector<vector<vector<${1:ll}>>> $0"
  },
  "vvv_": {
    "prefix": "vvv_",
    "body": "vector<vector<vector<${1:ll}>>> ${2:v}($3,vector<vector<${1:ll}>>($4,vector<${1:ll}>($5)));$0"
  },
  "vvvv": {
    "prefix": "vvvv",
    "body": "vector<vector<vector<vector<${1:ll}>>>> $0"
  },
  "vvvv_": {
    "prefix": "vvvv_",
    "body": "vector<vector<vector<vector<${1:ll}>>>> ${2:v}($3,vector<vector<vector<${1:ll}>>>($4,vector<vector<${1:ll}>>($5,vector<${1:ll}>($6))));$0"
  },
  "V": {
    "prefix": "V",
    "body": "vector<${1:ll}> ${2:v}(${3:N});\nfor(auto &i:${2:v}) {cin>>i;}$0"
  },
  "VI": {
    "prefix": "VI",
    "body": "vector<ll> ${1:v}(${2:N});\nfor(auto &i:${1:v}) {cin>>i;}$0"
  },
  "VD": {
    "prefix": "VD",
    "body": "vector<long double> ${1:v}(${2:N});\nfor(auto &i:${1:v}) {cin>>i;}$0"
  },
  "VC": {
    "prefix": "VC",
    "body": "vector<char> ${1:v}(${2:N});\nfor(auto &i:${1:v}) {cin>>i;}$0"
  },
  "VM": {
    "prefix": "VM",
    "body": "vector<mint> ${1:v}(${2:N});\nfor(auto &i:${1:v}) {cin>>i;}$0"
  },
  "VS": {
    "prefix": "VS",
    "body": "vector<string> ${1:v}(${2:H});\nfor(auto &i:${1:v}) {cin>>i;}$0"
  },
  "VP": {
    "prefix": "VP",
    "body": "vector<pair<ll,ll>> ${1:v}(${2:N});\nfor(auto &[x,y]:${1:v}) {cin>>x>>y;}$0"
  },
  "VV": {
    "prefix": "VV",
    "body": "vector<vector<${1:ll}>> ${2:v}(${3:H},vector<${1:ll}>(${4:W}));\nfor(auto &i:${2:v}){for(auto &j:i){cin>>j;}}$0"
  },
  "VVI": {
    "prefix": "VVI",
    "body": "vector<vector<ll>> ${1:v}(${2:H},vector<ll>(${3:W}));\nfor(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$0"
  },
  "VVD": {
    "prefix": "VVD",
    "body": "vector<vector<long double>> ${1:v}(${2:H},vector<long double>(${3:W}));\nfor(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$0"
  },
  "VVC": {
    "prefix": "VVC",
    "body": "vector<vector<char>> ${1:v}(${2:H},vector<char>(${3:W}));\nfor(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$0"
  },
  "VVS": {
    "prefix": "VVS",
    "body": "vector<vector<string>> ${1:v}(${2:H},vector<string>(${3:W}));\nfor(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$0"
  },
  "VVM": {
    "prefix": "VVM",
    "body": "vector<vector<mint>> ${1:v}(${2:H},vector<mint>(${3:W}));\nfor(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$0"
  },
  "lvi": {
    "prefix": "lvi",
    "body": "ll ${1:N}; cin>>${1:N};\n\nvector<ll> ${2:A}(${1:N});\nfor(auto &i:${2:A}) {cin>>i;}\n$0"
  },
  "lvp": {
    "prefix": "lvp",
    "body": "ll ${1:N}; cin>>${1:N};\nvector<pair<ll,ll>> ${2:v}(${1:N});\nfor(auto &[x,y]:${2:v}) {cin>>x>>y;}\n$0"
  },
  "set": {
    "prefix": "set",
    "body": "set<${1:ll}> ${2:s};$0"
  },
  "multiset": {
    "prefix": "multiset",
    "body": "multiset<${1:ll}> ${2:s};$0"
  },
  "map": {
    "prefix": "map",
    "body": "map<${1:ll},${2:ll}> ${3:m};$0"
  },
  "unordered_map": {
    "prefix": "umap",
    "body": "unordered_map<${1:ll},${2:ll}> ${3:m};$0"
  },
  "queue": {
    "prefix": "queue",
    "body": "queue<${1:ll}> ${2:q};$0"
  },
  "priority_queue_greater": {
    "prefix": "PQ",
    "body": "priority_queue<${1:ll},vector<${1:ll}>,greater<${1:ll}>> ${2:q};$0"
  },
  "priority_queue": {
    "prefix": "QP",
    "body": "priority_queue<${1:ll}> ${2:q};$0"
  },
  "stack": {
    "prefix": "stack",
    "body": "stack<${1:ll}> ${2:s};$0"
  },
  "all": {
    "prefix": "all",
    "body": "$1.begin(),$1.end()$0"
  },
  "begin": {
    "prefix": "begin",
    "body": "begin()"
  },
  "end": {
    "prefix": "end",
    "body": "end()"
  },
  "sort": {
    "prefix": "sort",
    "body": "ranges::sort($1);$0"
  },
  "reverse": {
    "prefix": "reverse",
    "body": "ranges::reverse($1);$0"
  },
  "resort": {
    "prefix": "resort",
    "body": "ranges::sort($1,greater());$0"
  },
  "sum": {
    "prefix": "sum",
    "body": "accumulate($1.begin(),$1.end(),${2:ll}(0))$0"
  },
  "MAX": {
    "prefix": "MAX",
    "body": "ranges::max($1)$0"
  },
  "MIN": {
    "prefix": "MIN",
    "body": "ranges::min($1)$0"
  },
  "binary_search": {
    "prefix": "BS",
    "body": "ranges::binary_search($1,$2)$0"
  },
  "all_of": {
    "prefix": "all_of",
    "body": "ranges::all_of($1,[](auto x){return $2;})$0"
  },
  "any_of": {
    "prefix": "any_of",
    "body": "ranges::any_of($1,[](auto x){return $2;})$0"
  },
  "none_of": {
    "prefix": "none_of",
    "body": "ranges::none_of($1,[](auto x){return $2;})$0"
  },
  "AP": {
    "prefix": "AP",
    "body": "for(ll ${3:i}=0;${3:i}<(ll)$1.size()) {$1[${3:i}]+=$2;}$0"
  },
  "lower_bound": {
    "prefix": "lb",
    "body": "ranges::lower_bound($1,$2)$0"
  },
  "upper_bound": {
    "prefix": "ub",
    "body": "ranges::upper_bound($1,$2)$0"
  },
  "unique": {
    "prefix": "unique",
    "body": "ranges::sort($1); $1.erase(unique($1.begin(),$1.end()),$1.end());$0"
  },
  // "Compress": {
  //   "prefix": "Compress",
  //   "body": "template<typename T> vector<T> Compress(vector<T> &v) {\n  vector<T> r = v;\n  ranges::sort(r);\n  r.erase(unique(r.begin(), r.end()), r.end());\n  for(auto &i : v) {i = ranges::lower_bound(r, i) - r.begin();}\n  return r;\n}"
  // },
  "compress": {
    "prefix": "compress",
    "body": "Compress($1)"
  },
  // "RLE_vec": {
  //   "prefix": "RLE__vec",
  //   "body": "template<typename T> vector<pair<T, ll>> RLE(const vector<T> &v) {\n  int p = -1, n = v.size();\n  vector<pair<T, ll>> r;\n  for(int i = 0; i < n - 1; i++) {\n    if(v[i] != v[i + 1]) {\n      r.emplace_back(v[i], i - p);\n      p = i;\n    }\n  }\n  if(!v.empty()) { r.emplace_back(v.back(), n - 1 - p); }\n  return r;\n}"
  // },
  // "RLE_str": {
  //   "prefix": "RLE_str",
  //   "body": "vector<pair<char, ll>> RLE(const string &s) {\n  int p = -1, n = s.size();\n  vector<pair<char, ll>> r;\n  for(int i = 0; i < n - 1; i++) {\n    if(s[i] != s[i + 1]) {\n      r.emplace_back(s[i], i - p);\n      p = i;\n    }\n  }\n  if(!s.empty()){r.emplace_back(s.back(), n - 1 - p);}\n  return r;\n}"
  // },
  "ACSUM": {
    "prefix": "ACSUM",
    "body": "vector<ll> s${1:v}(${2:${1:v}.size()}+1,0);\nfor(ll i=0;i<${2:${1:v}.size()};i++) {s${1:v}[i+1]=s${1:v}[i]+${1:v}[i];}$0"
  },
  "next_permutation": {
    "prefix": "next_permutation",
    "body": "do{\n  $2\n}while(next_permutation($1.begin(),$1.end()));"
  },
  "next_combination": {
    "prefix": "next_combination",
    "body": "vector<bool> o(${1:N}, false);\nfill(o.end() - ${1:N} + ${2:K}, o.end(), true);\ndo {\n  vector<ll> r;\n  for(int i = 0; i < ${1:N}; i++) {\n    if(!o[i]) { r.push_back(i); }\n  }\n} while(next_permutation(o.begin(), o.end()));$0"
  },
  // "ExtGcd": {
  //   "prefix": "ExtGcd",
  //   "body": "// return : gcd(a,b), {x,y} -> soltion of ax + by = gcd(a,b)\ntemplate<typename T> T ExtGcd(T a, T b, T &x, T &y) {\n  T g = a;\n  if(b != 0) {\n    g = ExtGcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else {x = 1, y = 0;}\n  return g;\n}"
  // },
  "extgcd": {
    "prefix": "extgcd",
    "body": "ExtGcd($1,$2,$3,$4);$0"
  },
  // "Binomial": {
  //   "prefix": "Combinatorics",
  //   "body": "struct Binomial {\n private:\n  void extend(int m) {\n    int n = fac.size();\n    m = min(m, mint::mod() - 1);\n    if(n > m) { return; }\n    fac.resize(m + 1);\n    finv.resize(m + 1);\n    inv.resize(m + 1);\n    for(int i = n; i <= m; i++) { fac[i] = fac[i - 1] * i; }\n    finv[m] = fac[m].inv();\n    for(int i = m - 1; i >= n; i--) { finv[i] = finv[i + 1] * (i + 1); }\n    for(int i = n; i <= m; i++) { inv[i] = finv[i] * fac[i - 1]; }\n  }\n\n public:\n  vector<mint> fac, finv, inv;\n  Binomial(int n = 0): fac(1, 1), finv(1, 1), inv(1, 1) { extend(n); }\n  mint operator()(int n) {\n    extend(abs(n));\n    return n >= 0 ? fac[n] : finv[-n];\n  }\n  mint operator[](int n) {\n    extend(abs(n));\n    return n >= 0 ? inv[n] : -inv[-n];\n  }\n  mint C(int n, int k) {\n    if(n < 0 || k < 0 || n < k) { return 0; }\n    extend(n);\n    return fac[n] * finv[n - k] * finv[k];\n  }\n  inline mint operator()(int n, int k) { return C(n, k); }\n  mint C_(ll n, ll k) {\n    if(n < 0 || k < 0 || n < k) { return 0; }\n    k = min(k, n - k);\n    extend(k);\n    mint r = 1;\n    for(ll i = 0; i < k; i++) { r *= n - i; }\n    return r * finv[k];\n  }\n  mint P(int n, int k) {\n    if(n < 0 || k < 0 || n < k) { return 0; }\n    extend(n);\n    return fac[n] * finv[n - k];\n  }\n  mint P_(ll n, ll k) {\n    if(n < 0 || k < 0 || n < k) { return 0; }\n    k = min(k, n - k);\n    mint r = 1;\n    for(ll i = 0; i < k; i++) { r *= n - i; }\n    return r;\n  }\n  mint H(int n, int k) {\n    if(n < 0 || k < 0) { return 0; }\n    if(n == 0 && k == 0) { return 1; }\n    return C(n + k - 1, k);\n  }\n  mint multi(const vector<ll> &v) {\n    int n = 0;\n    for(auto &i : v) {\n      if(i < 0) { return 0; }\n      n += i;\n    }\n    extend(n);\n    mint r = fac[n];\n    for(auto &i : v) { r *= finv[i]; }\n    return r;\n  }\n  mint operator()(const vector<ll> &v) { return multi(v); }\n  mint Catalan(int n) {\n    if(n < 0) { return 0; }\n    extend(n * 2);\n    return fac[n * 2] * finv[n] * finv[n + 1];\n  }\n  mint Bell(int n, int k) {\n    if(n < 0 || k < 0) { return 0; }\n    if(n == 0) { return 1; }\n    k = min(n, k);\n    extend(k);\n    mint r = 0;\n    vector<mint> v(k + 1);\n    v[0] = 1;\n    for(ll i = 1; i <= k; i++) { v[i] = v[i - 1] + (i & 1 ? -finv[i] : finv[i]); }\n    for(ll i = 1; i <= k; i++) { r += (mint(i).pow(n)) * finv[i] * v[k - i]; }\n    return r;\n  }\n  mint Stirling2(ll n, ll k) {\n    if(n < 0 || k < 0 || n < k) { return 0; }\n    mint r = 0;\n    for(ll i = 0; i <= k; i++) {\n      mint t = C(k, i) * (mint(i).pow(n));\n      r += (k - i) & 1 ? -t : t;\n    }\n    return r * finv[k];\n  }\n} C;  ${1:// 任意modの場合，main関数内に書くこと}"
  // },
  "combinatrics": {
    "prefix": "combinatrics",
    "body": "Binomial C($0);"
  },
  // "COMTable": {
  //   "prefix": "COMTable",
  //   "body": "template<typename T> vector<vector<T>> COMTable(int n) {\n  vector<vector<T>> r(n + 1, vector<T>(n + 1, 0));\n  for(int i = 0; i <= n; i++) {\n    for(int j = 0; j <= i; j++) {\n      if(j == 0 || j == i) { r[i][j] = 1; }\n      else { r[i][j] = r[i - 1][j - 1] + r[i - 1][j]; }\n    }\n  }\n  return r;\n}"
  // },
  "binomialtable": {
    "prefix": "binomialtable",
    "body": "BinomialTable($1);$0"
  },
  // "Stirling_2_Table": {
  //   "prefix": "Stirling_2_Table",
  //   "body": "template<typename T> vector<vector<T>> Stirling2(int N) {\n  vector<vector<T>> r(N + 1, vector<T>(N + 1, 0));\n  r[0][0] = 1;\n  for(int i = 1; i <= N; i++) {\n    for(int j = 1; j <= i; j++) { r[i][j] = r[i - 1][j - 1] + r[i - 1][j] * j; }\n  }\n  return r;\n}"
  // },
  // "Partition_Table": {
  //   "prefix": "Partition_Table",
  //   "body": "template<typename T> vector<vector<T>> Partition(int N) {\n  vector<vector<T>> r(N + 1, vector<T>(N + 1, 0));\n  for(int i = 0; i <= N; i++) { r[0][i] = 1; }\n  for(int i = 1; i <= N; i++) {\n    for(int j = 1; j <= N; j++) { r[i][j] = r[i][j - 1] + (i - j >= 0 ? r[i - j][j] : 0); }\n  }\n  return r;\n}"
  // },
  // "Base": {
  //   "prefix": "Base",
  //   "body": "vector<ll> Base(ll x, ll n, bool re = false) {\n  vector<ll> r;\n  while(x) {\n    r.emplace_back(x % n);\n    x /= n;\n  }\n  if(re) {ranges::reverse(r);}\n  return r;\n}"
  // },
  "base": {
    "prefix": "base",
    "body": "Base($1,$2)$0"
  },
  // "Prime": {
  //   "prefix": "Prime",
  //   "body": "vector<pair<ll, ll>> Prime(ll n) {\n  vector<pair<ll, ll>> r;\n  for(ll i = 2; i*i <= n; i++) {\n    if(n % i != 0) {continue;}\n    ll e = 0;\n    while(n % i == 0) {e++, n /= i;}\n    r.emplace_back(i, e);\n  }\n  if(n != 1) {r.emplace_back(n, 1);}\n  return r;\n}"
  // },
  "prime": {
    "prefix": "prime",
    "body": "Prime($0)"
  },
  "PriMap": {
    "prefix": "PriMap",
    "body": "map<ll, ll> PriMap(ll n) {\n  map<ll, ll> r;\n  for(ll i = 2; i*i <= n; i++) {\n    while(n % i == 0) {r[i]++, n /= i;}\n  }\n  if(n != 1){r[n] = 1;}\n  return r;\n}"
  },
  "primap": {
    "prefix": "primap",
    "body": "PriMap($0)"
  },
  // "Divisor": {
  //   "prefix": "Divisor",
  //   "body": "vector<ll> Divisor(ll n) {\n  vector<ll> r;\n  for(ll i = 1; i * i <= n; i++) {\n    if(n % i == 0) {\n      r.emplace_back(i);\n      if(i * i != n) {r.emplace_back(n / i);}\n    }\n  }\n  ranges::sort(r);\n  return r;\n}"
  // },
  "divisor": {
    "prefix": "div",
    "body": "Divisor($0)"
  },
  // "DivisorTable": {
  //   "prefix": "DivisorTable",
  //   "body": "vector<vector<int>> DivisorTable(int N) {\n  vector<vector<int>> r(N + 1);\n  for(int i = 1; i <= N; i++) {\n    for(int j = i; j <= N; j += i) { r[j].emplace_back(i); }\n  }\n  return r;\n}"
  // },
  // "Divcnt": {
  //   "prefix": "Divcnt",
  //   "body": "ll Divcnt(ll n, ll d) {\n  ll r = 0;\n  while(n % d == 0) {n /= d, r++;}\n  return r;\n}"
  // },
  "divcnt": {
    "prefix": "divcnt",
    "body": "Divcnt($1,$2)$0"
  },
  // "DigSum": {
  //   "prefix": "DigSum",
  //   "body": "ll DigSum(ll n){\n  ll r=0;\n  while(n){\n    r+=n%10;\n    n/=10;\n  }\n  return r;\n}"
  // },
  "digsum": {
    "prefix": "digsum",
    "body": "Digsum($0)"
  },
  // "EnumFloor": {
  //   "prefix": "EnumFloor",
  //   "body": "vector<tuple<ll, ll, ll>> EnumFloor(ll n) {\n  vector<tuple<ll, ll, ll>> ret;\n  ll l = 1;\n  while(l <= n) {\n    ll q = n / l, r = n / q + 1;\n    ret.push_back({l, r, q});\n    l = r;\n  }\n  return ret;\n}"
  // },
  "enumfloor": {
    "prefix": "enumfloor",
    "body": "EnumFloor($0)"
  },
  // "EnumCeil": {
  //   "prefix": "EnumCeil",
  //   "body": "vector<tuple<ll, ll, ll>> EnumCeil(ll n) {\n  vector<tuple<ll, ll, ll>> ret;\n  ll l = 1;\n  while(l <= n) {\n    ll q = (n + l - 1) / l, r = n + 1;\n    if(q != 1) { r = (n - 1) / (q - 1) + 1; }\n    ret.push_back({l, r, q});\n    l = r;\n  }\n  return ret;\n}"
  // },
  "enumceil": {
    "prefix": "enumceil",
    "body": "EnumCeil($0)"
  },
  "INF": {
    "prefix": "inf",
    "body": "1e18"
  },
  "FNI": {
    "prefix": "fni",
    "body": "-1e18"
  },
  // "LIS": {
  //   "prefix": "LIS",
  //   "body": "template<typename T> vector<ll> LIS(const vector<T> &v, bool strict = true) {\n  vector<T> lis;\n  vector<ll> pos;\n  for(const auto &i : v) {\n    auto it = (strict ? ranges::lower_bound(lis, i) : ranges::upper_bound(lis, i));\n    pos.emplace_back(it - lis.begin());\n    it == lis.end() ? lis.emplace_back(i) : *it = i;\n  }\n  vector<ll> idx(lis.size());\n  ll i = (int)idx.size() - 1, p = (int)pos.size() - 1;\n  while(i >= 0 && p >= 0) {\n    if(pos[p] == i) { idx[i--] = p; }\n    p--;\n  }\n  return idx;\n}"
  // },
  "DXDY4": {
    "prefix": "DXDY4",
    "body": "constexpr int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};"
  },
  "DXDY8": {
    "prefix": "DXDY8",
    "body": "constexpr int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1}, dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};"
  },
  "chmin_func": {
    "prefix": "chmin_func",
    "body": "auto chmin = [](auto &a, const auto &b) { return a > b ? (a = b, true) : false; };"
  },
  "chmax_func": {
    "prefix": "chmax_func",
    "body": "auto chmax = [](auto &a, const auto &b) { return a < b ? (a = b, true) : false; };"
  },
  "yn": {
    "prefix": "yn",
    "body": "cout << (${1:f} ? \"${2:Yes}\" : \"${3:No}\") << \"\\\\n\";$0"
  },
  "YN": {
    "prefix": "YN",
    "body": "cout << (${1:f} ? \"${2:YES}\" : \"${3:NO}\") << \"\\\\n\";$0"
  },
  "bitset": {
    "prefix": "bit",
    "body": "bitset<$1> $2($3);$0"
  },
  "floor_sum": {
    "prefix": "floor_sum",
    "body": "floor_sum(,,,); // (n,m,a,b) -> Σ i=0~n-1 floor((a*i+b)/m)"
  },
  "lambda": {
    "prefix": "lambda",
    "body": "auto ${1:f}=[&]($2){\n  $3\n};"
  },
  "lambda_": {
    "prefix": "Lambda",
    "body": "auto ${1:f}=[&](auto &&${1:f},$2)->$3{\n  $4\n};"
  },
  "binmax": {
    "prefix": "binmax",
    "body": "for(ll Lt = $1,Rt = $2;;) {\n  if(Rt - Lt <= 1) {\n    cout << Lt << \"\\\\n\";\n    break;\n  }\n  ll Mid = (Lt + Rt)/2;\n  bool flag = [&]() -> bool {\n    $0\n  }();\n  flag ? Lt = Mid : Rt = Mid;\n}"
  },
  "binmax_func": {
    "prefix": "binmax_func",
    "body": "[&] {\n  for(ll Lt = $1, Rt = $2;;) {\n    if(Rt - Lt <= 1) { return Lt; }\n    ll Mid = (Lt + Rt) / 2;\n    bool flag = [&]() -> bool {\n      $0\n    }();\n    flag ? Lt = Mid : Rt = Mid;\n  }\n}();"
  },
  "binmin": {
    "prefix": "binmin",
    "body": "for(ll Lt = $1, Rt = $2;;) {\n  if(Rt - Lt <= 1) {\n    cout << Rt << \"\\\\n\";\n    break;\n  }\n  ll Mid = (Lt + Rt)/2;\n  bool flag = [&]() -> bool {\n    $0\n  }();\n  flag ? Rt = Mid : Lt = Mid;\n}"
  },
  "binmin_func": {
    "prefix": "binmin_func",
    "body": "[&] {\n  for(ll Lt =, Rt = ;;) {\n    if(Rt - Lt <= 1) { return Rt; }\n    ll Mid = (Lt + Rt) / 2;\n    bool flag = [&]() -> bool {\n      $0\n    }();\n    flag ? Rt = Mid : Lt = Mid;\n  }\n}();"
  },
  "graph": {
    "prefix": "graph",
    "body": "vector<vector<ll>> g(${1:N});\nfor(ll i=0,u,v;i<${2:M};i++){\n  cin>>u>>v;\n  u--,v--;\n  g[u].emplace_back(v);\n  g[v].emplace_back(u);\n}$0"
  },
  "lgraph": {
    "prefix": "lgraph",
    "body": "ll ${1:N},${2:M};\ncin>>${1:N}>>${2:M};\nvector<vector<ll>> g(${1:N});\nfor(ll i=0,u,v;i<${2:M};i++){\n  cin>>u>>v;\n  u--,v--;\n  g[u].emplace_back(v);\n  g[v].emplace_back(u);\n}$0"
  },
  "tree": {
    "prefix": "tree",
    "body": "vector<vector<ll>> g(${1:N});\nfor(ll i=0,u,v;i<${1:N}-1;i++){\n  cin>>u>>v;\n  u--,v--;\n  g[u].emplace_back(v);\n  g[v].emplace_back(u);\n}$0"
  },
  "ltree": {
    "prefix": "ltree",
    "body": "ll ${1:N};\ncin>>${1:N};\nvector<vector<ll>> g(${1:N});\nfor(ll i=0,u,v;i<${1:N}-1;i++){\n  cin>>u>>v;\n  u--,v--;\n  g[u].emplace_back(v);\n  g[v].emplace_back(u);\n}$0"
  },
  "treeparent": {
    "prefix": "treeparent",
    "body": "vector<vector<ll>> g(${1:N});\nfor(ll i = 1, p; i < ${1:N}; i++) {\n  cin >> p;\n  p--;\n  g[p].emplace_back(i);\n  g[i].emplace_back(p);\n}$0"
  },
  "ltreeparent": {
    "prefix": "ltreeparent",
    "body": "ll ${1:N};\ncin>>${1:N};\nvector<vector<ll>> g(${1:N});\nfor(ll i = 1, p; i < ${1:N}; i++) {\n  cin >> p;\n  p--;\n  g[p].emplace_back(i);\n  g[i].emplace_back(p);\n}$0"
  },
  "wgraph": {
    "prefix": "wgraph",
    "body": "vector<vector<pair<ll,ll>>> g(${1:N});\nfor(ll i=0,u,v,w;i<${2:M};i++){\n  cin>>u>>v>>w;\n  u--,v--;\n  g[u].emplace_back(v,w);\n  g[v].emplace_back(u,w);\n}$0"
  },
  "lwgraph": {
    "prefix": "lwgraph",
    "body": "ll ${1:N},${2:m};\ncin>>${1:N}>>${2:m};\nvector<vector<pair<ll,ll>>> g(${1:N});\nfor(ll i=0,u,v,w;i<${2:M};i++){\n  cin>>u>>v>>w;\n  u--,v--;\n  g[u].emplace_back(v,w);\n  g[v].emplace_back(u,w);\n}$0"
  },
  "wtree": {
    "prefix": "wtree",
    "body": "vector<vector<pair<ll,ll>>> g(${1:N});\nfor(ll i=0,u,v,w;i<${1:N}-1;i++){\n  cin>>u>>v>>w;\n  u--,v--;\n  g[u].emplace_back(v,w);\n  g[v].emplace_back(u,w);\n}$0"
  },
  "lwtree": {
    "prefix": "lwtree",
    "body": "ll ${1:N};\ncin>>${1:N};\nvector<vector<pair<ll,ll>>> g(${1:N});\nfor(ll i=0,u,v,w;i<${1:N}-1;i++){\n  cin>>u>>v>>w;\n  u--,v--;\n  g[u].emplace_back(v,w);\n  g[v].emplace_back(u,w);\n}$0"
  },
  "DFS": {
    "prefix": "DFS",
    "body": "auto DFS = [&](auto &&DFS, ll v, ll p) -> void {\n  for(auto &nv : g[v]) {\n    if(nv != p) {DFS(DFS, nv, v);}\n  }\n};"
  },
  "DFS_tree": {
    "prefix": "DFS_tree",
    "body": "vector<ll> depth(n, -1);\nauto DFS = [&](auto &&DFS, ll v, ll p, ll d) -> void {\n  depth[v] = d;\n  for(auto &nv : g[v]) {\n    if(nv == p) {continue;}\n    DFS(DFS, nv, v, d + 1);\n  }\n};"
  },
  "DFS_tree_size": {
    "prefix": "DFS_tree_size",
    "body": "vector<ll> depth(n,-1),par(n,-1), order, tsiz(n);\nfunction<void(ll, ll, ll)> DFS = [&](ll v, ll p, ll d) {\n  depth[v] = d;\n  par[v]=p;\n  order.emplace_back(v);\n  for(auto &nv : g[v]) {\n    if(nv != p) {DFS(nv, v, d + 1);}\n  }\n  tsiz[v] = 1;\n  for(auto &nv : g[v]) {\n    if(nv != p) {tsiz[v] += tsiz[nv];}\n  }\n};"
  },
  "BFS_func": {
    "prefix": "BFS_func",
    "body": "auto BFS = [&](ll s) {\n  vector<ll> d(n, -1);\n  d[s] = 0;\n  queue<ll> q;\n  q.emplace(s);\n  while(!q.empty()) {\n    ll v = q.front();\n    q.pop();\n    for(auto &nv : g[v]) {\n      if(d[nv] == -1) {\n        d[nv] = d[v] + 1;\n        q.emplace(nv);\n      }\n    }\n  }\n  return d;\n};"
  },
  "BFS": {
    "prefix": "BFS",
    "body": "vector<ll> d(n, -1);\nd[0] = 0;\nqueue<ll> q;\nq.emplace(0);\nwhile(!q.empty()) {\n  ll v = q.front();\n  q.pop();\n  for(auto &nv : g[v]) {\n    if(d[nv] == -1) {\n      d[nv] = d[v] + 1;\n      q.emplace(nv);\n    }\n  }\n}"
  },
  "BFS_re_func": {
    "prefix": "BFS_re_func",
    "body": "auto BFS = [&](ll s, ll t) -> pair<vector<ll>, vector<ll>> {\n  vector<ll> d(n, -1), pre(n), path;\n  d[s] = 0;\n  queue<ll> q;\n  q.emplace(s);\n  while(!q.empty()) {\n    ll v = q.front();\n    q.pop();\n    for(auto &nv : g[v]) {\n      if(d[nv] == -1) {\n        d[nv] = d[v] + 1;\n        q.emplace(nv);\n        pre[nv] = v;\n      }\n    }\n  }\n  if(d[t] != -1) {\n    for(ll p = t; p != s; p = pre[p]) { path.emplace_back(p); }\n    path.emplace_back(s);\n    ranges::reverse(path);\n  }\n  return {d, path};\n};"
  },
  "BFS_re": {
    "prefix": "BFS_re",
    "body": "vector<ll> d(n, -1), pre(n), path;\nd[s] = 0;\nqueue<ll> q;\nq.emplace(s);\nwhile(!q.empty()) {\n  ll v = q.front();\n  q.pop();\n  for(auto &nv : g[v]) {\n    if(d[nv] == -1) {\n      d[nv] = d[v] + 1;\n      q.emplace(nv);\n      pre[nv] = v;\n    }\n  }\n}\nif(d[t] != -1) {\n  for(ll p = t; p != s; p = pre[p]) {path.emplace_back(p);}\n  path.emplace_back(s);\n  ranges::reverse(path);\n}"
  },
  "BFS_grid": {
    "prefix": "BFS_grid",
    "body": "constexpr ll DX[8]={0,0,1,-1,1,1,-1,-1},DY[8]={1,-1,0,0,1,-1,1,-1};\n\ntemplate<typename T> void BFS(vector<vector<T>> &g, vector<vector<ll>> &d, pair<ll, ll> s, T w, bool ini = 1) {\n  ll limx = g.size(), limy = g[0].size();\n  if(ini) d.assign(limx, vector<ll>(limy, 1e18));\n  d[s.first][s.second] = 0;\n  queue<pair<ll, ll>> q;\n  q.push(s);\n  while(!q.empty()) {\n    auto [x,y]=q.front();\n    q.pop();\n    for(ll i = 0; i < 4; i++) {\n      ll nx = x + DX[i], ny = y + DY[i];\n      if(nx < 0 || ny < 0 || nx >= limx || ny >= limy) {continue;}\n      if(g[nx][ny] == w) {continue;}\n      if(chmin(d[nx][ny], d[x][y] + 1)) {q.push({nx, ny});}\n    }\n  }\n}"
  },
  "01BFS_grid": {
    "prefix": "01BFS_grid",
    "body": "constexpr ll DX[8]={0,0,1,-1,1,1,-1,-1},DY[8]={1,-1,0,0,1,-1,1,-1};\n\ntemplate<typename T> void BFS(vector<vector<T>> &g, vector<vector<ll>> &d, pair<ll, ll> s, T w, bool ini = 1) {\n  ll limx = g.size(), limy = g[0].size();\n  if(ini) {d.assign(limx, vector<ll>(limy, 1e18));}\n  d[s.first][s.second] = 0;\n  deque<pair<ll, ll>> q;\n  q.push_back(s);\n  while(!q.empty()) {\n    auto [x,y]=q.front();\n    q.pop_front();\n    for(ll i = 0; i < 4; i++) {\n      ll nx = x + DX[i], ny = y + DY[i];\n      if(nx < 0 || ny < 0 || nx >= limx || ny >= limy) {continue;}\n      if(g[nx][ny] == w) {\n        if(chmin(d[nx][ny], d[x][y] + 1)) {q.push_back({nx, ny});}\n      }\n      else if(chmin(d[nx][ny], d[x][y])) {q.push_front({nx, ny});}\n    }\n  }\n}"
  },
  "Dijkstra": {
    "prefix": "Dijkstra",
    "body": "vector<ll> d(N, 1e18);\nd[${1:0}] = 0;\nauto chmin = [&](auto &a, const auto &b) { return a > b ? (a = b, true) : false; };\npriority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;\nq.emplace(0, ${1:0});\nwhile(!q.empty()) {\n  auto [tmp, v] = q.top();\n  q.pop();\n  if(tmp > d[v]) {continue;}\n  for(auto &[nv, c] : g[v]) {\n    if(chmin(d[nv], d[v] + c)) {q.emplace(d[nv], nv);}\n  }\n}$0"
  },
  "Dijkstra_func": {
    "prefix": "Dijkstra_func",
    "body": "auto Dijkstra = [&](ll s) {\n  auto chmin = [&](auto &a, const auto &b) { return a > b ? (a = b, true) : false; };\n  vector<ll> d(N, 1e18);\n  d[s] = 0;\n  priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;\n  q.emplace(0, s);\n  while(!q.empty()) {\n    auto [tmp, v] = q.top();\n    q.pop();\n    if(tmp > d[v]) { continue; }\n    for(auto &[nv, c] : g[v]) {\n      if(chmin(d[nv], d[v] + c)) { q.emplace(d[nv], nv); }\n    }\n  }\n  return d;\n};"
  },
  "Dijkstra_re": {
    "prefix": "Dijkstra_re",
    "body": "template<typename T> vector<ll> Dijkstra_re(vector<vector<pair<ll,T>>> &g, vector<T> &d, ll s, ll t, bool ini = 1) {  // O(E log V)\n  vector<ll> pre(g.size()), re;\n  if(ini) {d.assign(g.size(), 1e18);}\n  d[s] = 0;\n  priority_queue<pair<T, ll>, vector<pair<T, ll>>, greater<pair<T, ll>>> q;\n  q.push({T(0), s});\n  while(!q.empty()) {\n    pair<T, ll> p = q.top();\n    q.pop();\n    ll v = p.second;\n    if(p.first > d[v]) {continue;}\n    for(auto &[nv,c] : g[v]) {\n      if(chmin(d[nv], d[v] + c)) {\n        q.push({d[nv], nv});\n        pre[nv] = v;\n      }\n    }\n  }\n  if(d[t] != 1e18) {\n    for(ll p = t; p != s; p = pre[p]) {re.emplace_back(p);}\n    re.emplace_back(s);\n    ranges::reverse(re);\n  }\n  return re;\n}"
  },
  "BellmanFord": {
    "prefix": "BellmanFord",
    "body": "template<typename T> bool BellmanFord(vector<vector<pair<ll,T>>> &g, vector<T> &d, ll s = 0, bool ini = 1) {  // O(VE)\n  bool nega_cycle = false;\n  ll n = g.size();\n  if(ini) {d.assign(n, 1e18);}\n  d[s] = 0;\n  for(ll i = 0; i < n; i++) {\n    bool update = 0;\n    for(ll v = 0; v < n; v++) {\n      if(d[v] == 1e18) {continue;}\n      for(auto &[nv,c] : g[v]) {\n        if(chmin(d[nv], d[v] + c)) {update = 1;}\n      }\n    }\n    if(!update) {break;}\n    if(i == n - 1) {nega_cycle = true;}\n  }\n  return nega_cycle;\n}"
  },
  "bellmanford": {
    "prefix": "bellmanford",
    "body": "BellmanFord(g,d);"
  },
  "WarshallFroyd": {
    "prefix": "WarshallFroyd",
    "body": "template<typename T> vector<vector<T>> WarshallFroyd(vector<vector<pair<ll,T>>> &g) {  // O(V^3)\n  ll n = g.size();\n  vector<vector<T>> w(n, vector<T>(n, 1e18));\n  for(ll i = 0; i < n; i++) {w[i][i] = 0;}\n  for(ll i = 0; i < n; i++) {\n    for(auto &[j,c] : g[i]) {w[i][j] = c;}\n  }\n  for(ll via = 0; via < n; via++) {\n    for(ll i = 0; i < n; i++) {\n      for(ll j = 0; j < n; j++) {w[i][j]=min(w[i][j], w[i][via] + w[via][j]);}\n    }\n  }\n  return w;\n}"
  },
  "warshallfroyd": {
    "prefix": "warshallfroyd",
    "body": "WarshallFroyd(g)"
  },
  "WarshallFroyd_re": {
    "prefix": "WarshallFroyd_re",
    "body": "template<typename T> vector<vector<T>> WarshallFroyd(vector<vector<pair<ll,T>>> &g, vector<vector<ll>> &pre) {\n  ll n = g.size();\n  vector<vector<T>> w(n, vector<T>(n, 1e18));\n  for(ll i = 0; i < n; i++) {\n    vector<ll> p(n, i);\n    pre.emplace_back(p);\n  }\n  for(ll i = 0; i < n; i++) {w[i][i] = 0;}\n  for(ll i = 0; i < n; i++) {\n    for(auto &[j,c] : g[i]) {w[i][j] = c;}\n  }\n  for(ll via = 0; via < n; via++) {\n    for(ll i = 0; i < n; i++) {\n      for(ll j = 0; j < n; j++) {\n        if(chmin(w[i][j], w[i][via] + w[via][j])) {pre[i][j] = pre[via][j];}\n      }\n    }\n  }\n  return w;\n}\nvector<ll> WarshallFroyd_re(vector<vector<ll>> &pre, ll s, ll t) {\n  vector<ll> r;\n  for(ll p = t; p != s; p = pre[s][p]) {r.emplace_back(p);}\n  r.emplace_back(s);\n  ranges::reverse(r);\n  return r;\n}"
  },
  "warshallfroyd_re": {
    "prefix": "warshallfroyd_re",
    "body": "WarshallFroyd_re(pre,$1,$2)"
  },
  // "Topological_sort": {
  //   "prefix": "Topological_sort",
  //   "body": "vector<ll> sort(vector<vector<ll>> &g) {\n  ll n = g.size();\n  vector<ll> r, e(n);\n  priority_queue<ll, vector<ll>, greater<ll>> q;\n  for(ll i = 0; i < n; i++) {\n    for(auto &v : g[i]) {e[v]++;}\n  }\n  for(ll i = 0; i < n; i++) {\n    if(e[i] == 0) {q.emplace(i);}\n  }\n  while(!q.empty()) {\n    ll v = q.top();\n    q.pop();\n    r.emplace_back(v);\n    for(auto &nv : g[v]) {\n      e[nv]--;\n      if(e[nv] == 0) {q.emplace(nv);}\n    }\n  }\n  return r;\n}"
  // },
  // "Topological_sort_w": {
  //   "prefix": "Topological_sort_w",
  //   "body": "template<typename T> vector<ll> sort(vector<vector<pair<ll,T>>> &g) {\n  ll n = g.size();\n  vector<ll> r, e(n);\n  priority_queue<ll, vector<ll>, greater<ll>> q;\n  for(ll i = 0; i < n; i++) {\n    for(auto &v : g[i]) {e[v.second]++;}\n  }\n  for(ll i = 0; i < n; i++) {\n    if(e[i] == 0) {q.emplace(i);}\n  }\n  while(!q.empty()) {\n    ll v = q.top();\n    q.pop();\n    r.emplace_back(v);\n    for(auto &[nv,c] : g[v]) {\n      e[nv]--;\n      if(e[nv] == 0) {q.emplace(nv);}\n    }\n  }\n  return r;\n}"
  // },
  // "TreeDiameter": {
  //   "prefix": "TreeDiameter",
  //   "body": "ll TreeDiameter(vector<vector<ll>> &g) {\n  vector<ll> D(g.size(), -1);\n  function<void(ll, ll)> DFS = [&](ll v, ll d) {\n    D[v] = d;\n    for(auto &nv : g[v]) {\n      if(D[nv] < 0) {DFS(nv, d + 1);}\n    }\n  };\n  DFS(0, 0);\n  ll v = ranges::max_element(D) - D.begin();\n  D.assign(g.size(), -1);\n  DFS(v, 0);\n  return ranges::max(D);\n}"
  // },
  // "TreeDiameter_w": {
  //   "prefix": "TreeDiameter_w",
  //   "body": "pair<pair<ll, ll>, ll> TreeDiameter(vector<vector<pair<ll, ll>>> &g) {\n  vector<ll> D(g.size(), -1);\n  function<void(ll, ll)> DFS = [&](ll v, ll d) {\n    D[v] = d;\n    for(auto &[nv, c] : g[v]) {\n      if(D[nv] < 0) {DFS(nv, d + c);}\n    }\n  };\n  DFS(0, 0);\n  ll v = ranges::max_element(D) - D.begin();\n  D.assign(g.size(), -1);\n  DFS(v, 0);\n  ll u = ranges::max_element(D) - D.begin();\n  ll w = ranges::max(D);\n  return {{u, v}, w};\n}"
  // },
  // "Bipartite": {
  //   "prefix": "Bipartite",
  //   "body": "vector<ll> Bipartite(vector<vector<ll>>& g) {\n  ll n = g.size();\n  vector<ll> color(n, -1);\n  function<bool(ll, ll)> DFS = [&](ll v, ll c) {\n    color[v] = c;\n    for(auto &nv : g[v]) {\n      if(color[nv] != -1) {\n        if(color[nv] == c) {return false;}\n        continue;\n      }\n      if(!DFS(nv, 1 - c)) {return false;}\n    }\n    return true;\n  };\n  for(ll i = 0; i < n; i++) {\n    if(color[i] == -1) {\n      if(!DFS(i, 0)) {return {};}\n    }\n  }\n  return color;\n}"
  // },
  "bipartite": {
    "prefix": "bipartite",
    "body": "Bipartite(g);"
  },
  // "LagrangePolynomial": {
  //   "prefix": "Lagrange",
  //   "body": "template<typename T> mint LagrangePolynomial(vector<T> &v, ll x) {\n  ll N = v.size() - 1;\n  mint r = 0;\n  if(x <= N) { return v[x]; }\n  vector<mint> dp(N + 1, 1), pd(N + 1, 1);\n  for(ll i = 0; i < N; i++) { dp[i + 1] = dp[i] * (x - i); }\n  for(ll i = N; i >= 1; i--) { pd[i - 1] = pd[i] * (x - i); }\n  for(ll i = 0; i <= N; i++) {\n    mint t = dp[i] * pd[i] * C(-i) * C(i - N) * v[i];\n    r += (N - i) & 1 ? -t : t;\n  }\n  return r;\n}\n// depends on : Binomial"
  // },
  "lagrangepolynomial": {
    "prefix": "lagrange",
    "body": "LagrangePolynomial($1,$2)"
  },
  "Fibo": {
    "prefix": "Fibo",
    "body": "template<typename T = mint> T Fibo(ll n) {\n  vector<vector<T>> v = {{1, 1}, {1, 0}};\n  Matrix<T> M(v);\n  M ^= (n - 1);\n  return M[0][0];\n}\n// depends on : Matrix"
  },
  "fibo": {
    "prefix": "fibo",
    "body": "Fibo($0);"
  },
  "mypq": {
    "prefix": "mypq",
    "body": "auto compare=[](auto x,auto y){return $0;}; // condition to put y near top\npriority_queue<$1,vector<$1>,decltype(compare)> q(compare);"
  },
  // "RNG": {
  //   "prefix": "RNG",
  //   "body": "struct RNG{\n  mt19937 mt;\n  RNG():mt(chrono::steady_clock::now().time_since_epoch().count()){}\n  int operator()(int a,int b){uniform_int_distribution<int>dist(a,b);return dist(mt);}\n  int operator()(int b){return(*this)(0,b);}\n}rng;"
  // },
  // "RPG": {
  //   "prefix": "RPG",
  //   "body": "#include <atcoder/internal_math>\nint RPG(int l, int r = 2e9) {\n  int p = rng(l, r);\n  if(atcoder::internal::is_prime_constexpr(p)) { return p; }\n  return RPG(l, r);\n}"
  // },
  // "Inversion": {
  //   "prefix": "Inversion",
  //   "body": "template<typename T> vector<T> Compress(vector<T> &v) {\n  vector<T> r = v;\n  ranges::sort(r);\n  r.erase(unique(r.begin(), r.end()), r.end());\n  for(auto &i : v) { i = ranges::lower_bound(r, i) - r.begin(); }\n  return r;\n}\n\nll Inversion(vector<ll> &v) {\n  ll r = 0, n = v.size();\n  // Compress(v);\n  fenwick_tree<ll> b(n + 1);\n  for(ll i = 0; i < n; i++) {\n    r += b.sum(v[i] + 1, n + 1);\n    b.add(v[i], 1);\n  }\n  return r;\n}"
  // },
  "inversion": {
    "prefix": "inversion",
    "body": "Inversion($0)"
  },
  "Unionfind": {
    "prefix": "Unionfind",
    "body": "struct Unionfind {\n  vector<ll> par, nxt;\n  ll e = 0, v;\n  Unionfind(ll n): par(n, -1), nxt(n), v(n) { iota(nxt.begin(), nxt.end(), 0); }\n  ll root(ll x) { return par[x] < 0 ? x : par[x] = root(par[x]); }\n  void unite(ll x, ll y) {\n    x = root(x), y = root(y);\n    if(x == y) { return; }\n    if(par[x] > par[y]) { swap(x, y); }\n    par[x] += par[y];\n    par[y] = x;\n    swap(nxt[x], nxt[y]);\n    e++;\n  }\n  bool same(ll x, ll y) { return root(x) == root(y); }\n  ll size(ll x) { return -par[root(x)]; }\n  vector<ll> group(ll x) {\n    vector<ll> r{x};\n    for(int i = nxt[x]; i != x; i = nxt[i]) { r.push_back(i); }\n    return r;\n  }\n  vector<vector<ll>> groups() {\n    vector<vector<ll>> r(v);\n    for(ll i = 0; i < v; i++) { r[root(i)].emplace_back(i); }\n    r.erase(remove_if(begin(r), end(r), [&](vector<ll> &r_) { return r_.empty(); }));\n    return r;\n  }\n  ll operator[](ll i) { return root(i); }\n  ll operator()() { return v - e; }\n};"
  },
  "unionfind": {
    "prefix": "unionfind",
    "body": "Unionfind u(n);"
  },
  "CycleCheck": {
    "prefix": "cycle",
    "body": "bool CycleCheck(graph &g) {\n  Unionfind u(g.size());\n  for(ll i = 0; i < g.size(); i++) {\n    for(auto &j : g[i]) {\n      if(i < j && u.same(i, j)) {return true;}\n      u(i, j);\n    }\n  }\n  return false;\n}\n// depends on : graph , Unionfind"
  },
  // "Rollback_Unionfind": {
  //   "prefix": "Rollback_Unionfind",
  //   "body": "template<typename S, auto op, auto e> struct RollbackUnionfind {\n private:\n  vector<int> par;\n  vector<S> val;\n  stack<tuple<int, int, S, int>> history;\n  int snap, cnt;\n\n public:\n  RollbackUnionfind() = default;\n  RollbackUnionfind(int n): RollbackUnionfind(vector<S>(n, e())) {}\n  RollbackUnionfind(const vector<S> &v): par(v.size(), -1), val(v), snap(0), cnt(v.size()) {}\n  int root(int v) const {\n    if(par[v] < 0) { return v; }\n    return root(par[v]);\n  }\n  void unite(int u, int v) {\n    u = root(u), v = root(v);\n    history.emplace(-1, 0, e(), cnt);\n    history.emplace(u, par[u], val[u], cnt);\n    history.emplace(v, par[v], val[v], cnt);\n    if(u == v) { return; }\n    if(par[u] > par[v]) { swap(u, v); }\n    par[u] += par[v];\n    par[v] = u;\n    val[u] = op(val[u], val[v]);\n    cnt--;\n  }\n  void undo() {\n    assert(!history.empty());\n    while(true) {\n      auto [v, p, x, c] = history.top();\n      history.pop();\n      if(v == -1) { break; }\n      par[v] = p;\n      val[v] = x;\n      cnt = c;\n    }\n  }\n  bool same(int u, int v) const { return root(u) == root(v); }\n  int size(int v) const { return -par[root(v)]; }\n  int count() const { return cnt; }\n  S prod(int v) const { return val[root(v)]; }\n  void update(int v, const S &x) {\n    v = root(v);\n    history.emplace(-1, 0, e(), cnt);\n    history.emplace(v, par[v], val[v], cnt);\n    val[v] = op(val[x], x);\n  }\n  int state() const { return history.size(); }\n  void snapshot() { snap = history.size(); }\n  void rollback(int p = -1) {\n    if(p == -1) { p = snap; }\n    while(p < (int)history.size()) { undo(); }\n  }\n};"
  // },
  // "rollback_unionfind": {
  //   "prefix": "rollback_unionfind",
  //   "body": "RollbackUnionfind<S,op,e> u(N);"
  // },
  "WeightedUnionfind": {
    "prefix": "WeightedUnionfind",
    "body": "template<typename T> struct WeightedUnionfind {\n  vector<ll> par, rank;\n  vector<T> diff_;\n  WeightedUnionfind(ll n): par(n), rank(n), diff_(n) {\n    for(ll i = 0; i < n; i++) {par[i] = i, rank[i] = 0, diff_[i] = 0;}\n  }\n  ll root(ll x) {\n    if(par[x] == x) {return x;}\n    else {\n      ll r = root(par[x]);\n      diff_[x] += diff_[par[x]];\n      return par[x] = r;\n    }\n  }\n  T weight(ll x) {\n    root(x);\n    return diff_[x];\n  }\n  void unite(ll x, ll y, T w) { // y - x = w\n    w += weight(x) - weight(y);\n    x = root(x), y = root(y);\n    if(x == y) {return;}\n    if(rank[x] < rank[y]) {swap(x, y), w = -w;}\n    if(rank[x] == rank[y]) {rank[x]++;}\n    par[y] = x;\n    diff_[y] = w;\n  }\n  void unite(pair<ll, ll> x, T w) { unite(x.first, x.second, w); }\n  bool same(ll x, ll y) { return root(x) == root(y); }\n  bool same(pair<ll, ll> x) { return same(x.first, x.second); }\n  T diff(ll x, ll y) { return weight(y) - weight(x); }\n};"
  },
  "weightedunionfind": {
    "prefix": "weightedunionfind",
    "body": "WeightedUnionfind<ll> u(n);"
  },
  // "LCA": {
  //   "prefix": "LCA",
  //   "body": "struct LCA {\n  vector<vector<ll>> par;\n  vector<ll> di, order, tsiz;\n  LCA(graph &g, ll r = 0) { ini(g, r); }\n  void ini(graph &g, ll r = 0) {\n    ll s = g.size(), h = 1;\n    while((1LL << h) < s) {h++;}\n    par.assign(h, vector<ll>(s, -1));\n    di.assign(s, -1);\n    tsiz.resize(s);\n    dfs(g, r, -1, 0);\n    for(ll i = 0; i < h - 1; i++) {\n      for(ll j = 0; j < s; j++) {\n        if(par[i][j] < 0) {par[i + 1][j] = -1;}\n        else {par[i + 1][j] = par[i][par[i][j]];}\n      }\n    }\n  }\n  void dfs(graph &g, ll v, ll p, ll d) {\n    par[0][v] = p;\n    di[v] = d;\n    order.emplace_back(v);\n    for(auto &nv : g[v]) {\n      if(nv != p) {dfs(g, nv, v, d + 1);}\n    }\n    // tsiz[v] = 1; for(auto &nv : g[v]) {if(nv != p) {tsiz[v] += tsiz[nv];}}\n  }\n  ll lca(ll x, ll y) {\n    if(di[x] < di[y]) swap(x, y);\n    ll k = par.size();\n    for(ll i = 0; i < k; i++) {\n      if((di[x] - di[y]) >> i & 1) {x = par[i][x];}\n    }\n    if(x == y) return x;\n    for(ll i = k - 1; i >= 0; i--) {\n      if(par[i][x] != par[i][y]) {x = par[i][x], y = par[i][y];}\n    }\n    return par[0][x];\n  }\n  ll dis(ll x, ll y) { return di[x] + di[y] - 2 * di[lca(x, y)]; }\n  bool onpath(ll x, ll y, ll p) { return dis(x, p) + dis(p, y) == dis(x, y); }\n  ll operator()(ll x, ll y) { return dis(x, y); }\n  bool operator()(ll x, ll y, ll p) { return onpath(x, y, p); }\n};\n// depends on : graph"
  // },
  // "LCA_w": {
  //   "prefix": "LCA_w",
  //   "body": "template<typename T> struct LCA {\n  vector<vector<ll>> par;\n  vector<ll> di, order, tsiz;\n  vector<T> DI;\n  LCA(vector<vector<pair<ll,T>>> &g, ll r = 0) { ini(g, r); }\n  void ini(vector<vector<pair<ll,T>>> &g, ll r = 0) {\n    ll s = g.size(), h = 1;\n    while((1LL << h) < s) {h++;}\n    par.assign(h, vector<ll>(s, -1));\n    di.assign(s, -1);\n    DI.assign(s, -1);\n    tsiz.resize(s);\n    dfs(g, r, -1, 0, 0);\n    for(ll i = 0; i < h - 1; i++) {\n      for(ll j = 0; j < s; j++) {\n        if(par[i][j] < 0) {par[i + 1][j] = -1;}\n        else {par[i + 1][j] = par[i][par[i][j]];}\n      }\n    }\n  }\n  void dfs(vector<vector<pair<ll,T>>> &g, ll v, ll p, ll d, T D) {\n    par[0][v] = p;\n    di[v] = d;\n    DI[v] = D;\n    order.emplace_back(v);\n    for(auto &nv : g[v]) {\n      if(nv.first != p) {dfs(g, nv.first, v, d + 1, D + nv.second);}\n    }\n    // tsiz[v]=1; for(auto &nv:g[v]) {if(nv.first!=p){ tsiz[v]+=tsiz[nv.first];}}\n  }\n  ll lca(ll x, ll y) {\n    if(di[x] < di[y]) {swap(x, y);}\n    ll k = par.size();\n    for(ll i = 0; i < k; i++) {\n      if((di[x] - di[y]) >> i & 1) {x = par[i][x];}\n    }\n    if(x == y) {return x;}\n    for(ll i = k - 1; i >= 0; i--) {\n      if(par[i][x] != par[i][y]){ x = par[i][x], y = par[i][y];}\n    }\n    return par[0][x];\n  }\n  T dis(ll x, ll y) { return DI[x] + DI[y] - 2 * DI[lca(x, y)]; }\n  bool onpath(ll x, ll y, ll p) { return dis(x, p) + dis(p, y) == dis(x, y); }\n  T operator()(ll x, ll y) { return dis(x, y); }\n  bool operator()(ll x, ll y, ll p) { return onpath(x, y, p); }\n};\n// depends on : weighted_graph\n"
  // },
  // "RectangleSum": {
  //   "prefix": "RectangleSum",
  //   "body": "template<typename T> struct RectangleSum {\n  int H, W;\n  vector<vector<T>> v;\n  RectangleSum(int h, int w): H(h), W(w), v(H + 3, vector<T>(W + 3, 0)) {}\n  RectangleSum(vector<vector<T>> &ini): H(ini.size()), W(ini[0].size()), v(H + 3, vector<T>(W + 3, 0)) {\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) { v[i + 1][j + 1] += ini[i][j]; }\n    }\n    build();\n  }\n  void add(int x, int y, T a = 1) { v[x + 1][y + 1] += a; }\n  void imos_add(int lx, int rx, int ly, int ry, T a = 1) { add(lx, ly, a), add(lx, ry, -a), add(rx, ly, -a), add(rx, ry, a); }\n  void build() {\n    for(int i = 1; i < (int)v.size(); i++) {\n      for(int j = 1; j < (int)v[i].size(); j++) { v[i][j] += v[i][j - 1] + v[i - 1][j] - v[i - 1][j - 1]; }\n    }\n  }\n  T sum(int lx, int rx, int ly, int ry) const { return v[rx][ry] - v[lx][ry] - v[rx][ly] + v[lx][ly]; }\n  T operator()(int lx, int rx, int ly, int ry) const { return v[rx][ry] - v[lx][ry] - v[rx][ly] + v[lx][ly]; }\n  T imos_get(int x, int y) { return v[x + 1][y + 1]; }\n  vector<vector<T>> imos() const { return v; }\n};\n// 0-indexed, 半開区間\n// add / imos_add -> build -> sum / get , 併用不可"
  // },
  "rectanglesum": {
    "prefix": "rectanglesum",
    "body": "RectangleSum<ll> S($0);"
  },
  "BIT": {
    "prefix": "BIT",
    "body": "template<typename T> struct BIT {\n  vector<T> v;\n  ll n;\n  bool imos;\n  BIT(ll n_, bool imos_ = 0): v(n_ + 1, 0), n(n_ + 1), imos(imos_) {}\n  BIT(vector<T> &a, bool imos_ = 0): v(a.size() + 1, 0), n(v.size()), imos(imos_) {\n    if(!imos) {\n      for(ll i = 0; i < a.size(); i++) {add(i, a[i]);}\n    }\n    else {\n      for(ll i = 0; i < a.size(); i++) {imos_add(i, a[i]);}\n    }\n  }\n  void add(ll i, T x) {\n    for(i++; i < n; i += (i & -i)) {v[i] += x;}\n  }\n  void imos_add(ll l, ll r, T x) {\n    imos = true;\n    add(l, x), add(r + 1, -x);\n  }\n  void imos_add(ll i, T x) { imos_add(i, i, x); }\n  T sum(ll r) {  // sum[0,r] imos:v[r]\n    T re = T();\n    for(r++; r > 0; r -= (r & -r)) {re += v[r];}\n    return re;\n  }\n  T sum(ll l, ll r) { return sum(r) - sum(l - 1); }  // sum[l,r]\n  T operator()(ll r) { return sum(r); }\n  T operator()(ll l, ll r) { return sum(l, r); }\n  T operator[](ll i) { return imos ? sum(i) : sum(i) - sum(i - 1); }\n  ll LB(T x) {  // sum[0,i]<xとなるiの個数 / sum[0,i]>=xとなる最小のi\n    ll i = 0;\n    for(ll k = 1 << (__lg(n - 1) + 1); k > 0; k >>= 1) {\n      if(i + k < n && v[i + k] < x) {\n        x -= v[i + k];\n        i += k;\n      }\n    }\n    return i;\n  }\n  ll UB(T x) {  // sum[0,i]<=xとなるiの個数 / sum[0,i]>xとなる最小のi\n    ll i = 0;\n    for(ll k = 1 << (__lg(n - 1) + 1); k > 0; k >>= 1) {\n      if(i + k < n && v[i + k] <= x) {\n        x -= v[i + k];\n        i += k;\n      }\n    }\n    return i;\n  }\n};"
  },
  "BIT_": {
    "prefix": "bit",
    "body": "BIT<ll> b(n);"
  },
  // "BIT2D": {
  //   "prefix": "BIT2D",
  //   "body": "template<typename T> struct BIT2D {\n  int H, W;\n  vector<vector<T>> bit;\n  BIT2D(int h, int w): H(h + 1), W(w + 1) { bit.resize(H + 3, vector<T>(W + 3, T(0))); };\n  BIT2D(vector<vector<T>> v): H(v.size()), W(v[0].size()) {\n    bit.resize(H + 3, vector<T>(W + 3, T(0)));\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) { add(i, j, v[i][j]); }\n    }\n  };\n  void add(int x, int y, T w) {\n    if(x < 0 || y < 0 || x >= H || y >= W) { return; }\n    for(int a = (++y, ++x); a <= H; a += a & -a) {\n      for(int b = y; b <= W; b += b & -b) { bit[a][b] += w; }\n    }\n  }\n  void imos_add(int lx, int rx, int ly, int ry, T w) { add(lx, ly, w), add(lx, ry, -w), add(rx, ly, -w), add(rx, ry, w); }\n  void imos_add(int x, int y, T w) { imos_add(x, y, x, y, w); }\n  T sum(int x, int y) {\n    x--, y--;\n    T r = 0;\n    for(int a = (++y, ++x); a > 0; a -= a & -a) {\n      for(int b = y; b > 0; b -= b & -b) { r += bit[a][b]; }\n    }\n    return r;\n  }\n  T sum(int lx, int rx, int ly, int ry) { return sum(rx, ry) - sum(rx, ly) - sum(lx, ry) + sum(lx, ly); }\n  T imos_get(int x, int y) { return sum(++x, ++y); }\n};"
  // },
  "bit2d": {
    "prefix": "bit2d",
    "body": "BIT2D<ll> B(h,w);"
  },
  "Segtree": {
    "prefix": "Segtree",
    "body": "using T = ll;\n// struct T{};\nT op(T l, T r) { return $1; }\nT e() { return $2; }\nT tar;\nbool F(T x) { return $3; }\n\n// void set(i,x)        : a[i] = x;\n// T    get(i)          : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// int  max_right<F>(l) : return F(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<F>(r)  : return F(op(a[l], ... , a[r - 1])) = true となる最小の l"
  },
  "segtree": {
    "prefix": "segtree",
    "body": "segtree<T,op,e> S($0);"
  },
  "Lazy_add_min": {
    "prefix": "Lazy_add_min",
    "body": "using T = ll;\nusing F = ll;\nT op(T l,T r){return min(l,r);}\nT e(){return 1e18;}\nT fx(F f,T x){return f+x;}\nF fg(F f,F g){return f+g;}\nF id(){return 0;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_add_max": {
    "prefix": "Lazy_add_max",
    "body": "using T = ll;\nusing F = ll;\nT op(T l,T r){return max(l,r);}\nT e(){return -1e18;}\nT fx(F f,T x){return f+x;}\nF fg(F f,F g){return f+g;}\nF id(){return 0;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_add_sum": {
    "prefix": "Lazy_add_sum",
    "body": "struct T{ll val,siz;};\nusing F = ll;\nT op(T l,T r){return {l.val+r.val,l.siz+r.siz};}\nT e(){return {0,0};}\nT fx(F f,T x){return {x.val+f*x.siz,x.siz};}\nF fg(F f,F g){return f+g;}\nF id(){return 0;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n\n// vector<T> a(N,{0,1});\n"
  },
  "Lazy_update_min": {
    "prefix": "Lazy_update_min",
    "body": "using T = ll;\nusing F = ll;\nT op(T l,T r){return min(l,r);}\nT e(){return 1e18;}\nT fx(F f,T x){return (f==1e18?x:f);}\nF fg(F f,F g){return (f==1e18?g:f);}\nF id(){return 1e18;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_update_max": {
    "prefix": "Lazy_update_max",
    "body": "using T = ll;\nusing F = ll;\nT op(T l,T r){return max(l,r);}\nT e(){return -1e18;}\nT fx(F f,T x){return (f==1e18?x:f);}\nF fg(F f,F g){return (f==1e18?g:f);}\nF id(){return 1e18;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_update_sum": {
    "prefix": "Lazy_update_sum",
    "body": "struct T{ll val,siz;};\nusing F = ll;\nT op(T l,T r){return {l.val+r.val,l.siz+r.siz};}\nT e(){return {0,0};}\nT fx(F f,T x){if(f!=1e18) x.val=f*x.siz; return x;}\nF fg(F f,F g){return (f==1e18?g:f);}\nF id(){return 1e18;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n\n// vector<T> a(N,{0,1});\n"
  },
  "Lazy_chmax_min": {
    "prefix": "Lazy_chmax_min",
    "body": "using T = ll;\nusing F = ll;\nT op(T l,T r){return min(l,r);}\nT e(){return 1e18;}\nT fx(F f,T x){return max(f,x);}\nF fg(F f,F g){return max(f,g);}\nF id(){return -1e18;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_chmax_max": {
    "prefix": "Lazy_chmax_max",
    "body": "using T = ll;\nusing F = ll;\nT op(T l,T r){return max(l,r);}\nT e(){return -1e18;}\nT fx(F f,T x){return max(f,x);}\nF fg(F f,F g){return max(f,g);}\nF id(){return -1e18;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_chmin_min": {
    "prefix": "Lazy_chmin_min",
    "body": "using T = ll;\nusing F = ll;\nT op(T l,T r){return min(l,r);}\nT e(){return 1e18;}\nT fx(F f,T x){return min(f,x);}\nF fg(F f,F g){return min(f,g);}\nF id(){return 1e18;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_chmin_max": {
    "prefix": "Lazy_chmin_max",
    "body": "using T = ll;\nusing F = ll;\nT op(T l,T r){return max(l,r);}\nT e(){return -1e18;}\nT fx(F f,T x){return min(f,x);}\nF fg(F f,F g){return min(f,g);}\nF id(){return 1e18;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_affine_max": {
    "prefix": "Lazy_affine_max",
    "body": "using T = ll;\nusing F = pair<ll, ll>;\nT op(T l, T r) { return max(l, r); }\nT e() { return -1e18; }\nT fx(F f, T x) { return f.first * x + f.second; }\nF fg(F f, F g) { return {f.first * g.first, f.first * g.second + f.second}; }\nF id() { return {1, 0}; }\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_affine_min": {
    "prefix": "Lazy_affine_min",
    "body": "using T = ll;\nusing F = pair<ll, ll>;\nT op(T l, T r) { return min(l, r); }\nT e() { return 1e18; }\nT fx(F f, T x) { return f.first * x + f.second; }\nF fg(F f, F g) { return {f.first * g.first, f.first * g.second + f.second}; }\nF id() { return {1, 0}; }\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_affine_sum": {
    "prefix": "Lazy_affine_sum",
    "body": "struct T { ll val, siz; };\nusing F = pair<ll, ll>;\nT op(T l, T r) { return {l.val + r.val, l.siz + r.siz}; }\nT e() { return {0, 0}; }\nT fx(F f, T x) { return {f.first * x.val + f.second * x.siz, x.siz}; }\nF fg(F f, F g) { return {f.first * g.first, f.first * g.second + f.second}; }\nF id() { return {1, 0}; }\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "Lazy_void": {
    "prefix": "Lazy_void",
    "body": "using T = ll;\nusing F = ll;\nT op(T l,T r){return ;}\nT e(){return ;}\nT fx(F f,T x){return ;}\nF fg(F f,F g){return ;}\nF id(){return ;}\n\n// void set(i,x);       : a[i] = x;\n// T    get(i);         : return a[i];\n// T    prod(l,r)       : return op(a[l], ... , a[r - 1]);\n// T    all_prod()      : return op(a[0], ... , a[n - 1]);\n// void apply(i,f)      : a[i] = f(a[i]);\n// void apply(l,r,f)    : a[i] = f(a[i]) (l <= i < r);\n// int  max_right<f>(l) : return f(op(a[l], ... , a[r - 1])) = true となる最大の r\n// int  min_left<f>(r)  : return f(op(a[l], ... , a[r - 1])) = true となる最小の l\n"
  },
  "lazy_segtree": {
    "prefix": "lazy_segtree",
    "body": "lazy_segtree<T,op,e,F,fx,fg,id> S($0);"
  },
  // "Mo": {
  //   "prefix": "Mo",
  //   "body": "struct Mo {\n  int N, Q, W;\n  vector<int> L, R, O;\n  bool built;\n\n private:\n  void sort() {\n    vector<int> c(N + 1), buf(Q);\n    for(int i = 0; i < Q; i++) { c[R[i]]++; }\n    for(int i = 1; i < (int)c.size(); i++) { c[i] += c[i - 1]; }\n    for(int i = 0; i < Q; i++) { buf[--c[R[i]]] = i; }\n    vector<int> b(Q);\n    for(int i = 0; i < Q; i++) { b[i] = L[i] / W; }\n    c.resize(N / W + 1);\n    ranges::fill(c, 0);\n    for(int i = 0; i < Q; i++) { c[b[i]]++; }\n    for(int i = 1; i < (int)c.size(); i++) { c[i] += c[i - 1]; }\n    for(int i = 0; i < Q; i++) { O[--c[b[buf[i]]]] = buf[i]; }\n    for(int i = 0, j = 0; i < Q; i = j) {\n      int bi = b[O[i]];\n      j = i + 1;\n      while(j != Q && bi == b[O[j]]) { j++; }\n      if(~bi & 1) { reverse(O.begin() + i, O.begin() + j); }\n    }\n  }\n  int dist(int i, int j) { return abs(L[i] - L[j]) + abs(R[i] - R[j]); }\n  void climb(int it = 3, int interval = 5) {\n    vector<int> d(Q - 1);\n    for(int i = 0; i < Q - 1; i++) { d[i] = dist(O[i], O[i + 1]); }\n    while(it--) {\n      for(int i = 1; i < Q; i++) {\n        int pre1 = d[i - 1], js = i + 1, je = min<int>(i + interval, Q - 1);\n        for(int j = je - 1; j >= js; j--) {\n          int pre2 = d[j], now1 = dist(O[i - 1], O[j]), now2 = dist(O[i], O[j + 1]);\n          if(now1 + now2 < pre1 + pre2) {\n            reverse(O.begin() + i, O.begin() + j + 1);\n            reverse(d.begin() + i, d.begin() + j);\n            d[i - 1] = pre1 = now1;\n            d[j] = now2;\n          }\n        }\n      }\n    }\n  }\n\n public:\n  Mo(int n, int q): N(n), Q(q), O(Q), built(false) {\n    W = max<int>(1, 1.0 * N / max<double>(1.0, sqrt(Q / 2.0)));\n    iota(O.begin(), O.end(), 0);\n  }\n  // [l, r)\n  void insert(int l, int r) {\n    assert(0 <= l && l <= r && r <= N);\n    L.push_back(l);\n    R.push_back(r);\n  }\n  void build() {\n    sort();\n    climb();\n    built = true;\n  }\n  template<typename AL, typename AR, typename DL, typename DR, typename REM>\n  void solve(const AL &add_l, const AR &add_r, const DL &del_l, const DR &del_r, const REM &rem) {\n    if(!built) { build(); }\n    int nl = 0, nr = 0;\n    for(auto idx : O) {\n      while(nl > L[idx]) { add_l(--nl); }\n      while(nr < R[idx]) { add_r(nr++); }\n      while(nl < L[idx]) { del_l(nl++); }\n      while(nr > R[idx]) { del_r(--nr); }\n      rem(idx);\n    }\n  }\n  template<typename A, typename D, typename REM>\n  void solve(const A &add, const D &del, const REM &rem) { solve(add, add, del, del, rem); }\n};"
  // },
  // "Geometry": {
  //   "prefix": "Geometry",
  //   "body": "using Real = double;\nconstexpr Real EPS = 1e-10, PI = 3.141592653589793238462643383279L;\nbool eq(Real a, Real b = 0) { return fabs(b - a) < EPS; }\nint sign(Real a) { return !eq(a) ? a > 0 ? 1 : -1 : 0; }\nReal rtod(Real r) { return r * 180.0 / PI; }\nReal dtor(Real d) { return d * PI / 180.0; }\n\nstruct Point {\n  Real x, y;\n  Point(): x(0), y(0) {}\n  Point(Real x, Real y): x(x), y(y) {}\n  template<typename T, typename U> Point(const pair<T, U> &p): x(p.first), y(p.second) {}\n  Point operator+(const Point &p) const { return {x + p.x, y + p.y}; }\n  Point operator-(const Point &p) const { return {x - p.x, y - p.y}; }\n  Point operator*(Real r) const { return {x * r, y * r}; }\n  Point operator/(Real r) const { return {x / r, y / r}; }\n  Point &operator+=(const Point &p) { return (*this) = (*this) + p; }\n  Point &operator-=(const Point &p) { return (*this) = (*this) - p; }\n  Point &operator*=(Real r) { return (*this) = (*this) * r; }\n  Point &operator/=(Real r) { return (*this) = (*this) / r; }\n  bool operator<(const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n  bool operator==(const Point &p) const { return x == p.x && y == p.y; }\n  bool operator!=(const Point &p) const { return !((*this) == p); }\n  Point rotate(Real t) const { return {x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)}; }\n  Real real() const { return x; }\n  Real imag() const { return y; }\n  friend Real real(const Point &p) { return p.x; }\n  friend Real imag(const Point &p) { return p.y; }\n  friend Real dot(const Point &l, const Point &r) { return l.x * r.x + l.y * r.y; }\n  friend Real cross(const Point &l, const Point &r) { return l.x * r.y - l.y * r.x; }\n  friend Real abs(const Point &p) { return sqrt(p.x * p.x + p.y * p.y); }\n  friend Real norm(const Point &p) { return p.x * p.x + p.y * p.y; }\n  friend Real distance(const Point &l, const Point &r) { return abs(l - r); }\n  friend Real arg(const Point &p) { return atan2(p.y, p.x); }\n  friend istream &operator>>(istream &is, Point &p) {\n    Real a, b;\n    is >> a >> b;\n    p = Point{a, b};\n    return is;\n  }\n  friend ostream &operator<<(ostream &os, const Point &p) { return os << p.x << \" \" << p.y; }\n};\nusing Points = vector<Point>;\n\nReal angle(const Point &a, const Point &b, const Point &c) {  // ∠ABC (acute)\n  const Point x = a - b, y = c - b;\n  Real t1 = arg(x), t2 = arg(y);\n  if(t1 > t2) { swap(t1, t2); }\n  Real t = t2 - t1;\n  return min(t, 2 * PI - t);\n}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n  const Point x = b - a, y = c - a;\n  if(cross(x, y) > EPS) { return +1; }  // a,b,c counterclockwise\n  if(cross(x, y) < -EPS) { return -1; }  // a,b,c clockwise\n  if(min(norm(x), norm(y)) < EPS * EPS) { return 0; }  // c=a or c=b\n  if(dot(x, y) < EPS) { return +2; }  // c-a-b\n  if(norm(x) < norm(y)) { return -2; }  // a-b-c\n  return 0;  // a-c-b\n}\n\nusing Polygon = vector<Point>;\nusing Polygons = vector<Polygon>;\n\nint Contains(const Polygon &P, const Point &p) {  // 0:out, 1:on, 2:in\n  bool in = false;\n  const int N = P.size();\n  for(int i = 0; i < N; i++) {\n    Point a = P[i] - p, b = P[(i + 1) % N] - p;\n    if(a.y > b.y) { swap(a, b); }\n    if(a.y < EPS && b.y > EPS && cross(a, b) < -EPS) { in = !in; }\n    if(eq(cross(a, b)) && dot(a, b) < EPS) { return 1; }\n  }\n  return in ? 2 : 0;\n}\n\nint ConvexContains(const Polygon &C, const Point &p) {  // 0:out, 1:on, 2:in\n  const int N = C.size();\n  if(N == 0) { return 0; }\n  if(N == 1) { return C[0] == p; }\n  Real b1 = cross(C[1] - C[0], p - C[0]), b2 = cross(C[N - 1] - C[0], p - C[0]);\n  if(b1 < -EPS || b2 > EPS) { return 0; }\n  int L = 1, R = N - 1;\n  while(R - L > 1) {\n    int M = (L + R) >> 1;\n    (cross(p - C[0], C[M] - C[0]) >= 0 ? R : L) = M;\n  }\n  Real v = cross(C[L] - p, C[R] - p);\n  if(eq(v)) { return 1; }\n  else if(v > 0) { return eq(b1) || eq(b2) ? 1 : 2; }\n  else { return 0; }\n}\n\nbool isConvex(const Polygon &P) {\n  const int N = P.size();\n  for(int i = 0; i < N; i++) {\n    if(ccw(P[(i + N - 1) % N], P[i], P[(i + 1) % N]) == -1) { return false; }\n  }\n  return true;\n}\n\ntemplate<bool boundary = false> Polygon ConvexHull(Polygon P, bool sorted = false) {\n  if(!sorted) {\n    sort(P.begin(), P.end());\n    P.erase(unique(P.begin(), P.end()), P.end());\n  }\n  const int N = P.size();\n  int k = 0;\n  if(N <= 2) { return P; }\n  Polygon C(2 * N);\n  Real e = boundary ? -EPS : EPS;\n  for(int i = 0; i < N; C[k++] = P[i++]) {\n    while(k >= 2 && cross(C[k - 1] - C[k - 2], P[i] - C[k - 1]) < e) { k--; }\n  }\n  for(int i = N - 2, t = k + 1; i >= 0; C[k++] = P[i--]) {\n    while(k >= t && cross(C[k - 1] - C[k - 2], P[i] - C[k - 1]) < e) { k--; }\n  }\n  C.resize(k - 1);\n  return C;\n}\n\nReal Area(const Polygon &P) {\n  const int N = P.size();\n  Real A = 0;\n  for(int i = 0; i < N; i++) { A += cross(P[i], P[(i + 1) % N]); }\n  return A * 0.5;\n}\n\npair<int, int> ConvexDiameter(const Polygon &P) {\n  const int N = P.size();\n  int i = 0, j = 0;\n  for(int k = 1; k < N; k++) {\n    if(P[k].y < P[i].y) { i = k; }\n    if(P[k].y > P[j].y) { j = k; }\n  }\n  ll maxdis = norm(P[i] - P[j]);\n  int maxi = i, maxj = j, is = i, js = j;\n  do {\n    if(cross(P[(i + 1) % N] - P[i], P[(j + 1) % N] - P[j]) >= 0) { j = (j + 1) % N; }\n    else { i = (i + 1) % N; }\n    if(norm(P[i] - P[j]) > maxdis) {\n      maxdis = norm(P[i] - P[j]);\n      maxi = i, maxj = j;\n    }\n  } while(i != is || j != js);\n  return minmax(maxi, maxj);\n}\n\npair<Point, Point> ClosestPair(Points P) {\n  const int N = P.size();\n  assert(N >= 2);\n  sort(P.begin(), P.end());\n  Real d = 9e18;\n  Point a, b;\n  auto f = [&](auto &&f, int l, int r) -> void {\n    const int m = (l + r) >> 1;\n    if(r - l <= 1) { return; }\n    const Real x = P[m].x;\n    f(f, l, m);\n    f(f, m, r);\n    inplace_merge(P.begin() + l, P.begin() + m, P.begin() + r, [](const auto &a, const auto &b) { return a.y < b.y; });\n    vector<int> B;\n    for(int i = l; i < r; i++) {\n      if(sign(abs(P[i].x - x) - d) > 0) { continue; }\n      for(int j = (int)B.size() - 1; j >= 0; j--) {\n        if(sign(P[i].y - P[B[j]].y - d) > 0) { break; }\n        if(sign(d - distance(P[i], P[B[j]])) > 0) {\n          d = distance(P[i], P[B[j]]);\n          a = P[i], b = P[B[j]];\n        }\n      }\n      B.emplace_back(i);\n    }\n  };\n  f(f, 0, N);\n  return {a, b};\n}"
  // },
  // "Geometry_Line": {
  //   "prefix": "Geometry_Line",
  //   "body": "struct Line {\n  Point a, b;\n  Line() = default;\n  Line(const Point &a, const Point &b): a(a), b(b) {}\n  Line(const Real &A, const Real &B, const Real &C) {  // Ax + By = C\n    if(eq(A)) {\n      assert(!eq(B));\n      a = Point(0, C / B), b = Point(1, C / B);\n    }\n    else if(eq(B)) { a = Point(C / A, 0), b = Point(C / A, 1); }\n    else { a = Point(0, C / B), b = Point(C / A, 0); }\n  }\n  friend istream &operator>>(istream &is, Line &l) { return is >> l.a >> l.b; }\n  friend ostream &operator<<(ostream &os, const Line &l) { return os << l.a << \" to \" << l.b; }\n};\nusing Lines = vector<Line>;\n\nbool parallel(const Line &l, const Line &r) { return eq(cross(l.b - l.a, r.b - r.a)); }\nbool orthogonal(const Line &l, const Line &r) { return eq(dot(l.a - l.b, r.a - r.b)); }\nPoint projection(const Line &l, const Point &p) { return l.a + (l.a - l.b) * (dot(p - l.a, l.a - l.b) / norm(l.a - l.b)); }\nPoint reflection(const Line &l, const Point &p) { return projection(l, p) * 2 - p; }\nbool intersect(const Line &l, const Point &p) { return abs(ccw(l.a, l.b, p)) != 1; }\nint intersect(const Line &l, const Line &r) { return parallel(l, r) ? intersect(l, r.a) ? 2 : 0 : 1; }  // 0:parallel, 1:intersect 2:l=r\nReal distance(const Line &l, const Point &p) { return distance(p, projection(l, p)); }\nReal distance(const Line &l, const Line &r) { return intersect(l, r) ? 0 : distance(l, r.a); }\nPoint crosspoint(const Line &l, const Line &r) {\n  Real A = cross(l.b - l.a, r.b - r.a), B = cross(l.b - l.a, l.b - r.a);\n  return eq(A) && eq(B) ? r.a : r.a + (r.b - r.a) * B / A;\n}\nLine PerpendicularBisector(const Point &l, const Point &r) {\n  Point m = (l + r) * 0.5, d = r - l;\n  Point p(m.x - d.y, m.y + d.x);\n  return Line(m, p);\n}\nPoint Circumcenter(const Point &a, const Point &b, const Point &c) { return crosspoint(PerpendicularBisector(a, b), PerpendicularBisector(a, c)); }\n\nPolygon ConvexCut(const Polygon &P, const Line &l) {\n  const int N = P.size();\n  Polygon r;\n  for(int i = 0; i < N; i++) {\n    const Point &now = P[i], &nxt = P[(i + 1) % N];\n    Real cf = cross(l.a - now, l.b - now), cs = cross(l.a - nxt, l.b - nxt);\n    if(sign(cf) >= 0) { r.emplace_back(now); }\n    if(sign(cf) * sign(cs) < 0) { r.emplace_back(crosspoint(Line(now, nxt), l)); }\n  }\n  return r;\n}"
  // },
  // "Geometry_Segment": {
  //   "prefix": "Geometry_Segment",
  //   "body": "struct Segment : Line {\n  Segment() = default;\n  using Line::Line;\n};\nusing Segments = vector<Segment>;\n\nbool intersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0; }\nbool intersect(const Line &l, const Segment &s) { return sign(cross(l.b - l.a, s.a - l.a)) * sign(cross(l.b - l.a, s.b - l.a)) <= 0; }\nbool intersect(const Segment &l, const Segment &r) { return ccw(l.a, l.b, r.a) * ccw(l.a, l.b, r.b) <= 0 && ccw(r.a, r.b, l.a) * ccw(r.a, r.b, l.b) <= 0; }\nReal distance(const Segment &s, const Point &p) { return intersect(s, projection(s, p)) ? distance(p, projection(s, p)) : min(distance(s.a, p), distance(s.b, p)); }\nReal distance(const Line &l, const Segment &s) { return intersect(l, s) ? 0 : min(distance(l, s.a), distance(l, s.b)); }\nReal distance(const Segment &l, const Segment &r) { return intersect(l, r) ? 0 : min({distance(l, r.a), distance(l, r.b), distance(r, l.a), distance(r, l.b)}); }\n\nvoid MergeSegments(Segments &S) {\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(sign(cross(s1.b - s1.a, s2.b - s2.a)) == 1) { return 0; }\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) { return 0; }\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) { return 0; }\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return 1;\n  };\n  for(int i = 0; i < (int)S.size(); i++) {\n    if(S[i].b < S[i].a) { swap(S[i].a, S[i].b); }\n  }\n  for(int i = 0; i < (int)S.size(); i++) {\n    for(int j = i + 1; j < (int)S.size(); j++) {\n      if(merge_if_able(S[i], S[j])) {\n        S[j--] = S.back();\n        S.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(Segments &S, Points &P) {\n  vector<vector<int>> g;\n  const int N = S.size();\n  for(int i = 0; i < N; i++) {\n    P.push_back(S[i].a);\n    P.push_back(S[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = S[i].b - S[i].a, p2 = S[j].b - S[j].a;\n      if(eq(cross(p1, p2))) { continue; }\n      if(intersect(S[i], S[j])) { P.push_back(crosspoint(S[i], S[j])); }\n    }\n  }\n  sort(P.begin(), P.end());\n  P.erase(unique(P.begin(), P.end()), P.end());\n  const int M = P.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector<int> v;\n    for(int j = 0; j < M; j++) {\n      if(intersect(S[i], P[j])) { v.push_back(j); }\n    }\n    for(int j = 1; j < (int)v.size(); j++) {\n      g[v[j - 1]].push_back(v[j]);\n      g[v[j]].push_back(v[j - 1]);\n    }\n  }\n  return g;\n}"
  // },
  // "Geometry_Circle": {
  //   "prefix": "Geometry_Circle",
  //   "body": "struct Circle {\n  Point p;\n  Real r{};\n  Circle() = default;\n  Circle(const Point &p, const Real &r): p(p), r(r) {}\n  friend istream &operator>>(istream &is, Circle &c) { return is >> c.p >> c.r; }\n  friend ostream &operator<<(ostream &os, Circle &c) { return os << c.p << \" ,\" << c.r; }\n};\nusing Circles = vector<Circle>;\n\nint contains(const Circle &c, const Point &p) { return sign(c.r - distance(c.p, p)) + 1; }  // 0:out, 1:on, 2:in\nbool intersect(const Circle &c, const Point &p) { return eq(c.r, distance(c.p, p)); }\nint intersect(const Circle &c, const Line &l) { return contains(c, projection(l, c.p)); }\nint intersect(const Circle &c, const Segment &s) {\n  int r = intersect(c, Line(s)), f = ccw(s.a, s.b, projection(s, c.p));\n  if(r == 0) { return 0; }\n  if(r == 1) { return f == 0 ? 1 : 0; }\n  int f1 = sign(abs(c.p - s.a) - c.r), f2 = sign(abs(c.p - s.b) - c.r);\n  if(f1 < 0 && f2 < 0) { return 0; }\n  if(f1 < 0 || f2 < 0) { return 1; }\n  if(f1 == 0 && f2 == 0) { return 2; }\n  if(f1 == 0 || f2 == 0) { return f == 0 ? 2 : 1; }\n  return f == 0 ? 2 : 0;\n}\nint intersect(const Circle &a, const Circle &b) {  // +2:外部 -2:内部 +1:外接 -1:内接 0:2点で交わる\n  Real d = distance(a.p, b.p), R = a.r + b.r, r = fabs(a.r - b.r);\n  if(sign(d - R) > 0) { return +2; }\n  if(sign(d - r) < 0) { return -2; }\n  if(eq(d, R)) { return +1; }\n  if(eq(d, r)) { return -1; }\n  return 0;\n}\nPoints crosspoint(const Circle &c, const Line &l) {\n  Point h = projection(l, c.p);\n  if(intersect(c, l) == 0) { return {}; }\n  if(intersect(c, l) == 1) { return {h}; }\n  Point e = (l.b - l.a) / distance(l.a, l.b) * sqrt(norm(c.r) - norm(h - c.p));\n  return {h + e, h - e};\n}\nPoints crosspoint(const Circle &c, const Segment &s) {\n  if(intersect(c, s) == 0) { return {}; }\n  Points r = crosspoint(c, Line(s));\n  if(intersect(c, s) == 2) { return r; }\n  if(dot(s.a - r[0], s.b - r[0]) > 0) { swap(r[0], r[1]); }\n  return {r[0]};\n}\nPoints crosspoint(const Circle &l, const Circle &r) {\n  const int i = intersect(l, r);\n  if(abs(i) == 2) { return {}; }\n  Real d = distance(l.p, r.p), t = acos((l.r * l.r - r.r * r.r + d * d) / (2 * l.r * d)), s = arg(r.p - l.p);\n  Point e(l.r, 0), p = l.p + e.rotate(s + t), q = l.p + e.rotate(s - t);\n  if(abs(i) == 1) { return {p}; }\n  return {p, q};\n}\nPoints tangent(const Circle &c, const Point &p) {\n  const int i = contains(c, p);\n  if(i == 2) { return {}; }\n  if(i == 1) { return {p}; }\n  return crosspoint(c, Circle(p, sqrt(norm(p - c.p) - c.r * c.r)));\n}\nLines tangent(Circle &l, Circle &r) {\n  Lines ret;\n  if(sign(l.r - r.r) < 0) { swap(l, r); }\n  Real g = norm(l.p - r.p);\n  if(eq(g)) { return ret; }\n  Point u = (r.p - l.p) / sqrt(g), v = u.rotate(PI * 0.5);\n  for(int s : {-1, 1}) {\n    Real h = (l.r + s * r.r) / sqrt(g);\n    if(eq(1 - h * h)) { ret.emplace_back(Line(l.p + u * l.r, l.p + (u + v) * l.r)); }\n    else if(sign(1 - h * h) > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(Line(l.p + (uu + vv) * l.r, r.p - (uu + vv) * r.r * s));\n      ret.emplace_back(Line(l.p + (uu - vv) * l.r, r.p - (uu - vv) * r.r * s));\n    }\n  }\n  return ret;\n}\n\nReal Area(const Circle &c, const Polygon &P) {\n  auto calc = [&](auto &&calc, const Point &a, const Point &b) -> Real {\n    auto va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0;\n    if(eq(f)) { return ret; }\n    if(max(abs(va), abs(vb)) < c.r + EPS) { return f; }\n    if(distance(Segment(a, b), c.p) > c.r - EPS) {\n      Point t(va.x * vb.x + va.y * vb.y, va.x * vb.y - va.y * vb.x);\n      return norm(c.r) * arg(t);\n    }\n    auto u = crosspoint(c, Segment(a, b));\n    if((int)u.size() == 1) { u.emplace_back(u[0]); }\n    vector<Point> tot = {a, u[0], u[1], b};\n    for(int i = 0; i < 3; i++) { ret += calc(calc, tot[i], tot[i + 1]); }\n    return ret;\n  };\n  const int N = P.size();\n  if(N < 3) { return 0; }\n  Real A = 0;\n  for(int i = 0; i < N; i++) { A += calc(calc, P[i], P[(i + 1) % N]); }\n  return A * 0.5;\n}"
  // },
  // "Geometry_Integer": {
  //   "prefix": "Geometry_Integer",
  //   "body": "using Real = double;\nconstexpr double PI = 3.141592653589793238462643383279L;\nReal rtod(Real r) { return r * 180.0 / PI; }\nReal dtor(Real d) { return d * PI / 180.0; }\n\nstruct Point {\n  ll x, y;\n  Point(): x(0), y(0) {}\n  Point(ll x, ll y): x(x), y(y) {}\n  template<typename T, typename U> Point(const pair<T, U> &p): x(p.first), y(p.second) {}\n  Point operator+(const Point &p) const { return {x + p.x, y + p.y}; }\n  Point operator-(const Point &p) const { return {x - p.x, y - p.y}; }\n  Point operator*(ll r) const { return {x * r, y * r}; }\n  Point operator/(ll r) const { return {x / r, y / r}; }\n  Point &operator+=(const Point &p) { return *this = *this + p; }\n  Point &operator-=(const Point &p) { return *this = *this - p; }\n  Point &operator*=(ll r) { return *this = *this * r; }\n  Point &operator/=(ll r) { return *this = *this / r; }\n  bool operator<(const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n  bool operator==(const Point &p) const { return x == p.x && y == p.y; }\n  bool operator!=(const Point &p) const { return !(*this == p); }\n  Point rotate90() const { return {-y, x}; }\n  Point rotaet180() const { return {-x, -y}; }\n  Point rotate270() const { return {y, -x}; }\n  friend ll dot(const Point &l, const Point &r) { return l.x * r.x + l.y * r.y; }\n  friend ll cross(const Point &l, const Point &r) { return l.x * r.y - l.y * r.x; }\n  friend Real abs(const Point &p) { return sqrt(p.x * p.x + p.y * p.y); }\n  friend ll norm(const Point &p) { return p.x * p.x + p.y * p.y; }\n  friend Real distance(const Point &l, const Point &r) { return abs(l - r); }\n  friend Real arg(const Point &p) { return atan2(p.y, p.x); }\n  friend istream &operator>>(istream &is, Point &p) {\n    ll a, b;\n    cin >> a >> b;\n    p = Point(a, b);\n    return is;\n  }\n  friend ostream &operator<<(ostream &os, const Point &p) { return os << p.x << \" \" << p.y; }\n};\nusing Points = vector<Point>;\n\nReal angle(const Point &a, const Point &b, const Point &c) {\n  const Point x = a - b, y = c - b;\n  Real t1 = arg(x), t2 = arg(y);\n  if(t1 > t2) { swap(t1, t2); }\n  Real t = t2 - t1;\n  return min(t, 2 * PI - t);\n}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n  const Point x = b - a, y = c - a;\n  if(cross(x, y) > 0) { return +1; }  // a,b,c counterclockwise\n  if(cross(x, y) < 0) { return -1; }  // a,b,c clockwise\n  if(min(norm(x), norm(y)) == 0) { return 0; }  // c=a or c=b\n  if(dot(x, y) < 0) { return 2; }  // c-a-b\n  if(norm(x) < norm(y)) { return -2; }  // a-b-c\n  return 0;  // a-c-b\n}\n\nusing Polygon = vector<Point>;\nusing Polygons = vector<Polygon>;\n\nint Contains(const Polygon &P, const Point &p) {  // 0:out, 1:on, 2:in\n  bool in = false;\n  const int N = P.size();\n  for(int i = 0; i < N; i++) {\n    Point a = P[i] - p, b = P[(i + 1) % N] - p;\n    if(a.y > b.y) { swap(a, b); }\n    if(a.y < 0 && b.y > 0 && cross(a, b) < 0) { in = !in; }\n    if(cross(a, b) == 0 && dot(a, b) < 0) { return 1; }\n  }\n  return in ? 2 : 0;\n}\n\nint ConvexContains(const Polygon &C, const Point &p) {  // 0:out, 1:on, 2:in\n  const int N = C.size();\n  if(N == 0) { return 0; }\n  if(N == 1) { return C[0] == p; }\n  ll b1 = cross(C[1] - C[0], p - C[0]), b2 = cross(C[N - 1] - C[0], p - C[0]);\n  if(b1 < 0 || b2 > 0) { return 0; }\n  int L = 1, R = N - 1;\n  while(R - L > 1) {\n    int M = (L + R) >> 1;\n    (cross(p - C[0], C[M] - C[0]) >= 0 ? R : L) = M;\n  }\n  ll v = cross(C[L] - p, C[R] - p);\n  if(!v) { return 1; }\n  else if(v > 0) { return !b1 || !b2 ? 1 : 2; }\n  return 0;\n}\n\nbool isConvex(const Polygon &P) {\n  const int N = P.size();\n  for(int i = 0; i < N; i++) {\n    if(ccw(P[(i + N - 1) % N], P[i], P[(i + 1) % N]) == -1) { return false; }\n  }\n  return true;\n}\n\ntemplate<bool boundary = false> Polygon ConvexHull(Polygon P, bool sorted = false) {\n  if(!sorted) {\n    sort(P.begin(), P.end());\n    P.erase(unique(P.begin(), P.end()), P.end());\n  }\n  const int N = P.size();\n  int k = 0;\n  if(N <= 2) { return P; }\n  Polygon C(2 * N);\n  for(int i = 0; i < N; C[k++] = P[i++]) {\n    while(k >= 2 && cross(C[k - 1] - C[k - 2], P[i] - C[k - 1]) < !boundary) { k--; }\n  }\n  for(int i = N - 2, t = k + 1; i >= 0; C[k++] = P[i--]) {\n    while(k >= t && cross(C[k - 1] - C[k - 2], P[i] - C[k - 1]) < !boundary) { k--; }\n  }\n  C.resize(k - 1);\n  return C;\n}\n\nReal Area(const Polygon &P) {\n  const int N = P.size();\n  Real A = 0;\n  for(int i = 0; i < N; i++) { A += cross(P[i], P[(i + 1) % N]); }\n  return A * 0.5;\n}\n\npair<int, int> ConvexDiameter(const Polygon &P) {\n  const int N = P.size();\n  int i = 0, j = 0;\n  for(int k = 1; k < N; k++) {\n    if(P[k].y < P[i].y) { i = k; }\n    if(P[k].y > P[j].y) { j = k; }\n  }\n  ll maxdis = norm(P[i] - P[j]);\n  int maxi = i, maxj = j, is = i, js = j;\n  do {\n    if(cross(P[(i + 1) % N] - P[i], P[(j + 1) % N] - P[j]) >= 0) { j = (j + 1) % N; }\n    else { i = (i + 1) % N; }\n    if(norm(P[i] - P[j]) > maxdis) {\n      maxdis = norm(P[i] - P[j]);\n      maxi = i, maxj = j;\n    }\n  } while(i != is || j != js);\n  return minmax(maxi, maxj);\n}\n\npair<Point, Point> ClosestPair(Points P) {\n  const int N = P.size();\n  assert(N >= 2);\n  sort(P.begin(), P.end());\n  ll d = 9e18;\n  Point a, b;\n  auto f = [&](auto &&f, int l, int r) -> void {\n    const int m = (l + r) >> 1;\n    if(r - l <= 1) { return; }\n    const ll x = P[m].x;\n    f(f, l, m);\n    f(f, m, r);\n    inplace_merge(P.begin() + l, P.begin() + m, P.begin() + r, [](const auto &a, const auto &b) { return a.y < b.y; });\n    vector<int> B;\n    for(int i = l; i < r; i++) {\n      if((P[i].x - x) * (P[i].x - x) >= d) { continue; }\n      for(int j = (int)B.size() - 1; j >= 0; j--) {\n        if((P[i].y - P[B[j]].y) * (P[i].y - P[B[j]].y) >= d) { break; }\n        if(d > norm(P[i] - P[B[j]])) {\n          d = norm(P[i] - P[B[j]]);\n          a = P[i], b = P[B[j]];\n        }\n      }\n      B.emplace_back(i);\n    }\n  };\n  f(f, 0, N);\n  return {a, b};\n}"
  // },
  "Eratosthenes": {
    "prefix": "Eratosthenes",
    "body": "vector<ll> Eratosthenes(int n) {\n  vector<ll> prime(n + 1, 0);\n  if(n >= 0) { prime[0] = 0; }\n  if(n >= 1) { prime[1] = 0; }\n  for(int i = 2; i * i <= n; i++) {\n    if(prime[i]) { continue; }\n    for(int j = i; j <= n; j += i) { prime[j]++; }\n  }\n  return prime;\n}"
  },
  "Eratosthenes_": {
    "prefix": "Eratosthenes_",
    "body": "//  is_p[i].empty() -> i は素数\n// !is_p[i].empty() -> is_p[i] は i の素因数を格納\n// 素数判定の必要なし，素因数だけ欲しいときは j=i*2 を j=i に変更\n// p : n以下の素数列\n\npair<vector<vector<ll>>, vector<ll>> Eratosthenes(ll n) {\n  vector<vector<ll>> is_p(n + 1);\n  vector<ll> p;\n  for(ll i = 2; i <= n; i++) {\n    if(!is_p[i].empty()) {continue;}\n    p.push_back(i);\n    for(ll j = i ; j <= n; j += i) {is_p[j].emplace_back(i);}\n  }\n  return {is_p, p};\n}"
  },
  "eratosthenes": {
    "prefix": "eratosthenes",
    "body": "Eratosthenes($0);"
  },
  // "prime_super": {
  //   "prefix": "Prime_super",
  //   "body": "bool is_prime(ll N) {\n  if(N == 2 || N == 3 || N == 5 || N == 7) { return true; }\n  if(N % 2 == 0 || N % 3 == 0 || N % 5 == 0 || N % 7 == 0) { return false; }\n  if(N < 121) { return N > 1; }\n  ll d = (N - 1) >> __builtin_ctzll(N - 1);\n  ll p = 1, m = N - 1;\n  auto internal_pow = [&](ll x, ll n) -> __uint128_t {\n    __uint128_t r;\n    x %= N;\n    if(n == 0) { return 1; }\n    r = 1;\n    __uint128_t c = x;\n    for(; n; n >>= 1, c = (c * c) % N) {\n      if(n & 1) { r = r * c % N; }\n    }\n    return r;\n  };\n  auto ok = [&](ll a) {\n    auto y = internal_pow(a, d);\n    ll t = d;\n    for(; y != p && y != m && t != N - 1; t <<= 1) { y = y * y % N; }\n    if(y != m && t % 2 == 0) { return false; }\n    return true;\n  };\n  if(N < (1ll << 32)) {\n    for(ll a : {2, 7, 61}) {\n      if(!ok(a)) { return false; }\n    }\n  }\n  else {\n    for(ll a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {\n      if(N <= a) { return true; }\n      if(!ok(a)) { return false; }\n    }\n  }\n  return true;\n}\n\nll Rho(ll N) {\n  if(N % 2 == 0) { return 2; }\n  if(is_prime(N)) { return N; }\n  ll ds = [&]() -> ll {\n    ll n = ll(sqrt(N));\n    for(ll i = 0; i < 300; ++i) {\n      ll T = (n + i) * (n + i) - N;\n      ll t = ll(sqrt(T));\n      if(t * t == T) { return n + i - t; }\n    }\n    return 0;\n  }();\n  if(ds > 1) { return ds; }\n  auto f = [&](ll x) -> ll { return (__int128_t(x) * x + 1) % N; };\n  ll st = 0;\n  while(true) {\n    ++st;\n    ll x = st, y = f(x);\n    while(true) {\n      ll p = gcd(y - x + N, N);\n      if(p == 0 || p == N) { break; }\n      if(p != 1) { return p; }\n      x = f(x);\n      y = f(f(y));\n    }\n  }\n}\n\nvector<ll> PrimeFactorize(ll N) {\n  if(N == 1) { return {}; }\n  ll p = Rho(N);\n  if(p == N) { return {p}; }\n  vector<ll> l = PrimeFactorize(p), r = PrimeFactorize(N / p);\n  l.insert(l.end(), r.begin(), r.end());\n  ranges::sort(l);\n  return l;\n}\n\nvector<ll> Divisor(ll N) {\n  auto p = PrimeFactorize(N);\n  vector<vector<ll>> x(1, {1});\n  ll num = 1, idx = 0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    num *= p[i];\n    x[idx].emplace_back(num);\n    if(i != (int)p.size() - 1 && p[i + 1] != p[i]) {\n      x.push_back({1});\n      num = 1;\n      idx++;\n    }\n  }\n  ll l = 0, r = 1;\n  vector<ll> ret{1};\n  for(int i = 0; i < (int)x.size(); i++) {\n    for(auto &e : x[i]) {\n      for(int j = l; j < r; j++) { ret.emplace_back(ret[j] * e); }\n    }\n    l = r;\n    r = ret.size();\n  }\n  return vector<ll>(ret.begin() + l, ret.end());\n}"
  // },
  // "WaveletMatrix": {
  //   "prefix": "WaveletMatrix",
  //   "body": "struct SuccinctIndexableDictionary {\n  unsigned len, blk;\n  vector<unsigned> bit, sum;\n  SuccinctIndexableDictionary() = default;\n  SuccinctIndexableDictionary(unsigned len): len(len), blk((len + 31) >> 5) {\n    bit.assign(blk, 0U);\n    sum.assign(blk, 0U);\n  }\n  void set(int k) { bit[k >> 5] |= 1U << (k & 31); }\n  void build() {\n    sum[0] = 0U;\n    for(unsigned i = 1; i < blk; i++) { sum[i] = sum[i - 1] + __builtin_popcount(bit[i - 1]); }\n  }\n  bool operator[](ll k) { return (bool((bit[k >> 5] >> (k & 31)) & 1)); }\n  int rank(int k) { return (sum[k >> 5] + __builtin_popcount(bit[k >> 5] & ((1U << (k & 31)) - 1))); }\n  int rank(bool val, int k) { return (val ? rank(k) : k - rank(k)); }\n};\n\ntemplate<typename T, ll MAXLOG> struct WaveletMatrix {\n  ll len;\n  SuccinctIndexableDictionary mat[MAXLOG];\n  ll mid[MAXLOG];\n  WaveletMatrix() = default;\n  WaveletMatrix(vector<T> v): len(v.size()) {\n    vector<T> l(len), r(len);\n    for(ll lev = MAXLOG - 1; lev >= 0; lev--) {\n      mat[lev] = SuccinctIndexableDictionary(len + 1);\n      ll left = 0, right = 0;\n      for(ll i = 0; i < len; i++) {\n        if(((v[i] >> lev) & 1)) {\n          mat[lev].set(i);\n          r[right++] = v[i];\n        }\n        else { l[left++] = v[i]; }\n      }\n      mid[lev] = left;\n      mat[lev].build();\n      v.swap(l);\n      for(ll i = 0; i < right; i++) { v[left + i] = r[i]; }\n    }\n  }\n  pair<ll, ll> succ(bool f, ll l, ll r, ll lev) { return {mat[lev].rank(f, l) + mid[lev] * f, mat[lev].rank(f, r) + mid[lev] * f}; }\n  T access(ll k) {\n    T ret = 0;\n    for(ll lev = MAXLOG - 1; lev >= 0; lev--) {\n      bool f = mat[lev][k];\n      if(f) { ret |= T(1) << lev; }\n      k = mat[lev].rank(f, k) + mid[lev] * f;\n    }\n    return ret;\n  }\n  T operator[](const ll &k) { return access(k); }\n  ll rank(const T &x, ll r) {\n    ll l = 0;\n    for(ll lev = MAXLOG - 1; lev >= 0; lev--) { tie(l, r) = succ((x >> lev) & 1, l, r, lev); }\n    return r - l;\n  }\n  T kth_smallest(ll l, ll r, ll k) {\n    assert(0 <= k && k < r - l);\n    T ret = 0;\n    for(ll lev = MAXLOG - 1; lev >= 0; lev--) {\n      ll cnt = mat[lev].rank(false, r) - mat[lev].rank(false, l);\n      bool f = cnt <= k;\n      if(f) {\n        ret |= T(1) << lev;\n        k -= cnt;\n      }\n      tie(l, r) = succ(f, l, r, lev);\n    }\n    return ret;\n  }\n  T kth_largest(ll l, ll r, ll k) { return kth_smallest(l, r, r - l - k - 1); }\n  ll range_freq(ll l, ll r, T upper) {\n    ll ret = 0;\n    for(ll lev = MAXLOG - 1; lev >= 0; lev--) {\n      bool f = ((upper >> lev) & 1);\n      if(f) { ret += mat[lev].rank(false, r) - mat[lev].rank(false, l); }\n      tie(l, r) = succ(f, l, r, lev);\n    }\n    return ret;\n  }\n  ll range_freq(ll l, ll r, T lower, T upper) { return range_freq(l, r, upper) - range_freq(l, r, lower); }\n  T prev_value(ll l, ll r, T upper) {\n    ll cnt = range_freq(l, r, upper);\n    return cnt == 0 ? T(-1) : kth_smallest(l, r, cnt - 1);\n  }\n  T next_value(ll l, ll r, T lower) {\n    ll cnt = range_freq(l, r, lower);\n    return cnt == r - l ? T(-1) : kth_smallest(l, r, cnt);\n  }\n};\n\ntemplate<typename T = ll, ll MAXLOG = 20> struct CompressedWaveletMatrix {\n  WaveletMatrix<ll, MAXLOG> mat;\n  vector<T> ys;\n  CompressedWaveletMatrix() {}\n  CompressedWaveletMatrix(const vector<T> &v): ys(v) {\n    ranges::sort(ys);\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    vector<ll> t(v.size());\n    for(ll i = 0; i < (ll)v.size(); i++) { t[i] = get(v[i]); }\n    mat = WaveletMatrix<ll, MAXLOG>(t);\n  }\n  inline ll get(const T &x) { return ranges::lower_bound(ys, x) - ys.begin(); }\n  T access(ll k) { return ys[mat.access(k)]; }\n  T operator[](const ll &k) { return access(k); }\n  ll rank(const T &x, ll r) {\n    auto pos = get(x);\n    if(pos == (ll)ys.size() || ys[pos] != x) { return 0; }\n    return mat.rank(pos, r);\n  }\n  ll count(ll l, ll r, T x) {\n    if(l >= r) { return 0; }\n    return rank(x, r) - rank(x, l);\n  }\n  T kth_smallest(ll l, ll r, ll k) { return ys[mat.kth_smallest(l, r, k)]; }\n  T kth_largest(ll l, ll r, ll k) { return ys[mat.kth_largest(l, r, k)]; }\n  ll range_freq(ll l, ll r, T upper) {\n    if(l >= r) { return 0; }\n    return mat.range_freq(l, r, get(upper));\n  }\n  ll range_freq(ll l, ll r, T lower, T upper) {\n    if(l >= r || lower >= upper) { return 0; }\n    return mat.range_freq(l, r, get(lower), get(upper));\n  }\n  T prev_value(ll l, ll r, T upper) {\n    auto ret = mat.prev_value(l, r, get(upper));\n    return ret == -1 ? T(-1) : ys[ret];\n  }\n  T next_value(ll l, ll r, T lower) {\n    auto ret = mat.next_value(l, r, get(lower));\n    return ret == -1 ? T(-1) : ys[ret];\n  }\n};\n// ll count(l,r,x)                : return ＃{i∈[l, r) | v[i] == x}\n// T  kth_smallest(l,r,k)         : return k-th(0-indexed) smallest number in v[i] s.t. i∈[l, r)\n// T  kth_largest(l,r,k)          : return k-th(0-indexed) largest number in v[i] s.t. i∈[l, r)\n// ll range_freq(l,r,upper)       : return ＃{i∈[l, r) | v[i] < upper}\n// ll range_freq(l,r,lower,upper) : return ＃{i∈[l, r) | lower <= v[i] < upper}\n// T  prev_value(l,r,upper)       : return max v[i] s.t. i∈[l, r) && v[i] < upper\n// T  next_value(l,r,lower)       : return min v[i] s.t. i∈[l, r) && lower <= v[i]\n"
  // },
  "waveletmatrix": {
    "prefix": "waveletmatrix",
    "body": "CompressedWaveletMatrix<> W($0);"
  },
  // "PrioritySum": {
  //   "prefix": "PrioritySum",
  //   "body": "template<typename T, typename Compare = less<T>, typename RCompare = greater<T>> struct PrioritySum {\n private:\n  ll k;\n  T sum;\n  priority_queue<T, vector<T>, Compare> in, d_in;\n  priority_queue<T, vector<T>, RCompare> out, d_out;\n  void modify() {\n    while(in.size() - d_in.size() < k && !out.empty()) {\n      auto p = out.top();\n      out.pop();\n      if(!d_out.empty() && p == d_out.top()) { d_out.pop(); }\n      else {\n        sum += p;\n        in.emplace(p);\n      }\n    }\n    while(in.size() - d_in.size() > k) {\n      auto p = in.top();\n      in.pop();\n      if(!d_in.empty() && p == d_in.top()) { d_in.pop(); }\n      else {\n        sum -= p;\n        out.emplace(p);\n      }\n    }\n    while(!d_in.empty() && in.top() == d_in.top()) {\n      in.pop();\n      d_in.pop();\n    }\n  }\n\n public:\n  PrioritySum(int k): k(k), sum(0) {}\n  void insert(T x) {\n    in.emplace(x);\n    sum += x;\n    modify();\n  }\n  void erase(T x) {\n    assert(size());\n    if(!in.empty() && in.top() == x) {\n      sum -= x;\n      in.pop();\n    }\n    else if(!in.empty() && RCompare()(in.top(), x)) {\n      sum -= x;\n      d_in.emplace(x);\n    }\n    else { d_out.emplace(x); }\n    modify();\n  }\n  T query() const { return sum; }\n  void set(ll kk) {\n    k = kk;\n    modify();\n  }\n  ll get() const { return k; }\n  ll size() const { return in.size() + out.size() - d_in.size() - d_out.size(); }\n  T operator()() { return query(); }\n};"
  // },
  "MaxSum": {
    "prefix": "MaxSum",
    "body": "PrioritySum<ll, greater<ll>, less<ll>> $0"
  },
  "MinSum": {
    "prefix": "MinSum",
    "body": "PrioritySum<ll, less<ll>, greater<ll>> $0"
  },
  // "Matrix": {
  //   "prefix": "Matrix",
  //   "body": "template<typename T> struct Matrix : vector<vector<T>> {\n  using vector<vector<T>>::vector;\n  using vector<vector<T>>::operator=;\n  Matrix() {}\n  Matrix(ll N) {\n    *this = vector<vector<T>>(N, vector<T>(N, T()));\n    for(ll i = 0; i < N; i++) { (*this)[i][i] = 1; }\n  }\n  Matrix(ll H, ll W, T x = 0) { *this = vector<vector<T>>(H, vector<T>(W, x)); }\n  Matrix(vector<vector<T>> v) { *this = v; }\n  Matrix operator+(const Matrix &m) const { return Matrix(*this) += m; }\n  Matrix operator-(const Matrix &m) const { return Matrix(*this) -= m; }\n  Matrix operator*(const Matrix &m) const { return Matrix(*this) *= m; }\n  Matrix operator*(const T &x) const { return Matrix(*this) *= x; }\n  Matrix operator^(ll n) const { return Matrix(*this) ^= n; }\n  Matrix operator+=(const Matrix &m) const {\n    ll h = this->size(), w = (*this)[0].size();\n    assert(h == m.size() && w == m[0].size());\n    for(ll i = 0; i < h; i++) {\n      for(ll j = 0; j < w; j++) { *this[i][j] += m[i][j]; }\n    }\n    return *this;\n  }\n  Matrix operator-=(const Matrix &m) {\n    ll h = this->size(), w = (*this)[0].size();\n    assert(h == m.size() && w == m[0].size());\n    for(ll i = 0; i < h; i++) {\n      for(ll j = 0; j < w; j++) { *this[i][j] -= m[i][j]; }\n    }\n    return *this;\n  }\n  Matrix operator*=(const Matrix &m) {\n    ll h = this->size(), w = (*this)[0].size();\n    assert(w == (ll)m.size());\n    vector<vector<T>> r(h, vector<T>(m[0].size(), T(0)));\n    for(ll i = 0; i < h; i++) {\n      for(ll j = 0; j < (ll)m[0].size(); j++) {\n        for(ll k = 0; k < w; k++) { r[i][j] += (*this)[i][k] * m[k][j]; }\n      }\n    }\n    this->swap(r);\n    return *this;\n  }\n  Matrix operator*=(const T &x) {\n    ll h = this->size(), w = (*this)[0].size();\n    for(ll i = 0; i < h; i++) {\n      for(ll j = 0; j < w; j++) { *this[i][j] *= x; }\n    }\n    return *this;\n  }\n  Matrix operator^=(ll n) {\n    ll h = this->size();\n    Matrix m(h);\n    while(n) {\n      if(n & 1) { m *= *this; }\n      *this *= *this;\n      n >>= 1LL;\n    }\n    this->swap(m);\n    return *this;\n  }\n};"
  // },
  // "Matrix_linear": {
  //   "prefix": "Matrix_linear",
  //   "body": "Matrix<long double> rotate(const long double &theta) {\n  Matrix<long double> r = {{cos(theta), -sin(theta)}, {sin(theta), cos(theta)}};\n  return r;\n}\nMatrix<ll> rotate_left() {\n  Matrix<ll> r = {{0, -1}, {1, 0}};\n  return r;\n}\nMatrix<ll> rotate_right() {\n  Matrix<ll> r = {{0, 1}, {-1, 0}};\n  return r;\n}\nMatrix<ll> flip_x() {\n  Matrix<ll> r = {{1, 0}, {0, -1}};\n  return r;\n}\nMatrix<ll> flip_y() {\n  Matrix<ll> r = {{-1, 0}, {0, 1}};\n  return r;\n}\nMatrix<ll> flip_O() {\n  Matrix<ll> r = {{-1, 0}, {0, -1}};\n  return r;\n}\nMatrix<long double> flip_line(long double &theta) {\n  theta *= 2;\n  Matrix<long double> r = {{cos(theta), sin(theta)}, {sin(theta), -cos(theta)}};\n  return r;\n}"
  // },
  // "Matrix_affine": {
  //   "prefix": "Matrix_affine",
  //   "body": "template<typename T> Matrix<T> translation(const T &x, const T &y) {\n  Matrix<T> r = {{1, 0, x}, {0, 1, y}, {0, 0, 1}};\n  return r;\n}\nMatrix<long double> rotate(const long double &theta) {\n  Matrix<long double> r = {{cos(theta), -sin(theta), 0}, {sin(theta), cos(theta), 0}, {0, 0, 1}};\n  return r;\n}\nMatrix<ll> rotate_left() {\n  Matrix<ll> r = {{0, -1, 0}, {1, 0, 0}, {0, 0, 1}};\n  return r;\n}\nMatrix<ll> rotate_right() {\n  Matrix<ll> r = {{0, 1, 0}, {-1, 0, 0}, {0, 0, 1}};\n  return r;\n}\nMatrix<ll> flip_x() {\n  Matrix<ll> r = {{1, 0, 0}, {0, -1, 0}, {0, 0, 1}};\n  return r;\n}\nMatrix<ll> flip_y() {\n  Matrix<ll> r = {{-1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n  return r;\n}\nMatrix<ll> flip_O() {\n  Matrix<ll> r = {{-1, 0, 0}, {0, -1, 0}, {0, 0, 1}};\n  return r;\n}"
  // },
  "matrix": {
    "prefix": "matrix",
    "body": "Matrix<${1:mint}> $0"
  },
  // "FormalPowerSeries": {
  //   "prefix": "FPS",
  //   "body": "struct FPS : vector<mint> {\n  using vector<mint>::vector;\n  using vector<mint>::operator=;\n  ll MOD = mint::mod();\n  bool FAST = !((MOD - 1) & ((1 << 23) - 1));\n  FPS pre(int deg) const {\n    FPS r((*this).begin(), (*this).begin() + min((int)this->size(), deg));\n    if((int)r.size() < deg) { r.resize(deg); }\n    return r;\n  }\n  FPS rev(int deg = -1) const {\n    FPS r(*this);\n    if(deg != -1) { r.resize(deg, mint(0)); }\n    ranges::reverse(r);\n    return r;\n  }\n  void shrink() {\n    while(this->size() && this->back() == mint(0)) { this->pop_back(); }\n  }\n  FPS operator+(const FPS &f) const { return FPS(*this) += f; }\n  FPS operator+(const mint &x) const { return FPS(*this) += x; }\n  FPS operator-(const FPS &f) const { return FPS(*this) -= f; }\n  FPS operator-(const mint &x) const { return FPS(*this) -= x; }\n  FPS operator*(const FPS &f) const { return FPS(*this) *= f; }\n  template<typename I> FPS operator*(const vector<pair<I, mint>> &f) const { return FPS(*this) *= f; }\n  template<typename I> FPS operator*(const pair<I, mint> &f) const { return FPS(*this) *= f; }\n  FPS operator*(const mint &x) const { return FPS(*this) *= x; }\n  FPS operator/(const FPS &f) const { return FPS(*this) /= f; }\n  template<typename I> FPS operator/(vector<pair<I, mint>> &f) const { return FPS(*this) /= f; }\n  template<typename I> FPS operator/(const pair<I, mint> &f) const { return FPS(*this) /= f; }\n  FPS operator/(const mint &x) const { return FPS(*this) /= x; }\n  FPS operator%(const FPS &f) const { return FPS(*this) %= f; }\n  FPS &operator+=(const FPS &f) {\n    if(f.size() > this->size()) { this->resize(f.size()); }\n    for(int i = 0; i < (int)f.size(); i++) { (*this)[i] += f[i]; }\n    return *this;\n  }\n  FPS &operator-=(const FPS &f) {\n    if(f.size() > this->size()) { this->resize(f.size()); }\n    for(int i = 0; i < (int)f.size(); i++) { (*this)[i] -= f[i]; }\n    return *this;\n  }\n  FPS &operator*=(const FPS &f) {\n    if(FAST) { *this = convolution(*this, f); }\n    else {\n      const int n = this->size(), m = f.size();\n      vector<ll> a(n), b(m);\n      static constexpr ll MOD1 = 754974721, MOD2 = 167772161, MOD3 = 469762049;\n      static constexpr ll M1_M2 = internal::inv_gcd(MOD1, MOD2).second, M12_M3 = internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n      ll M12 = (MOD1 * MOD2) % MOD;\n      for(int i = 0; i < n; i++) { a[i] = (*this)[i].val(); }\n      for(int i = 0; i < m; i++) { b[i] = f[i].val(); }\n      vector<ll> x = convolution<MOD1>(a, b), y = convolution<MOD2>(a, b), z = convolution<MOD3>(a, b);\n      vector<mint> c(n + m - 1);\n      for(int i = 0; i < n + m - 1; i++) {\n        ll v1 = (y[i] - x[i]) * M1_M2 % MOD2;\n        if(v1 < 0) { v1 += MOD2; }\n        ll v2 = (z[i] - (x[i] + MOD1 * v1) % MOD3) * M12_M3 % MOD3;\n        if(v2 < 0) { v2 += MOD3; }\n        c[i] = x[i] + MOD1 * v1 + M12 * v2;\n      }\n      *this = c;\n    }\n    return *this;\n  }\n  template<typename I> FPS &operator*=(const vector<pair<I, mint>> &f) {\n    const int n = this->size() - 1, m = f.back().first;\n    FPS r(n + m + 1, 0);\n    for(int i = 0; i <= n; i++) {\n      for(auto &[j, c] : f) { r[i + j] += (*this)[i] * c; }\n    }\n    return *this = r;\n  }\n  template<typename I> FPS &operator*=(const pair<I, mint> &f) {  // *(cx^d + 1)\n    const int n = this->size();\n    auto [d, c] = f;\n    for(int i = n - d - 1; i >= 0; i--) { (*this)[i + d] += (*this)[i] * c; }\n    return *this;\n  }\n  FPS &operator/=(const FPS &f) {\n    if(this->size() < f.size()) {\n      this->clear();\n      return *this;\n    }\n    return *this *= f.inv();\n  }\n  template<typename I> FPS &operator/=(vector<pair<I, mint>> &f) {\n    ranges::sort(f, [&](auto x, auto y) { return x.first > y.first; });\n    const ll n = this->size() - 1, m = f[0].first;\n    FPS r(n - m + 1, 0);\n    for(int i = n - m; i >= 0; i--) {\n      r[i] = (*this)[i + m] / f[0].second;\n      for(auto &[j, c] : f) { (*this)[i + j] -= r[i] * c; }\n    }\n    return *this = r;\n  }\n  template<typename I> FPS &operator/=(const pair<I, mint> &f) {  // /(cx^d + 1)\n    const int n = this->size();\n    auto [d, c] = f;\n    for(int i = 0; i < n - d; i++) { (*this)[i + d] -= (*this)[i] * c; }\n    return *this;\n  }\n  FPS &operator%=(const FPS &f) { return *this -= *this / f * f; }\n  pair<FPS, FPS> div_mod(const FPS &f) {\n    FPS g = *this / f;\n    return {g, *this - g * f};\n  }\n  FPS operator-() {\n    FPS r(this->size());\n    for(int i = 0; i < (int)(this->size()); i++) { r[i] = -(*this)[i]; }\n    return r;\n  }\n  FPS &operator+=(const mint &x) {\n    if(this->empty()) { this->resize(1); }\n    (*this)[0] += x;\n    return *this;\n  }\n  FPS &operator-=(const mint &x) {\n    if(this->empty()) { this->resize(1); }\n    (*this)[0] -= x;\n    return *this;\n  }\n  FPS &operator*=(const mint &x) {\n    for(int i = 0; i < (int)this->size(); i++) { (*this)[i] *= x; }\n    return *this;\n  }\n  FPS &operator/=(const mint &x) {\n    for(int i = 0; i < (int)this->size(); i++) { (*this)[i] /= x; }\n    return *this;\n  }\n  FPS operator>>(ll sz) {\n    if((int)this->size() <= sz) { return {}; }\n    FPS r(*this);\n    r.erase(r.begin(), r.begin() + sz);\n    return r;\n  }\n  FPS operator<<(ll sz) {\n    FPS r(*this);\n    r.insert(r.begin(), sz, mint(0));\n    return r;\n  }\n  FPS dot(const FPS &f) const {\n    FPS r(min(this->size(), f.size()));\n    for(int i = 0; i < (int)r.size(); i++) { r[i] = (*this)[i] * f[i]; }\n    return r;\n  }\n  mint operator()(mint x) const {\n    mint r = 0, w = 1;\n    for(auto &i : (*this)) {\n      r += w * i;\n      w *= x;\n    }\n    return r;\n  }\n  FPS diff() const {\n    const int n = this->size();\n    FPS r(n);\n    for(int i = 1; i < n; i++) { r[i - 1] = (*this)[i] * mint(i); }\n    r[n - 1] = 0;\n    return r;\n  }\n  FPS integral() const {\n    const int n = this->size();\n    vector<mint> inv(n);\n    inv[1] = 1;\n    for(int i = 2; i < n; i++) { inv[i] = -inv[MOD % i] * (MOD / i); }\n    FPS r(n);\n    for(int i = n - 2; i >= 0; i--) { r[i + 1] = (*this)[i] * inv[i + 1]; }\n    r[0] = 0;\n    return r;\n  }\n  FPS inv(ll deg = -1) const {\n    const int n = this->size();\n    if(deg == -1) { deg = n; }\n    assert(n && (*this)[0] != mint(0));\n    FPS res{(*this)[0].inv()};\n    if(FAST) {\n      while((int)res.size() < deg) {\n        int d = res.size();\n        FPS f(this->begin(), this->begin() + min(n, d * 2)), g(res);\n        f.resize(d * 2);\n        g.resize(d * 2);\n        internal::butterfly(f);\n        internal::butterfly(g);\n        for(int i = 0; i < d * 2; i++) { f[i] *= g[i]; }\n        internal::butterfly_inv(f);\n        f.erase(f.begin(), f.begin() + d);\n        f.resize(d * 2);\n        internal::butterfly(f);\n        for(int i = 0; i < d * 2; i++) { f[i] *= g[i]; }\n        internal::butterfly_inv(f);\n        mint iz = mint(d * 2).inv();\n        iz *= -iz;\n        for(int i = 0; i < d; i++) { f[i] *= iz; }\n        res.insert(res.end(), f.begin(), f.begin() + d);\n      }\n    }\n    else {\n      for(int i = 1; i < deg; i <<= 1) { res = (res + res - res * res * pre(i << 1)).pre(i << 1); }\n    }\n    return res.pre(deg);\n  }\n  FPS log(ll deg = -1) const {\n    assert((*this)[0] == mint(1));\n    if(deg == -1) { deg = this->size(); }\n    return (this->diff() * this->inv(deg)).pre(deg).integral();\n  }\n  FPS sqrt(ll deg = -1) {\n    const int n = this->size();\n    if(deg == -1) { deg = n; }\n    if((*this)[0] == mint(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != mint(0)) {\n          if(i & 1) { return {}; }\n          if(deg - i / 2 <= 0) { break; }\n          auto r = (*this >> i).sqrt(deg - i / 2);\n          if(r.empty()) { return {}; }\n          r = r << (i / 2);\n          if((int)r.size() < deg) { r.resize(deg, mint(0)); }\n          return r;\n        }\n      }\n      return FPS(deg, 0);\n    }\n    auto mod_sqrt = [&](const ll &a) -> ll {\n      ll m = MOD - 1, e = 0;\n      if(!a) { return 0; }\n      if(MOD == 2) { return a; }\n      if(mint(a).pow(m >> 1) != 1) { return -1; }\n      mint b = 1;\n      while(b.pow(m >> 1) == 1) { b++; }\n      while(~m & 1) {\n        m >>= 1;\n        e++;\n      }\n      mint x = mint(a).pow((m - 1) >> 1), y = mint(a) * x * x, z = mint(b).pow(m);\n      x *= a;\n      while(y != 1) {\n        ll j = 0;\n        mint t = y;\n        while(t != 1) {\n          j++;\n          t *= t;\n        }\n        z = z.pow(1LL << (e - j - 1));\n        x *= z;\n        z *= z;\n        y *= z;\n        e = j;\n      }\n      return x.val();\n    };\n    auto sq = mint(mod_sqrt((*this)[0].val()));\n    if(sq * sq != (*this)[0]) { return {}; }\n    FPS r{sq};\n    mint inv2 = mint(1) / mint(2);\n    for(int i = 1; i < deg; i <<= 1) { r = (r + pre(i << 1) * r.inv(i << 1)) * inv2; }\n    return r.pre(deg);\n  }\n  FPS exp(ll deg = -1) const {\n    const int n = this->size();\n    assert((*this)[0] == mint(0));\n    if(deg == -1) { deg = n; }\n    if(FAST) {\n      FPS inv;\n      inv.reserve(deg);\n      inv.emplace_back(mint(0));\n      inv.emplace_back(mint(1));\n      auto internal_integral = [&](FPS &f) {\n        const int n = f.size();\n        while((int)inv.size() <= n) {\n          int i = inv.size();\n          inv.emplace_back((-inv[MOD % i]) * (MOD / i));\n        }\n        f.insert(f.begin(), mint(0));\n        for(int i = 1; i <= n; i++) { f[i] *= inv[i]; }\n      };\n      auto internal_diff = [](FPS &f) {\n        if(f.empty()) { return; }\n        f.erase(f.begin());\n        mint c = 1;\n        for(int i = 0; i < (int)f.size(); i++, c++) { f[i] *= c; }\n      };\n      FPS b{1, 1 < (int)this->size() ? (*this)[1] : 0}, c{1}, z1, z2{1, 1};\n      for(int m = 2; m <= deg; m <<= 1) {\n        auto y = b;\n        y.resize(m * 2);\n        internal::butterfly(y);\n        z1 = z2;\n        FPS z(m);\n        for(int i = 0; i < m; i++) { z[i] = y[i] * z1[i]; }\n        internal::butterfly_inv(z);\n        mint si = mint(m).inv();\n        for(int i = 0; i < m; i++) { z[i] *= si; }\n        fill(z.begin(), z.begin() + m / 2, mint(0));\n        internal::butterfly(z);\n        for(int i = 0; i < m; i++) { z[i] *= -z1[i]; }\n        internal::butterfly_inv(z);\n        for(int i = 0; i < m; i++) { z[i] *= si; }\n        c.insert(c.end(), z.begin() + m / 2, z.end());\n        z2 = c;\n        z2.resize(m * 2);\n        internal::butterfly(z2);\n        FPS x(this->begin(), this->begin() + min((int)this->size(), m));\n        x.resize(m);\n        internal_diff(x);\n        x.emplace_back(mint(0));\n        internal::butterfly(x);\n        for(int i = 0; i < m; i++) { x[i] *= y[i]; }\n        internal::butterfly_inv(x);\n        for(int i = 0; i < m; i++) { x[i] *= si; }\n        x -= b.diff();\n        x.resize(m * 2);\n        for(int i = 0; i < m - 1; i++) {\n          x[m + i] = x[i];\n          x[i] = mint(0);\n        }\n        internal::butterfly(x);\n        for(int i = 0; i < m * 2; i++) { x[i] *= z2[i]; }\n        internal::butterfly_inv(x);\n        mint si2 = mint(m << 1).inv();\n        for(int i = 0; i < m * 2; i++) { x[i] *= si2; }\n        x.pop_back();\n        internal_integral(x);\n        for(int i = m; i < min((int)this->size(), m * 2); i++) { x[i] += (*this)[i]; }\n        fill(x.begin(), x.begin() + m, mint(0));\n        internal::butterfly(x);\n        for(int i = 0; i < m * 2; i++) { x[i] *= y[i]; }\n        internal::butterfly_inv(x);\n        for(int i = 0; i < m * 2; i++) { x[i] *= si2; }\n        b.insert(b.end(), x.begin() + m, x.end());\n      }\n      return b.pre(deg);\n    }\n    else {\n      FPS r({mint(1)});\n      for(int i = 1; i < deg; i <<= 1) { r = (r * (pre(i << 1) + mint(1) - r.log(i << 1))).pre(i << 1); }\n      return r.pre(deg);\n    }\n  }\n  FPS pow(ll k) {\n    const int n = this->size();\n    assert(k >= 0);\n    if(k == 0) {\n      FPS r(n, mint(0));\n      r[0] = mint(1);\n      return r;\n    }\n    for(int i = 0; i < n; i++) {\n      if(i * k > n) { return FPS(n, mint(0)); }\n      if((*this)[i] != mint(0)) {\n        mint rev = (*this)[i].inv();\n        FPS r = (((*this * rev) >> i).log() * k).exp() * ((*this)[i].pow(k));\n        r = (r << (i * k)).pre(n);\n        if((int)r.size() < n) { r.resize(n, mint(0)); }\n        return r;\n      }\n    }\n    return *this;\n  }\n  FPS mod_pow(ll k, FPS f) const {\n    FPS modinv = f.rev().inv();\n    auto get_div = [&](FPS base) {\n      if(base.size() < f.size()) {\n        base.clear();\n        return base;\n      }\n      ll n = base.size() - f.size() + 1;\n      return (base.rev().pre(n) * modinv.pre(n)).pre(n).rev(n);\n    };\n    FPS x(*this), r{1};\n    while(k > 0) {\n      if(k & 1) {\n        r *= x;\n        r -= get_div(r) * f;\n        r.shrink();\n      }\n      x *= x;\n      x -= get_div(x) * f;\n      x.shrink();\n      k >>= 1;\n    }\n    return r;\n  }\n};"
  // },
  // "TaylorShift": {
  //   "prefix": "TaylorShift",
  //   "body": "FPS TaylorShift(FPS f, mint c) {\n  const int N = f.size();\n  for(int i = 0; i < N; i++) { f[i] *= C(i); }\n  f = f.rev();\n  FPS g(N, 1);\n  for(int i = 1; i < N; i++) { g[i] = g[i - 1] * c * C[i]; }\n  f = (f * g).pre(N);\n  f = f.rev();\n  for(int i = 0; i < N; i++) { f[i] *= C(-i); }\n  return f;\n}"
  // },
  // "PrimeCount": {
  //   "prefix": "PrimeCount",
  //   "body": "uint64_t Root(uint64_t a, int k = 2) {\n  if(a <= 1 || k == 1) { return a; }\n  if(k >= 64) { return 1; }\n  auto check = [&](__uint128_t n) {\n    __uint128_t x = 1, m = n;\n    for(ll p = k; p; p >>= 1, m *= m) {\n      if(p & 1) { x *= m; }\n    }\n    return x <= a;\n  };\n  uint64_t n = powl(a, (long double)(1.0) / k);\n  while(!check(n)) { --n; }\n  while(check(n + 1)) { ++n; }\n  return n;\n}\n\nvector<bool> Eratosthenes(int n) {\n  vector<bool> prime(n + 1, true);\n  if(n >= 0) { prime[0] = false; }\n  if(n >= 1) { prime[1] = false; }\n  for(int i = 2; i * i <= n; i++) {\n    if(!prime[i]) { continue; }\n    for(int j = i + i; j <= n; j += i) { prime[j] = false; }\n  }\n  return prime;\n}\n\nstruct PrimeCount {\n private:\n  ll p2(ll x, ll y) {\n    if(x < 4) { return 0; }\n    ll a = cnt(y), b = cnt(Root(x));\n    if(a >= b) { return 0; }\n    ll sum = (a - 2) * (a + 1) / 2 - (b - 2) * (b + 1) / 2;\n    for(ll i = a; i < b; i++) { sum += cnt(x / primes[i]); }\n    return sum;\n  }\n  ll phi(ll m, ll n) {\n    if(m < 1) { return 0; }\n    if(n > m) { return 1; }\n    if(n < 1) { return m; }\n    if(m <= primes[n - 1] * primes[n - 1]) { return cnt(m) - n + 1; }\n    if(m <= primes[n - 1] * primes[n - 1] * primes[n - 1] && m <= sq) {\n      ll sx = cnt(Root(m)), ans = cnt(m) - (sx + n - 2) * (sx - n + 1) / 2;\n      for(ll i = n; i < sx; i++) { ans += cnt(m / primes[i]); }\n      return ans;\n    }\n    return phi(m, n - 1) - phi(m / primes[n - 1], n - 1);\n  }\n\n public:\n  ll sq;\n  vector<bool> prime;\n  vector<ll> prime_sum, primes;\n  PrimeCount(ll n): sq(Root(n)), prime_sum(sq + 1) {\n    prime = Eratosthenes(sq);\n    for(int i = 1; i <= sq; i++) { prime_sum[i] = prime_sum[i - 1] + prime[i]; }\n    primes.reserve(prime_sum[sq]);\n    for(int i = 1; i <= sq; i++) {\n      if(prime[i]) { primes.emplace_back(i); }\n    }\n  }\n  ll cnt(ll n) {\n    if(n <= sq) { return prime_sum[n]; }\n    ll m = Root(n, 3), a = cnt(m);\n    return phi(n, a) + a - 1 - p2(n, m);\n  }\n  inline ll operator()(ll n) { return cnt(n); }\n} P(1e11);"
  // },
  "mysort": {
    "prefix": "mysort",
    "body": "ranges::sort($1,[&](auto x,auto y){return $2;});$0 // condition to put x front"
  },
  "sortidx": {
    "prefix": "sortidx",
    "body": "vector<ll> ord(N);\niota(ord.begin(), ord.end(), 0);\nranges::sort(ord, [&](auto i, auto j) { return $1[i] < $1[j]; });"
  },
  "scc": {
    "prefix": "scc",
    "body": "scc_graph g(N);"
  },
  "suffix_array": {
    "prefix": "suffix_array",
    "body": "suffix_array($1)"
  },
  "lcp_array": {
    "prefix": "lcp_array",
    "body": "lcp_array($1,sa)"
  },
  "z_algorithm": {
    "prefix": "z_algorithm",
    "body": "z_algorithm($1)"
  },
  "fenwick_tree": {
    "prefix": "fenwick_tree",
    "body": "fenwick_tree<ll> $1(N);\n// f.add(i,x) f[i]+=x;\n// f.sum(l,r) sum[l,r)"
  },
  // "ShortestRepetition_str": {
  //   "prefix": "ShortestRepetition_str",
  //   "body": "int ShortestRepetition(const string &s) {\n  vector<int> z = z_algorithm(s);\n  int sz = s.size();\n  for(int i = 1; i < sz; i++) {\n    if(z[i] == sz - i && sz % i == 0) { return i; }\n  }\n  return sz;\n}"
  // },
  // "ShortestRepetition_vec": {
  //   "prefix": "ShortestRepetition_vec",
  //   "body": "template<typename T> int ShortestRepetition(const vector<T> &v) {\n  vector<int> z = z_algorithm(v);\n  int sz = v.size();\n  for(int i = 1; i < sz; i++) {\n    if(z[i] == sz - i && sz % i == 0) { return i; }\n  }\n  return sz;\n}"
  // },
  "testcase": {
    "prefix": "tt",
    "body": "ll ${1:Q}; cin>>${1:Q};\nwhile(${1:Q}--){\n  $2\n}"
  },
  "iota": {
    "prefix": "iota",
    "body": "iota(${1:v}.begin(),${1:v}.end(),0);$0"
  },
  "fixed": {
    "prefix": "fixed",
    "body": "cout << fixed << setprecision(12);"
  },
  "MaxFlow": {
    "prefix": "maxflow",
    "body": "mf_graph<ll> g(N); ${1://https://atcoder.github.io/ac-library/document_ja/maxflow.html}"
  },
  "add_edge": {
    "prefix": "add_edge",
    "body": "add_edge($1);$0"
  },
  // "BipartiteMatching": {
  //   "prefix": "BipartiteMatching",
  //   "body": "int BipartiteMatching(vector<vector<ll>> &g) {\n  const int N = g.size();\n  vector<int> color(N, -1);\n  auto DFS = [&](auto DFS, int v, int c) -> bool {\n    color[v] = c;\n    for(auto &nv : g[v]) {\n      if(color[nv] != -1) {\n        if(color[nv] == c) { return false; }\n        continue;\n      }\n      if(!DFS(DFS, nv, 1 - c)) { return false; }\n    }\n    return true;\n  };\n  for(int i = 0; i < N; i++) {\n    if(color[i] == -1) {\n      if(!DFS(DFS, i, 0)) { return -1; }\n    }\n  }\n  mf_graph<ll> f(N + 2);\n  for(int i = 0; i < N; i++) {\n    !color[i] ? f.add_edge(N, i, 1) : f.add_edge(i, N + 1, 1);\n    for(auto &j : g[i]) {\n      if(i >= j) { continue; }\n      !color[i] ? f.add_edge(i, j, 1) : f.add_edge(j, i, 1);\n    }\n  }\n  return f.flow(N, N + 1);\n}"
  // },
  "bipartitematching": {
    "prefix": "bipartitematching",
    "body": "BipartiteMatching(g);"
  },
  "Rational": {
    "prefix": "Rational",
    "body": "template<typename T> struct Rational {\n  T num, den;\n  Rational() {}\n  Rational(T num_): num(num_), den(1) {}\n  Rational(T num_, T den_): num(num_), den(den_) {\n    if(den < 0) num = -num, den = -den;\n  }\n  static Rational make(const T& x, const T& y) {\n    Rational m;\n    return m.num = x, m.den = y, m;\n  }\n  friend ostream& operator<<(ostream& os, const Rational& r) {\n    return (os << r.num << \" / \" << r.den);\n  }\n  Rational& operator=(T val) { return *this = Rational(val); }\n  bool operator<(const Rational& val) const { return num * val.den < den * val.num; }\n  bool operator<(const T val) const { return *this < Rational(val); }\n  friend bool operator<(const T val1, const Rational& val2) { return Rational(val1) < val2; }\n  bool operator>(const Rational& val) const { return val < *this; }\n  bool operator>(const T val) const { return *this > Rational(val); }\n  friend bool operator>(const T val1, const Rational& val2) { return Rational(val1) > val2; }\n  bool operator<=(const Rational& val) const { return !(*this > val); }\n  bool operator<=(const T val) const { return *this <= Rational(val); }\n  friend bool operator<=(const T val1, const Rational& val2) { return Rational(val1) <= val2; }\n  bool operator>=(const Rational& val) const { return !(*this < val); }\n  bool operator>=(const T val) const { return *this >= Rational(val); }\n  friend bool operator>=(const T val1, const Rational& val2) { return Rational(val1) >= val2; }\n  bool operator==(const Rational& val) const { return num * val.den == den * val.num; }\n  bool operator==(const T val) const { return *this == Rational(val); }\n  friend bool operator==(const T val1, const Rational& val2) { return Rational(val1) == val2; }\n  bool operator!=(const Rational& val) const { return !(*this == val); }\n  bool operator!=(const T val) const { return *this != Rational(val); }\n  friend bool operator!=(const T val1, const Rational& val2) { return Rational(val1) != val2; }\n  explicit operator bool() const noexcept { return num; }\n  bool operator!() const noexcept { return !static_cast<bool>(*this); }\n  Rational operator+() const { return *this; }\n  Rational operator-() const { return make(-num, den); }\n  friend Rational abs(const Rational& val) { return make(abs(val.num), val.den); }\n  Rational operator+(const Rational& val) const { return make(num * val.den + val.num * den, den * val.den); }\n  Rational operator+(T val) const { return *this + Rational(val); }\n  friend Rational operator+(T a, const Rational& b) { return b + a; }\n  Rational& operator+=(const Rational& val) { return *this = *this + val; }\n  Rational& operator+=(const T& val) { return *this = *this + val; }\n  Rational& operator++() { return *this += 1; }\n  Rational operator++(int) { return make(num + den, den); }\n  Rational operator-(const Rational& val) const { return make(num * val.den - val.num * den, den * val.den); }\n  Rational operator-(T val) const { return *this - Rational(val); }\n  friend Rational operator-(T a, const Rational& b) { return Rational(a) - b; }\n  Rational& operator-=(const Rational& val) { return *this = *this - val; }\n  Rational& operator-=(const T& val) { return *this = *this - val; }\n  Rational& operator--() { return *this -= 1; }\n  Rational operator--(int) { return make(num - den, den); }\n  Rational operator*(const Rational& val) const { return make(num * val.num, den * val.den); }\n  Rational operator*(T val) const { return *this * Rational(val); }\n  friend Rational operator*(T a, const Rational& b) { return b * a; }\n  Rational& operator*=(const Rational& val) { return *this = *this * val; }\n  Rational& operator*=(const T& val) { return *this = *this * val; }\n  Rational operator/(const Rational& val) const { return make(num * val.den, den * val.num); }\n  Rational operator/(T val) const { return *this / Rational(val); }\n  friend Rational operator/(T a, const Rational& b) { return Rational(a) / b; }\n  Rational& operator/=(const Rational& val) { return *this / val; }\n  Rational& operator/=(const T& val) { return *this = *this / val; }\n};"
  },
  // "ConvexHullTrick": {
  //   "prefix": "ConvexHullTrick",
  //   "body": "template<typename T, bool isMin> struct ConvexHullTrick {\n private:\n  deque<pair<T, T>> H;\n  static constexpr int sgn(T x) { return x == 0 ? 0 : (x < 0 ? -1 : 1); }\n  static constexpr T floor(T n, T d) { return n / d - ((n ^ d) < 0 && n % d); }\n  static constexpr bool check(const pair<T, T> &a, const pair<T, T> &b, const pair<T, T> &c) {\n    if(b.second == a.second || c.second == b.second) { return sgn(b.first - a.first) * sgn(c.second - b.second) >= sgn(c.first - b.first) * sgn(b.second - a.second); }\n    if constexpr(is_integral<T>::value) { return floor(b.second - a.second, a.first - b.first) >= floor(c.second - b.second, b.first - c.first); }\n    else { return (b.first - a.first) * sgn(c.second - b.second) / abs(b.second - a.second) >= (c.first - b.first) * sgn(b.second - a.second) / abs(c.second - b.second); }\n  }\n  static constexpr T get(const pair<T, T> &a, const T &x) { return a.first * x + a.second; }\n\n public:\n  ConvexHullTrick() = default;\n  bool empty() const { return H.empty(); }\n  void clear() { H.clear(); }\n  void add(T a, T b) {\n    if(!isMin) { a *= -1, b *= -1; }\n    pair<T, T> line(a, b);\n    if(empty()) {\n      H.emplace_front(line);\n      return;\n    }\n    if(H.front().first <= a) {\n      if(H.front().first == a) {\n        if(H.front().second <= b) { return; }\n        H.pop_front();\n      }\n      while(H.size() >= 2 && check(line, H.front(), H[1])) { H.pop_front(); }\n      H.emplace_front(line);\n    }\n    else {\n      assert(a <= H.back().first);\n      if(H.back().first == a) {\n        if(H.back().second <= b) { return; }\n        H.pop_back();\n      }\n      while(H.size() >= 2 && check(H[H.size() - 2], H.back(), line)) { H.pop_back(); }\n      H.emplace_back(line);\n    }\n  }\n  T query(T x) const {\n    assert(!empty());\n    int l = -1, r = H.size() - 1;\n    while(l + 1 < r) {\n      int m = (l + r) >> 1;\n      get(H[m], x) >= get(H[m + 1], x) ? l = m : r = m;\n    }\n    return isMin ? get(H[r], x) : -get(H[r], x);\n  }\n  T query_inc(T x) {\n    assert(!empty());\n    while(H.size() >= 2 && get(H.front(), x) >= get(H[1], x)) { H.pop_front(); }\n    return isMin ? get(H.front(), x) : -get(H.front(), x);\n  }\n  T query_dec(T x) {\n    assert(!empty());\n    while(H.size() >= 2 && get(H.back(), x) >= get(H[H.size() - 2], x)) { H.pop_back(); }\n    return isMin ? get(H.back(), x) : -get(H.back(), x);\n  }\n};\n// 直線 y = ax + b の追加クエリ（a は広義単調増加/減少）と，ある x での最大値/最小値取得クエリを処理\n// N = 追加される直線の数，Q = 最大値/最小値取得クエリの数\n// bool empty()        : 空かどうかを返す O(1)\n// void clear()        : 直線を全て消去 O(1)\n// void add(T a,T b)   : 直線 y = ax + b を追加（a は広義単調増加/減少） O(N) in total\n// T    query(T x)     : ax + b の最大値/最小値を返す O(log N)\n// T    query_inc(T x) : ax + b の最大値/最小値を返す（x は単調増加）O(N + Q) in total\n// T    query_dec(T x) : ax + b の最大値/最小値を返す（x は単調減少）O(N + Q) in total"
  // },
  "ConvexHullTrick_min": {
    "prefix": "ConvexHullTrick_min",
    "body": "ConvexHullTrick<ll,true> C;"
  },
  "ConvexHullTrick_max": {
    "prefix": "ConvexHullTrick_max",
    "body": "ConvexHullTrick<ll,false> C;"
  },
  // "Partition": {
  //   "prefix": "Partition",
  //   "body": "vector<vector<ll>> Partition(int n, int Maxlen = -1, int Maxval = -1) {\n  vector<vector<ll>> r;\n  auto DFS = [&](auto &&DFS, vector<ll> &v, int sum) -> void {\n    if(sum == n) {\n      r.emplace_back(v);\n      return;\n    }\n    if(Maxlen != -1 && ssize(v) == Maxlen) { return; }\n    int nx = (ssize(v) ? v.back() : n);\n    if(Maxval != -1) { nx = min(nx, Maxval); }\n    nx = min(nx, n - sum);\n    v.emplace_back(0);\n    for(ll i = nx; i >= 1; i--) {\n      v.back() = i;\n      DFS(DFS, v, sum + i);\n    }\n    v.pop_back();\n  };\n  vector<ll> v;\n  DFS(DFS, v, 0);\n  return r;\n}"
  // },
  "partition": {
    "prefix": "partition",
    "body": "Partition"
  },
  // "Namori": {
  //   "prefix": "Namori",
  //   "body": "struct Namori {\n  ll path_len;\n  vector<ll> path, loop;\n  Namori(const vector<ll> &nx, ll s = 0) {\n    vector<ll> vis(nx.size(), -1);\n    for(ll i = 0, p = s;; i++, p = nx[p]) {\n      if(vis[p] != -1) {\n        path_len = vis[p];\n        break;\n      }\n      loop.emplace_back(p);\n      vis[p] = i;\n    }\n    for(ll i = 0; i < path_len; i++) { path.emplace_back(loop[i]); }\n    loop.erase(loop.begin(), loop.begin() + path_len);\n  }\n  inline ll operator()(ll k) const { return k < path_len ? path[k] : loop[(k - path_len) % loop.size()]; }\n};"
  // },
  "namori": {
    "prefix": "namori",
    "body": "Namori g($1,${2:0});$0"
  },
  // "LiChaoTree": {
  //   "prefix": "LiChaoTree",
  //   "body": "template<typename T, T x_low, T x_high, T id> struct DynamicLiChaoTree {\n private:\n  struct Line {\n    T a, b;\n    Line(T a, T b): a(a), b(b) {}\n    inline T get(T x) const { return a * x + b; }\n  };\n  struct Node {\n    Line x;\n    Node *l, *r;\n    Node(const Line &x): x{x}, l{nullptr}, r{nullptr} {}\n  };\n  Node *root;\n  Node *add_line(Node *t, Line &x, const T &l, const T &r, const T &x_l, const T &x_r) {\n    if(!t) return new Node(x);\n    T t_l = t->x.get(l), t_r = t->x.get(r);\n    if(t_l <= x_l && t_r <= x_r) { return t; }\n    else if(t_l >= x_l && t_r >= x_r) {\n      t->x = x;\n      return t;\n    }\n    else {\n      T m = (l + r) / 2;\n      if(m == r) { --m; }\n      T t_m = t->x.get(m), x_m = x.get(m);\n      if(t_m > x_m) {\n        swap(t->x, x);\n        if(x_l >= t_l) { t->l = add_line(t->l, x, l, m, t_l, t_m); }\n        else { t->r = add_line(t->r, x, m + 1, r, t_m + x.a, t_r); }\n      }\n      else {\n        if(t_l >= x_l) { t->l = add_line(t->l, x, l, m, x_l, x_m); }\n        else { t->r = add_line(t->r, x, m + 1, r, x_m + x.a, x_r); }\n      }\n      return t;\n    }\n  }\n  Node *add_segment(Node *t, Line &x, const T &a, const T &b, const T &l, const T &r, const T &x_l, const T &x_r) {\n    if(r < a || b < l) { return t; }\n    if(a <= l && r <= b) {\n      Line y{x};\n      return add_line(t, y, l, r, x_l, x_r);\n    }\n    if(t) {\n      T t_l = t->x.get(l), t_r = t->x.get(r);\n      if(t_l <= x_l && t_r <= x_r) { return t; }\n    }\n    else { t = new Node(Line(0, id)); }\n    T m = (l + r) / 2;\n    if(m == r) { --m; }\n    T x_m = x.get(m);\n    t->l = add_segment(t->l, x, a, b, l, m, x_l, x_m);\n    t->r = add_segment(t->r, x, a, b, m + 1, r, x_m + x.a, x_r);\n    return t;\n  }\n  T query(const Node *t, const T &l, const T &r, const T &x) const {\n    if(!t) { return id; }\n    if(l == r) { return t->x.get(x); }\n    T m = (l + r) / 2;\n    if(m == r) { --m; }\n    if(x <= m) { return min(t->x.get(x), query(t->l, l, m, x)); }\n    else { return min(t->x.get(x), query(t->r, m + 1, r, x)); }\n  }\n\n public:\n  DynamicLiChaoTree(): root{nullptr} {}\n  void add_line(const T &a, const T &b) {\n    Line x(a, b);\n    root = add_line(root, x, x_low, x_high, x.get(x_low), x.get(x_high));\n  }\n  void add_segment(const T &l, const T &r, const T &a, const T &b) {\n    Line x(a, b);\n    root = add_segment(root, x, l, r - 1, x_low, x_high, x.get(x_low), x.get(x_high));\n  }\n  T query(const T &x) const { return query(root, x_low, x_high, x); }\n};\n// https://ei1333.github.io/library/structure/convex-hull-trick/dynamic-li-chao-tree.hpp"
  // },
  "modpow": {
    "prefix": "modpow",
    "body": "mint modpow(mint x, auto n) {\n  mint r = 1;\n  while(n) {\n    if(n & 1) {r = r * x;}\n    x = x * x;\n    n >>= 1;\n  }\n  return r;\n}"
  },
  "Rerooting": {
    "prefix": "Rerooting",
    "body": "template<typename Cost> struct Edge {\n  int src, to;\n  Cost cost;\n  Edge(int s, int t, Cost c = 1): src(s), to(t), cost(c) {}\n  operator int() const { return to; }\n};\n\ntemplate<typename Cost> struct Graph : vector<vector<Edge<Cost>>> {\n  Graph(int n): vector<vector<Edge<Cost>>>(n) {}\n  void add_edge(int s, int t, Cost c = 1) { (*this)[s].emplace_back(s, t, c); }\n};\n\ntemplate<typename Cost, typename Data, Data (*merge)(Data, Data), Data (*e)(), Data (*apply)(Data, int, int, Cost)>\nstruct Rerooting : Graph<Cost> {\n  vector<Data> dp, memo;\n  Rerooting(int n): Graph<Cost>::Graph(n) {}\n  vector<Data> build() {\n    memo.resize(this->size(), e());\n    dp.resize(this->size());\n    dfs1(0, -1);\n    dfs2(0, -1, e());\n    return dp;\n  }\n  void dfs1(int c, int p) {\n    bool upd = false;\n    for(Edge<Cost> &d : (*this)[c]) {\n      if(d == p) {continue;}\n      dfs1(d, c);\n      upd = true;\n      memo[c] = merge(memo[c], apply(memo[d], d, c, d.cost));\n    }\n    if(!upd) { memo[c] = e(); }\n  }\n  void dfs2(int c, int p, const Data &val) {\n    vector<Data> ds{val};\n    for(Edge<Cost> &d : (*this)[c]) {\n      if(d == p) { continue; }\n      ds.push_back(apply(memo[d], d, c, d.cost));\n    }\n    int n = ds.size(), idx = 1;\n    vector<Data> head(n + 1, e()), tail(n + 1, e());\n    for(int i = 0; i++ < n;) { head[i] = merge(head[i - 1], ds[i - 1]); }\n    for(int i = n; i-- > 0;) { tail[i] = merge(tail[i + 1], ds[i]); }\n    dp[c] = head[n];\n    for(Edge<Cost> &d : (*this)[c]) {\n      if(d == p) { continue; }\n      Data sub = merge(head[idx], tail[idx + 1]);\n      dfs2(d, c, apply(sub, c, d, d.cost));\n      idx++;\n    }\n  }\n};\n\nusing Cost = ll;\nusing Data = ll;\nData merge(Data a, Data b) { return ; }\nData e() { return ; }\nData apply(Data a, int c, int, Cost w) { return ; }"
  },
  "rerooting": {
    "prefix": "rerooting",
    "body": "Rerooting<Cost, Data, merge, e, apply> g(N);"
  },
  "lim_grid": {
    "prefix": "lim_grid",
    "body": "if(${1:nx}<0||${1:nx}>=H||${2:ny}<0||${2:ny}>=W) {continue;}"
  },
  // "MaximumRectangle": {
  //   "prefix": "Maximum_rectangle_LR",
  //   "body": "pair<vector<ll>, vector<ll>> MaximumRectangle(vector<ll> &h) {\n  ll n = h.size();\n  vector<ll> l(n, 0), r(n, n - 1);\n  stack<pair<ll, ll>> sl, sr;\n  for(ll i = 0; i < n; i++) {\n    while(!sl.empty() && h[i] <= sl.top().first) {sl.pop();}\n    if(!sl.empty()) {l[i] = sl.top().second + 1;}\n    sl.emplace(h[i], i);\n  }\n  for(ll i = n - 1; i >= 0; i--) {\n    while(!sr.empty() && h[i] <= sr.top().first) {sr.pop();}\n    if(!sr.empty()) {r[i] = sr.top().second - 1;}\n    sr.emplace(h[i], i);\n  }\n  return {l, r};\n}\n// min l[i], max r[i] s.t. [l[i],r[i]]<=H[i], 0-indexed"
  // },
  "maximumrectangle": {
    "prefix": "maximumrectangle",
    "body": "MaximumRectangle($1)"
  },
  // "floor": {
  //   "prefix": "floor",
  //   "body": "auto floor(auto a, auto b) {\n  assert(b != 0);\n  if(b < 0) { a = -a, b = -b; }\n  return a / b - (a % b < 0);\n}"
  // },
  // "under": {
  //   "prefix": "under",
  //   "body": "auto under(auto a, auto b) {\n  assert(b != 0);\n  if(b < 0) { a = -a, b = -b; }\n  return a / b - (a % b <= 0);\n}"
  // },
  // "ceil": {
  //   "prefix": "ceil",
  //   "body": "auto ceil(auto a, auto b) {\n  assert(b != 0);\n  if(b < 0) { a = -a, b = -b; }\n  return a / b + (a % b > 0);\n}"
  // },
  // "over": {
  //   "prefix": "over",
  //   "body": "auto over(auto a, auto b) {\n  assert(b != 0);\n  if(b < 0) { a = -a, b = -b; }\n  return a / b + (a % b >= 0);\n}"
  // },
  // "RelaxedConvolution": {
  //   "prefix": "RelaxedConvolution",
  //   "body": "struct RelaxedConvolution {\n  vector<mint> a, b, c;\n  ll k;\n  RelaxedConvolution(ll n): a(n), b(n), c(n), k(0) {}\n  mint operator()(mint na, mint nb) {\n    a[k] = na;\n    b[k] = nb;\n    ll s = k + 2;\n    for(ll w = 1; s % w == 0 && w < s; w <<= 1) {\n      for(ll r = 0; r < 2; r++) {\n        if(r == 0 || w * 2 != s) {\n          vector<mint> f(w), g(w);\n          for(ll i = 0; i < w; i++) {f[i] = a[w - 1 + i], g[i] = b[k - w + 1 + i];}\n          f = convolution(f, g);\n          for(ll i = 0, j = k; i < (ll)f.size() && j < (ll)c.size(); i++, j++) {c[j] += f[i];}\n        }\n        swap(a, b);\n      }\n    }\n    return c[k++];\n  }\n};"
  // },
  // "BinaryTrie": {
  //   "prefix": "BinaryTrie",
  //   "body": "template<int MAX_LOG = 32, typename T = int> struct BinaryTrie {\n private:\n  struct node {\n    int cnt;\n    T lazy;\n    node *ch[2];\n    node(): cnt(0), lazy(0), ch{nullptr, nullptr} {}\n  };\n  void push(node *t, int b) {\n    if((t->lazy >> (T)b) & (T)1) { swap(t->ch[0], t->ch[1]); }\n    if(t->ch[0]) { t->ch[0]->lazy ^= t->lazy; }\n    if(t->ch[1]) { t->ch[1]->lazy ^= t->lazy; }\n    t->lazy = 0;\n  }\n  node *add(node *t, T val, int b = MAX_LOG - 1) {\n    if(!t) { t = new node; }\n    t->cnt += 1;\n    if(b < 0) { return t; }\n    push(t, b);\n    bool f = (val >> (T)b) & (T)1;\n    t->ch[f] = add(t->ch[f], val, b - 1);\n    return t;\n  }\n  node *sub(node *t, T val, int b = MAX_LOG - 1) {\n    assert(t);\n    t->cnt -= 1;\n    if(t->cnt == 0) { return nullptr; }\n    if(b < 0) { return t; }\n    push(t, b);\n    bool f = (val >> (T)b) & (T)1;\n    t->ch[f] = sub(t->ch[f], val, b - 1);\n    return t;\n  }\n  T get_min(node *t, T val, int b = MAX_LOG - 1) {\n    assert(t);\n    if(b < 0) { return 0; }\n    push(t, b);\n    bool f = (val >> (T)b) & (T)1;\n    f ^= !t->ch[f];\n    return get_min(t->ch[f], val, b - 1) | ((T)f << (T)b);\n  }\n  T get(node *t, int k, int b = MAX_LOG - 1) {\n    if(b < 0) { return 0; }\n    push(t, b);\n    int m = t->ch[0] ? t->ch[0]->cnt : 0;\n    return k < m ? get(t->ch[0], k, b - 1) : get(t->ch[1], k - m, b - 1) | ((T)1 << (T)b);\n  }\n  int count_lower(node *t, T val, int b = MAX_LOG - 1) {\n    if(!t || b < 0) { return 0; }\n    push(t, b);\n    bool f = (val >> (T)b) & (T)1;\n    return (f && t->ch[0] ? t->ch[0]->cnt : 0) + count_lower(t->ch[f], val, b - 1);\n  }\n  node *root;\n\n public:\n  BinaryTrie(): root(nullptr) {}\n  int size() const { return root ? root->cnt : 0; }\n  bool empty() const { return !root; }\n  void insert(T val) { root = add(root, val); }\n  void erase(T val) {\n    if(!count(val)) { return; }\n    root = sub(root, val);\n  }\n  void xor_all(T val) {\n    if(root) { root->lazy ^= val; }\n  }\n  T max_element(T xor_val = 0) {\n    xor_all(xor_val);\n    T r = get_min(root, -1);\n    xor_all(xor_val);\n    return r;\n  }\n  T min_element(T xor_val = 0) {\n    xor_all(xor_val);\n    T r = get_min(root, 0);\n    xor_all(xor_val);\n    return r;\n  }\n  T kth_smallest(int k, T xor_val = 0) {\n    assert(0 <= k && k < size());\n    xor_all(xor_val);\n    T r = get(root, k);\n    xor_all(xor_val);\n    return r;\n  }\n  int lower_bound(T val, T xor_val = 0) {\n    xor_all(xor_val);\n    int r = count_lower(root, val);\n    xor_all(xor_val);\n    return r;\n  }\n  int upper_bound(T val, T xor_val = 0) {\n    xor_all(xor_val);\n    int r = count_lower(root, val + 1);\n    xor_all(xor_val);\n    return r;\n  }\n  int count(T val) {\n    if(!root) { return 0; }\n    node *t = root;\n    for(int i = MAX_LOG - 1; i >= 0; i--) {\n      push(t, i);\n      t = t->ch[(val >> (T)i) & (T)1];\n      if(!t) { return 0; }\n    }\n    return t->cnt;\n  }\n};\n// 引数 xor を指定すると全要素をそれで xor した場合の動作をする（変更はしない）\n// メンバ関数は 種類数 ではなく 要素数 を返す\n//\n// BinaryTrie<MAX_LOG,T>()   : コンストラクタ\n// bool empty()              : 空かどうかを返す O(1)\n// int  size()               : return ＃{i∈S} O(1)\n// void insert(val)          : val を１つ追加 O(w)\n// void erase(val)           : val があれば１つ消去，無ければ何もしない O(w)\n// void xor_all(val)         : 全要素を val で xor した値に変更 O(1)\n// T    max_element(xor)     : return max(S)  O(w)\n// T    min_element(xor)     : return min(S)  O(w)\n// T    kth_smallest(k,xor)  : return k-th(0-indexed) smallest number in S O(w)\n// int  lower_bound(val,xor) : return ＃{i∈S | i < val}  O(w)\n// int  upper_bound(val,xor) : return ＃{i∈S | i <= val} O(w)\n// int  count(val)           : return ＃{i∈S | i == val} O(w)\n"
  // },
  "binarytrie": {
    "prefix": "binarytrie",
    "body": "BinaryTrie<30> b;"
  },
  "ranges": {
    "prefix": "ranges",
    "body": "ranges::"
  },
  "views": {
    "prefix": "views",
    "body": "views::"
  },
  "views_reverse": {
    "prefix": "views_reverse",
    "body": "views::reverse($1)$0"
  },
  "views_keys": {
    "prefix": "keys",
    "body": "views::keys($1)$0"
  },
  "views_values": {
    "prefix": "values",
    "body": "views::values($1)$0"
  },
  // "Lowlink": {
  //   "prefix": "Lowlink",
  //   "body": "struct Lowlink {\n  const vector<vector<ll>> g;\n  ll N;\n  vector<ll> ord, low;\n  vector<ll> articulation;  // 関節点\n  vector<pair<ll, ll>> bridge;  // 橋 (辺(u, v)が u < v となるよう格納)\n  Lowlink(const vector<vector<ll>> &g_): g(g_), N(g.size()), ord(N, -1), low(N, -1) {\n    for(ll i = 0, k = 0; i < N; i++) {\n      if(ord[i] == -1) {k = dfs(i, k, -1);}\n    }\n  }\n  ll dfs(ll idx, ll k, ll par) {\n    low[idx] = (ord[idx] = k++);\n    ll cnt = 0;\n    bool arti = false, second = false;\n    for(auto &to : g[idx]) {\n      if(ord[to] == -1) {\n        cnt++;\n        k = dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        arti |= (par != -1) && (low[to] >= ord[idx]);\n        if(ord[idx] < low[to]) {bridge.emplace_back(minmax(idx, to));}\n      }\n      else if(to != par || second) {low[idx] = min(low[idx], ord[to]);}\n      else {second = true;}\n    }\n    arti |= par == -1 && cnt > 1;\n    if(arti) {articulation.emplace_back(idx);}\n    return k;\n  }\n};"
  // },
  // "StringSearch": {
  //   "prefix": "StringSearch",
  //   "body": "template<typename T> struct SparseTable {\n  inline static constexpr T INF = numeric_limits<T>::max() / 2;\n  int N;\n  vector<vector<T>> table;\n  T f(T a, T b) { return min(a, b); }\n  SparseTable() {}\n  SparseTable(const vector<T> &v): N(ssize(v)) {\n    int b = 1;\n    while((1 << b) <= N) { ++b; }\n    table.emplace_back(v);\n    for(int i = 1; i < b; i++) {\n      table.emplace_back(vector<T>(N, INF));\n      for(int j = 0; j + (1 << i) <= N; j++) {\n        table[i][j] = f(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n  }\n  T query(int l, int r) {  // [l, r)\n    assert(0 <= l && l <= r && r <= N);\n    if(l == r) { return INF; }\n    int b = 31 - __builtin_clz(r - l);\n    return f(table[b][l], table[b][r - (1 << b)]);\n  }\n};\n\ntemplate<typename T> struct StringSearch {\n  const T &S;\n  ll N;\n  vector<int> sa, la, inv;\n  SparseTable<int> sparse;\n  StringSearch(const T &s_): S(s_), N(ssize(S)) {\n    sa = suffix_array(S);\n    la = lcp_array(S, sa);\n    inv.resize(N);\n    for(ll i = 0; i < N; i++) { inv[sa[i]] = i; }\n    sparse = SparseTable<int>{la};\n  }\n  // lcp(s[i, N), s[j, N))\n  ll lcp(ll i, ll j) {\n    assert(0 <= min(i, j) && max(i, j) < N);\n    if(i == j) { return N - i; }\n    auto [x, y] = minmax(inv[i], inv[j]);\n    return sparse.query(x, y);\n  }\n  // lcp(s[a, b), s[c, d))\n  ll lcp(ll a, ll b, ll c, ll d) {\n    assert(0 <= a && a <= b && b <= N);\n    assert(0 <= c && c <= d && d <= N);\n    ll l = lcp(a, c);\n    return min({l, b - a, d - c});\n  }\n  ll lcp(pair<ll, ll> p, pair<ll, ll> q) {\n    return lcp(p.first, p.second, q.first, q.second);\n  }\n  // s[i, N) > s[j, N) : 1\n  // s[i, N) = s[j, N) : 0\n  // s[i, N) < s[j, N) : -1\n  ll compare(ll i, ll j) {\n    assert(0 <= min(i, j) && max(i, j) < N);\n    if(i == j) { return 0; }\n    return inv[i] < inv[j] ? -1 : 1;\n  }\n  // s[a, b) > s[c, d) : 1\n  // s[a, b) = s[c, d) : 0\n  // s[a, b) < s[c, d) : -1\n  ll compare(ll a, ll b, ll c, ll d) {\n    ll l = lcp(a, b, c, d);\n    return a + l == b     ? (c + l == d ? 0 : -1)\n    : c + l == d          ? 1\n    : S[a + l] < S[c + l] ? -1\n                          : 1;\n  }\n  ll compare(pair<ll, ll> p, pair<ll, ll> q) {\n    return compare(p.first, p.second, q.first, q.second);\n  }\n};"
  // },
  // "Tree": {
  //   "prefix": "Tree",
  //   "body": "struct Tree : vector<vector<ll>> {\n private:\n  void dfs_sz(int v, int p) {\n    sz[v] = 1;\n    ord.emplace_back(v);\n    for(int i = p, x = 0; i != -1;) {\n      bl[v][x] = i;\n      i = bl[i][x], x++;\n    }\n    for(auto &nv : (*this)[v]) {\n      if(nv == p) {\n        if((int)(*this)[v].size() >= 2 && nv == (*this)[v][0]) { std::swap((*this)[v][0], (*this)[v][1]); }\n        else { continue; }\n      }\n      dp[nv] = dp[v] + 1;\n      dfs_sz(nv, v);\n      sz[v] += sz[nv];\n      if(sz[nv] > sz[(*this)[v][0]]) { std::swap(nv, (*this)[v][0]); }\n    }\n  }\n  void dfs_hld(int v) {\n    down[v] = id++;\n    for(auto &nv : (*this)[v]) {\n      if(nv == parent(v)) { continue; }\n      nx[nv] = (nv == (*this)[v][0] ? nx[v] : nv);\n      dfs_hld(nv);\n    }\n    up[v] = id;\n  }\n  vector<pair<int, int>> ascend(int u, int v) const {\n    vector<pair<int, int>> r;\n    while(nx[u] != nx[v]) {\n      r.emplace_back(down[u], down[nx[u]]);\n      u = parent(nx[u]);\n    }\n    if(u != v) { r.emplace_back(down[u], down[v] + 1); }\n    return r;\n  }\n  vector<pair<int, int>> descend(int u, int v) const {\n    if(u == v) { return {}; }\n    if(nx[u] == nx[v]) { return {{down[u] + 1, down[v]}}; }\n    auto r = descend(u, parent(nx[v]));\n    r.emplace_back(down[nx[v]], down[v]);\n    return r;\n  }\n\n public:\n  int n, root, id = 0;\n  vector<array<int, 24>> bl;\n  vector<int> dp, sz, ord, down, up, nx;\n  Tree(int n_, int r = 0): n(n_), root(r) { this->resize(n); }\n  Tree(vector<vector<ll>> &g, int r = 0): n(g.size()), root(r) {\n    *this = g;\n    build();\n  }\n  void add_edge(int u, int v) {\n    (*this)[u].emplace_back(v);\n    (*this)[v].emplace_back(u);\n  }\n  void build() {\n    bl.resize(n);\n    dp.resize(n);\n    sz.resize(n);\n    down.assign(n, -1);\n    up.assign(n, -1);\n    nx.assign(n, root);\n    for(auto &v : bl) { ranges::fill(v, -1); }\n    dfs_sz(root, -1);\n    dfs_hld(root);\n  }\n  int size() const { return n; }\n  int depth(int i) const { return dp[i]; }\n  int parent(int i) const { return i == root ? root : bl[i][0]; }\n  int order(int i) const { return ord[i]; }\n  int in(int i) const { return down[i]; }\n  int out(int i) const { return up[i]; }\n  int size(int i) const { return sz[i]; }\n  int kth_ancestor(int i, int k) const {\n    if(dp[i] < k) { return -1; }\n    while(k) {\n      int t = __builtin_ctz(k);\n      i = bl[i][t], k ^= 1 << t;\n    }\n    return i;\n  }\n  int distance(int u, int v) { return dp[u] + dp[v] - dp[lca(u, v)] * 2; }\n  bool onpath(int u, int x, int v) { return distance(u, v) == distance(u, x) + distance(x, v); }\n  // vertex adjacent to u on u-v path\n  int nxt(int u, int v) const {\n    if(dp[u] >= dp[v]) { return parent(u); }\n    int x = kth_ancestor(v, dp[v] - dp[u] - 1);\n    return bl[x][0] == u ? x : bl[u][0];\n  }\n  vector<int> path(int u, int v) const {\n    vector<int> pre, suf;\n    while(dp[u] > dp[v]) {\n      pre.emplace_back(u);\n      u = bl[u][0];\n    }\n    while(dp[u] < dp[v]) {\n      suf.emplace_back(v);\n      v = bl[v][0];\n    }\n    while(u != v) {\n      pre.emplace_back(u);\n      suf.emplace_back(v);\n      u = bl[u][0];\n      v = bl[v][0];\n    }\n    pre.emplace_back(u);\n    ranges::reverse(suf);\n    copy(suf.begin(), suf.end(), back_inserter(pre));\n    return pre;\n  }\n  int lca(int u, int v) {\n    while(nx[u] != nx[v]) {\n      if(down[u] < down[v]) { std::swap(u, v); }\n      u = parent(nx[u]);\n    }\n    return dp[u] < dp[v] ? u : v;\n  }\n  // vertex at distance x from u on u-v path\n  int jump(int u, int v, int x) {\n    int lc = lca(u, v), d1 = dp[u] - dp[lc];\n    if(x <= d1) { return kth_ancestor(u, x); }\n    int d = d1 + dp[v] - dp[lc];\n    if(x <= d) { return kth_ancestor(v, d - x); }\n    return -1;\n  }\n  vector<int> diameter() {\n    int s = ranges::max_element(dp) - dp.begin();\n    vector<int> d(n, -1);\n    d[s] = 0;\n    queue<int> q;\n    q.emplace(s);\n    while(!q.empty()) {\n      int v = q.front();\n      q.pop();\n      for(auto &nv : (*this)[v]) {\n        if(d[nv] == -1) {\n          d[nv] = d[v] + 1;\n          q.emplace(nv);\n        }\n      }\n    }\n    int t = ranges::max_element(d) - d.begin();\n    return path(t, s);\n  }\n  template<typename F> void query(int u, int v, bool vertex, const F &f) {\n    int l = lca(u, v);\n    for(auto &&[a, b] : ascend(u, l)) {\n      int s = a + 1, t = b;\n      s > t ? f(t, s) : f(s, t);\n    }\n    if(vertex) f(down[l], down[l] + 1);\n    for(auto &&[a, b] : descend(l, v)) {\n      int s = a, t = b + 1;\n      s > t ? f(t, s) : f(s, t);\n    }\n  }\n  template<typename F> void noncommutative_query(int u, int v, bool vertex, const F &f) {\n    int l = lca(u, v);\n    for(auto &&[a, b] : ascend(u, l)) { f(a + 1, b); }\n    if(vertex) { f(down[l], down[l] + 1); }\n    for(auto &&[a, b] : descend(l, v)) { f(a, b + 1); }\n  }\n  template<typename F> void subtree_query(int u, bool vertex, const F &f) {\n    f(down[u] + int(!vertex), up[u]);\n  }\n};"
  // },
  "PI": {
    "prefix": "PI",
    "body": "numbers::pi"
  },
  "__int128_t": {
    "prefix": "int128t",
    "body": "__int128_t"
  },
  // "UniteInterval": {
  //   "prefix": "UniteInterval",
  //   "body": "// union of [a1,b1), [a2,b2) ...\ntemplate<typename T> vector<pair<T, T>> UniteInterval(const vector<pair<T, T>> &v) {\n  vector<pair<T, T>> u{v}, r;\n  ranges::sort(u);\n  for(auto &p : u) {\n    r.emplace_back(p);\n    while((int)r.size() >= 2) {\n      const int n = r.size();\n      if(r[n - 2].second < r[n - 1].first) { break; }\n      pair<T, T> q = {r[n - 2].first, max<T>(r[n - 2].second, r[n - 1].second)};\n      r.pop_back();\n      r.pop_back();\n      r.emplace_back(q);\n    }\n  }\n  return r;\n}"
  // },
  "uniteinterval": {
    "prefix": "uniteinterval",
    "body": "UniteInterval($1);$0"
  },
  // "Mulall": {
  //   "prefix": "Mulall",
  //   "body": "auto mulall(vector<auto> &v) {\n  queue<int> q;\n  for(int i = 0; i < (int)v.size(); i++) { q.emplace(i); }\n  while((int)q.size() >= 2) {\n    int x = q.front();\n    q.pop();\n    int y = q.front();\n    q.pop();\n    v[x] = convolution(v[x], v[y]);\n    q.emplace(x);\n  }\n  return v[q.front()];\n}"
  // },
  "mulall": {
    "prefix": "mulall",
    "body": "mulall($1);$0"
  },
  // "Bostan_Mori": {
  //   "prefix": "Bostan_Mori",
  //   "body": "mint BostanMori(FPS p, FPS q, ll n) {\n  ll m = max(p.size(), q.size());\n  p.resize(m);\n  q.resize(m);\n  while(n) {\n    FPS r = q;\n    for(ll i = 0; i < ssize(r); i += 2) { r[i] = -r[i]; }\n    FPS v = q * r, u = p * r;\n    for(ll i = n % 2; i < ssize(u); i += 2) { p[i / 2] = u[i]; }\n    for(ll i = 0; i < ssize(v); i += 2) { q[i / 2] = v[i]; }\n    n /= 2;\n  }\n  return p[0] / q[0];\n}\n\n// ini = { a_0, a_1, ..., a_{k-1} }\n// a_n = rec_0 * a_{n-1} + rec_1 * a_{n-2} +...+ rec_{k-1} * a_{n-k}\ntemplate<typename T, typename U> mint LinearRecurrence(const vector<T> &ini, const vector<U> &rec, ll n) {\n  ll s = ini.size(), k = rec.size();\n  assert(s >= k);\n  FPS p, q(k + 1), a(s);\n  q[0] = 1;\n  for(ll i = 0; i < k; i++) { q[i + 1] = -rec[i]; }\n  for(ll i = 0; i < s; i++) { a[i] = ini[i]; }\n  p = (q * a).pre(k);\n  return BostanMori(p, q, n);\n}"
  // },
  // "BMBM": {
  //   "prefix": "BMBM",
  //   "body": "template<typename T> vector<mint> BerlekampMassey(const vector<T> &v) {\n  const int N = v.size();\n  vector<mint> b, c;\n  b.reserve(N + 1);\n  c.reserve(N + 1);\n  b.push_back(1);\n  c.push_back(1);\n  mint y = 1;\n  for(int ed = 1; ed <= N; ed++) {\n    int l = c.size(), m = b.size();\n    mint x = 0;\n    for(int i = 0; i < l; i++) { x += c[i] * v[ed - l + i]; }\n    b.emplace_back(0);\n    m++;\n    if(x == 0) { continue; }\n    mint freq = x / y;\n    if(l < m) {\n      auto tmp = c;\n      c.insert(begin(c), m - l, 0);\n      for(int i = 0; i < m; i++) { c[m - i - 1] -= freq * b[m - i - 1]; }\n      b = tmp;\n      y = x;\n    }\n    else {\n      for(int i = 0; i < m; i++) { c[l - i - 1] -= freq * b[m - i - 1]; }\n    }\n  }\n  c.pop_back();\n  for(auto &i : c) { i = -i; }\n  ranges::reverse(c);\n  return c;\n}\n\ntemplate<typename T> mint BMBM(const vector<T> &v, ll n) {\n  auto bm = BerlekampMassey(v);\n  return LinearRecurrence(v, bm, n);\n}"
  // },
  "if": {
    "prefix": "if",
    "body": "if($1){$2}$0"
  },
  "elif": {
    "prefix": "else if",
    "body": "else if($1){$2}$0"
  },
  "else": {
    "prefix": "else",
    "body": "else{$1}$0"
  },
  "PersistentArray": {
    "prefix": "PersistentArray",
    "body": "template<typename T, int shift = 4> struct PersistentArray {\n  struct Node {\n    Node *ns[1 << shift];\n    Node() { memset(ns, 0, sizeof(ns)); }\n    Node(const Node &other) { memcpy(ns, other.ns, sizeof(ns)); }\n    Node(const Node *other) { memcpy(ns, other->ns, sizeof(ns)); }\n  };\n  inline Node *my_new() { return new Node(); }\n  inline Node *my_new(const Node &other) { return new Node(other); }\n  inline Node *my_new(const Node *other) { return new Node(other); }\n  inline T *my_new_leaf(const T &val) { return new T{val}; }\n  static constexpr int mask = (1 << shift) - 1;\n  Node *root;\n  int depth;\n  T ID;\n  PersistentArray() {}\n  PersistentArray(ll MAX, T ID_ = T(0)): root(my_new()), depth(0), ID(ID_) {\n    while(MAX) {\n      depth++;\n      MAX >>= shift;\n    }\n  }\n  PersistentArray(const vector<T> &v, T ID_ = T(0)): root(my_new()), depth(0), ID(ID_) {\n    ll MAX = v.size();\n    while(MAX) {\n      depth++;\n      MAX >>= shift;\n    }\n    for(ll i = 0; i < (ll)v.size(); i++) {\n      Node *n = root;\n      for(ll k = i, d = depth; d; d--) {\n        if(!(n->ns[k & mask])) {\n          if(d == 1) { n->ns[k & mask] = reinterpret_cast<Node *>(my_new_leaf(v[i])); }\n          else { n->ns[k & mask] = my_new(); }\n        }\n        n = n->ns[k & mask];\n        k >>= shift;\n      }\n    }\n  }\n  T get(Node *n, ll k) const {\n    for(ll i = depth; i; i--) {\n      n = n ? n->ns[k & mask] : nullptr;\n      k >>= shift;\n    }\n    return n ? *reinterpret_cast<T *>(n) : ID;\n  }\n  T get(ll k) const { return get(root, k); }\n  Node *update(Node *n, ll k, const T &val) {\n    stack<pair<Node *, int>> st;\n    for(ll i = depth; i; i--) {\n      st.emplace(n, k & mask);\n      n = n ? n->ns[k & mask] : nullptr;\n      k >>= shift;\n    }\n    Node *chd = reinterpret_cast<Node *>(my_new_leaf(val));\n    while(!st.empty()) {\n      Node *par;\n      ll k;\n      tie(par, k) = st.top();\n      st.pop();\n      Node *nxt = par ? my_new(par) : my_new();\n      nxt->ns[k] = chd;\n      chd = nxt;\n    }\n    return root = chd;\n  }\n  Node *update(ll k, const T &val) { return update(root, k, val); }\n};"
  },
  "lll": {
    "prefix": "lll",
    "body": "const ll D_SI = 125;\nstruct lll : vector<ll> {\n  static const ll BASE = 100000000;\n  static const ll BASE_D = 8;\n  ll sign;\n  lll(ll n = 0): vector<ll>(D_SI, 0), sign(1) {\n    if(n < 0) { sign = -1, n = -n; }\n    (*this)[0] = n;\n    this->normalize();\n  }\n  lll(ll size, ll n): vector<ll>(size, n), sign(1) {}\n  lll &normalize() {\n    ll c = 0;\n    bool e = false;\n    for(ll i = 0;; ++i) {\n      if(i >= this->size()) { this->push_back(0); }\n      if((*this)[i] < 0 && i + 1 >= this->size()) { this->push_back(0); }\n      while((*this)[i] < 0) {\n        (*this)[i + 1] -= 1;\n        (*this)[i] += BASE;\n      }\n      ll a = (*this)[i] + c;\n      (*this)[i] = a % BASE;\n      if((*this)[i]) { e = 1; }\n      c = a / BASE;\n      if(c == 0 && i == this->size() - 1) { break; }\n    }\n    if(!e) { sign = 1; }\n    return (*this);\n  }\n  friend lll abs(const lll &x) {\n    lll z = x;\n    if(z.sign == -1) { z.sign = 1; }\n    return z;\n  }\n  lll operator-() const {\n    lll r = *this;\n    bool z = 1;\n    for(ll i = 0; i < (ll)this->size(); i++) {\n      if(r[i] != 0) {\n        z = 0;\n        break;\n      }\n    }\n    if(!z) { r.sign = -r.sign; }\n    return r;\n  }\n  lll &operator+=(const lll &r) {\n    while(size() < r.size()) this->emplace_back(0);\n    if(sign == r.sign) {\n      for(ll i = 0; i < (ll)r.size(); i++) {\n        (*this)[i] += r[i];\n      }\n    }\n    else {\n      if(sign == 1 && abs(*this) < abs(r)) { sign = -1; }\n      else if(sign == -1 && abs(*this) <= abs(r)) { sign = 1; }\n      if(abs(*this) >= abs(r)) {\n        for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] -= r[i]; }\n      }\n      else {\n        for(ll i = 0; i < (ll)size(); i++) { (*this)[i] = -(*this)[i]; }\n        for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] += r[i]; }\n      }\n    }\n    return this->normalize();\n  }\n  lll &operator-=(const lll &r) {\n    while(size() < r.size()) { this->emplace_back(0); }\n    if(sign == -r.sign) {\n      for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] += r[i]; }\n    }\n    else {\n      if(sign == 1 && abs(*this) < abs(r)) { sign = -1; }\n      else if(sign == -1 && abs(*this) <= abs(r)) { sign = 1; }\n      if(abs(*this) >= abs(r)) {\n        for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] -= r[i]; }\n      }\n      else {\n        for(ll i = 0; i < (ll)size(); i++) { (*this)[i] = -(*this)[i]; }\n        for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] += r[i]; }\n      }\n    }\n    return this->normalize();\n  }\n  lll &operator*=(ll r) {\n    if((sign == 1 && r >= 0) || (sign == -1 && r < 0)) { sign = 1; }\n    else { sign = -1; }\n    if(r < 0) { r = -r; }\n    for(ll i = 0; i < (ll)size(); i++) { (*this)[i] *= r; }\n    return this->normalize();\n  }\n  lll &operator*=(const lll &r) {\n    ll tx = size() - 1, ty = r.size() - 1;\n    for(tx = size() - 1; tx >= 0; --tx) {\n      if((*this)[tx] > 0) { break; }\n    }\n    for(ty = r.size() - 1; ty >= 0; --ty) {\n      if(r[ty] > 0) { break; }\n    }\n    lll res(0);\n    res.resize(tx + ty + 2);\n    if(sign == r.sign) { res.sign = 1; }\n    else { res.sign = -1; }\n    for(ll i = 0; i <= tx; i++) {\n      for(ll j = 0; j <= ty && i + j < res.size() - 1; j++) {\n        ll val = (*this)[i] * r[j] + res[i + j];\n        res[i + j + 1] += val / lll::BASE;\n        res[i + j] = val % lll::BASE;\n      }\n    }\n    return (*this) = res.normalize();\n  }\n  friend lll POW(const lll &a, ll n) {\n    lll r(1), b = a;\n    while(n > 0) {\n      if(n & 1) { r = r * b; }\n      b = b * b;\n      n >>= 1;\n    }\n    return r;\n  }\n  lll operator+(const lll &r) const { return lll(*this) += r; }\n  lll operator-(const lll &r) const { return lll(*this) -= r; }\n  lll operator*(ll r) const { return lll(*this) *= r; }\n  lll operator*(const lll &r) const { return lll(*this) *= r; }\n  lll &operator/=(ll r) {\n    if(r < 0) { sign *= -1, r = -r; }\n    ll c = 0, t = 0;\n    for(ll i = size() - 1; i >= 0; i--) {\n      t = lll::BASE * c + (*this)[i];\n      (*this)[i] = t / r;\n      c = t % r;\n    }\n    this->normalize();\n    return (*this);\n  }\n  ll operator%=(ll r) {\n    if(r < 0) { sign *= -1, r = -r; }\n    ll c = 0, t = 0;\n    for(ll i = size() - 1; i >= 0; i--) {\n      t = lll::BASE * c + (*this)[i];\n      (*this)[i] = t / r;\n      c = t % r;\n    }\n    return c;\n  }\n  lll operator/(ll r) const { return lll(*this) /= r; }\n  ll operator%(ll r) const { return lll(*this) %= r; }\n  friend pair<lll, lll> divmod(const lll &a, const lll &r) {\n    lll zero = 0, s = 0, t = 0;\n    if(abs(a) < abs(r)) { return {zero, a}; }\n    lll ar = abs(r);\n    s.resize(a.size()), t.resize(r.size());\n    ll tx = a.size() - 1;\n    for(; tx >= 0; --tx) {\n      if(a[tx] > 0) { break; }\n    }\n    for(ll i = tx; i >= 0; i--) {\n      t = t * lll::BASE + a[i];\n      ll lo = 0, hi = lll::BASE;\n      if(t >= ar) {\n        while(hi - lo > 1) {\n          ll mid = (hi + lo) / 2;\n          if(ar * mid > t) hi = mid;\n          else lo = mid;\n        }\n        t -= ar * lo;\n      }\n      s[i] = lo;\n    }\n    if(a.sign == r.sign) { s.sign = 1, t.sign = 1; }\n    else { s.sign = -1, t.sign = 1; }\n    return make_pair(s.normalize(), t.normalize());\n  }\n  lll operator/(const lll &r) const { return divmod((*this), r).first; }\n  lll operator%(const lll &r) const { return divmod((*this), r).second; }\n  lll &operator/=(const lll &r) { return (*this) = (*this) / r; }\n  lll &operator%=(const lll &r) { return (*this) = (*this) % r; }\n  friend bool operator<(const lll &x, const lll &y) {\n    if(x.sign < y.sign) { return true; }\n    else if(x.sign > y.sign) { return false; }\n    else {\n      ll tx = x.size() - 1, ty = y.size() - 1;\n      for(tx = x.size() - 1; tx >= 0; --tx) {\n        if(x[tx] > 0) { break; }\n      }\n      for(ty = y.size() - 1; ty >= 0; --ty) {\n        if(y[ty] > 0) { break; }\n      }\n      if(tx < ty) { return true; }\n      else if(tx > ty) { return false; }\n      else if(x.sign == 1) {\n        for(ll i = tx; i >= 0; i--) {\n          if(x[i] != y[i]) { return x[i] < y[i]; }\n        }\n        return false;\n      }\n      else {\n        for(ll i = tx; i >= 0; i--) {\n          if(x[i] != y[i]) { return x[i] > y[i]; }\n        }\n        return false;\n      }\n    }\n  }\n  friend bool operator>(const lll &x, const lll &y) { return y < x; }\n  friend bool operator<=(const lll &x, const lll &y) { return !(x > y); }\n  friend bool operator>=(const lll &x, const lll &y) { return !(x < y); }\n  friend bool operator==(const lll &x, const lll &y) {\n    if(x.sign != y.sign) { return 0; }\n    ll tx = (ll)x.size() - 1, ty = (ll)y.size() - 1;\n    for(tx = x.size() - 1; tx >= 0; --tx) {\n      if(x[tx] > 0) { break; }\n    }\n    for(ty = y.size() - 1; ty >= 0; --ty) {\n      if(y[ty] > 0) { break; }\n    }\n    if(tx != ty) { return false; }\n    for(ll i = tx; i >= 0; i--) {\n      if(x[i] != y[i]) { return false; }\n    }\n    return true;\n  }\n  friend bool operator!=(const lll &x, const lll &y) { return !(x == y); }\n};\n\nlll tolll(const string &is) {\n  string s = is;\n  if(s[0] == '-') { s = s.substr(1); }\n  while(s.size() % lll::BASE_D != 0) s = \"0\" + s;\n  ll N = s.size();\n  lll res(N / lll::BASE_D, 0);\n  for(ll i = 0; i < (ll)s.size(); i++) {\n    res[(N - i - 1) / lll::BASE_D] *= 10;\n    res[(N - i - 1) / lll::BASE_D] += s[i] - '0';\n  }\n  if(is[0] == '-') { res.sign = -1; }\n  return res;\n}\nstring tostr(const lll &r) {\n  stringstream ss;\n  if(r.sign == -1) { ss << '-'; }\n  ll d = r.size() - 1;\n  for(; d >= 0; --d) {\n    if(r[d] > 0) { break; }\n  }\n  if(d == -1) { ss << 0; }\n  else { ss << r[d]; }\n  for(ll i = d - 1; i >= 0; i--) {\n    ss.width(lll::BASE_D);\n    ss.fill('0');\n    ss << r[i];\n  }\n  return ss.str();\n}\n\nistream &operator>>(istream &is, lll &x) {\n  string s;\n  is >> s;\n  x = tolll(s);\n  return is;\n}\nostream &operator<<(ostream &os, const lll &x) {\n  if(x.sign == -1) { os << '-'; }\n  ll d = x.size() - 1;\n  for(d = x.size() - 1; d >= 0; --d) {\n    if(x[d] > 0) { break; }\n  }\n  if(d == -1) { os << 0; }\n  else { os << x[d]; }\n  for(ll i = d - 1; i >= 0; i--) {\n    os.width(lll::BASE_D);\n    os.fill('0');\n    os << x[i];\n  }\n  return os;\n}"
  },
  // "Rotate": {
  //   "prefix": "Rotate",
  //   "body": "auto rotate = [&N]<typeName T>(vector<vector<T>> &v) {\n  vector<vector<T>> u(N, vector<T>(N));\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) { u[j][N - 1 - i] = v[i][j]; }\n  }\n  v = u;\n  return;\n};"
  // },
  "rotate": {
    "prefix": "rotate",
    "body": "rotate($0);"
  },
  // "ImplicitTreap": {
  //   "prefix": "ImplicitTreap",
  //   "body": "template<typename T0, typename T1> struct ImplicitTreap {\n private:\n  virtual T0 f0(T0, T0) = 0;\n  const T0 u0;\n  virtual T1 f1(T1, T1) = 0;\n  const T1 u1;\n  virtual T0 g(T0, T1) = 0;\n  virtual T1 p(T1, int) = 0;\n  struct xorshift {\n    uint64_t x;\n    xorshift() {\n      mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n      x = rnd();\n      for(int i = 0; i < 100; i++) { random(); }\n    }\n    uint64_t random() {\n      x = x ^ (x << 7);\n      return x = x ^ (x >> 9);\n    }\n  } rnd;\n  struct Node {\n    T0 value, acc;\n    T1 lazy;\n    int priority, cnt;\n    bool rev;\n    Node *l, *r;\n    Node(T0 value_, int priority_, T0 u0_, T1 u1_): value(value_), acc(u0_), lazy(u1_), priority(priority_), cnt(1), rev(false), l(nullptr), r(nullptr) {}\n  } *root = nullptr;\n  using Tree = Node *;\n  int cnt(Tree t) { return t ? t->cnt : 0; }\n  T0 acc(Tree t) { return t ? t->acc : u0; }\n  void update_cnt(Tree t) {\n    if(t) { t->cnt = 1 + cnt(t->l) + cnt(t->r); }\n  }\n  void update_acc(Tree t) {\n    if(t) { t->acc = f0(acc(t->l), f0(t->value, acc(t->r))); }\n  }\n  void pushup(Tree t) { update_cnt(t), update_acc(t); }\n  void pushdown(Tree t) {\n    if(t && t->rev) {\n      t->rev = false;\n      swap(t->l, t->r);\n      if(t->l) { t->l->rev ^= 1; }\n      if(t->r) { t->r->rev ^= 1; }\n    }\n    if(t && t->lazy != u1) {\n      if(t->l) {\n        t->l->lazy = f1(t->l->lazy, t->lazy);\n        t->l->acc = g(t->l->acc, p(t->lazy, cnt(t->l)));\n      }\n      if(t->r) {\n        t->r->lazy = f1(t->r->lazy, t->lazy);\n        t->r->acc = g(t->r->acc, p(t->lazy, cnt(t->r)));\n      }\n      t->value = g(t->value, p(t->lazy, 1));\n      t->lazy = u1;\n    }\n    pushup(t);\n  }\n  void split(Tree t, int key, Tree &l, Tree &r) {\n    if(!t) {\n      l = r = nullptr;\n      return;\n    }\n    pushdown(t);\n    int implicit_key = cnt(t->l) + 1;\n    if(key < implicit_key) { split(t->l, key, l, t->l), r = t; }\n    else { split(t->r, key - implicit_key, t->r, r), l = t; }\n    pushup(t);\n  }\n  void insert(Tree &t, int key, Tree item) {\n    Tree t1, t2;\n    split(t, key, t1, t2);\n    merge(t1, t1, item);\n    merge(t, t1, t2);\n  }\n  void merge(Tree &t, Tree l, Tree r) {\n    pushdown(l);\n    pushdown(r);\n    if(!l || !r) { t = l ? l : r; }\n    else if(l->priority > r->priority) { merge(l->r, l->r, r), t = l; }\n    else { merge(r->l, l, r->l), t = r; }\n    pushup(t);\n  }\n  void erase(Tree &t, int key) {\n    Tree t1, t2, t3;\n    split(t, key + 1, t1, t2);\n    split(t1, key, t1, t3);\n    merge(t, t1, t2);\n  }\n  void update(Tree t, int l, int r, T1 x) {\n    if(l >= r) return;\n    Tree t1, t2, t3;\n    split(t, l, t1, t2);\n    split(t2, r - l, t2, t3);\n    t2->lazy = f1(t2->lazy, x);\n    t2->acc = g(t2->acc, p(x, cnt(t2)));\n    merge(t2, t2, t3);\n    merge(t, t1, t2);\n  }\n  T0 query(Tree t, int l, int r) {\n    if(l == r) return u0;\n    Tree t1, t2, t3;\n    split(t, l, t1, t2);\n    split(t2, r - l, t2, t3);\n    T0 ret = t2->acc;\n    merge(t2, t2, t3);\n    merge(t, t1, t2);\n    return ret;\n  }\n  int find(Tree t, T0 x, int offset, bool left = true) {\n    if(f0(t->acc, x) == x) { return -1; }\n    else {\n      if(left) {\n        if(t->l && f0(t->l->acc, x) != x) { return find(t->l, x, offset, left); }\n        else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->r, x, offset + cnt(t->l) + 1, left); }\n      }\n      else {\n        if(t->r && f0(t->r->acc, x) != x) { return find(t->r, x, offset + cnt(t->l) + 1, left); }\n        else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->l, x, offset, left); }\n      }\n    }\n  }\n  void reverse(Tree t, int l, int r) {\n    if(l > r) { return; }\n    Tree t1, t2, t3;\n    split(t, l, t1, t2);\n    split(t2, r - l, t2, t3);\n    t2->rev ^= 1;\n    merge(t2, t2, t3);\n    merge(t, t1, t2);\n  }\n  void rotate(Tree t, int l, int m, int r) {\n    reverse(t, l, r);\n    reverse(t, l, l + r - m);\n    reverse(t, l + r - m, r);\n  }\n  void dump(Tree t) {\n    if(!t) return;\n    pushdown(t);\n    dump(t->l);\n    cout << t->value << \" \";\n    dump(t->r);\n  }\n\n public:\n  ImplicitTreap(T0 u0_, T1 u1_): u0(u0_), u1(u1_) {}\n  void set_by_vector(const vector<T0> &a) {\n    for(int i = 0; i < a.size(); i++) {\n      insert(i, a[i]);\n    }\n  }\n  int size() { return cnt(root); }\n  void insert(int pos, T0 x) { insert(root, pos, new Node(x, rnd.random(), u0, u1)); }\n  void update(int l, int r, T1 x) { update(root, l, r, x); }\n  T0 query(int l, int r) { return query(root, l, r); }\n  int binary_search(int l, int r, T0 x, bool left = true) {\n    if(l >= r) return -1;\n    Tree t1, t2, t3;\n    split(root, l, t1, t2);\n    split(t2, r - l, t2, t3);\n    int ret = find(t2, x, l, left);\n    merge(t2, t2, t3);\n    merge(root, t1, t2);\n    return ret;\n  }\n  void erase(int pos) { erase(root, pos); }\n  void reverse(int l, int r) { reverse(root, l, r); }\n  void rotate(int l, int m, int r) { rotate(root, l, m, r); }\n  void dump() {\n    dump(root);\n    cout << endl;\n  }\n  T0 operator[](int pos) { return query(pos, pos + 1); }\n};\n\n// int  size() : O(1)\n// void insert(int pos, T0 x)       : 先頭から pos の位置 (pos == 0 なら先頭)に x を挿入 O(logn)\n// void update(int l, int r, T1 x)  : [l,r) に x を作用　O(logn)\n// T0   query(int l, int r)         : [l,r) の累積 O(logn)\n// void erase(int pos)              : 位置 pos を削除 O(logn)\n// void reverse(int l, int r)       : [l,r) を反転 O(logn)\n// void rotate(int l, int m, int r) : [l,r) の先頭が m になるよう回転\n// T0   operator[]                  : ランダムアクセス O(logn)\n// void dump()                      : 配列の中身を print (for debug)\n// int  binary_search(int l, int r, T0 x, bool left = true) :\n//  k∈[l, r) で f0(tr[k], x) != x となる最左/右のもの。存在しない場合は-1 O(logn)\n//  ex) MinMonoidの場合、x未満の最左/最右の要素の位置を返す"
  // },
  "ImplicitTreap_Update_Min": {
    "prefix": "ImplicitTreap_Update_Min",
    "body": "template<typename T0, typename T1> struct UpdateMinQuery : public ImplicitTreap<T0, T1> {\n  using ImplicitTreap<T0, T1>::ImplicitTreap;\n  UpdateMinQuery(): UpdateMinQuery(numeric_limits<T0>::max(), numeric_limits<T1>::min()) {}\n  T0 f0(T0 x, T0 y) override { return min(x, y); }\n  T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }\n  T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }\n  T1 p(T1 x, int len) override { return x; }\n};"
  },
  "ImplicitTreap_Add_Sum": {
    "prefix": "ImplicitTreap_Add_Sum",
    "body": "template<typename T0, typename T1> struct AddSumQuery : public ImplicitTreap<T0, T1> {\n  using ImplicitTreap<T0, T1>::ImplicitTreap;\n  AddSumQuery(): AddSumQuery(0, 0) {}\n  T0 f0(T0 x, T0 y) override { return x + y; }\n  T1 f1(T1 x, T1 y) override { return x + y; }\n  T0 g(T0 x, T1 y) override { return x + y; }\n  T1 p(T1 x, int len) override { return x * len; }\n};"
  },
  "ImplicitTreap_Add_Min": {
    "prefix": "ImplicitTreap_Add_Min",
    "body": "template<typename T0, typename T1> struct AddMinQuery : public ImplicitTreap<T0, T1> {\n  using ImplicitTreap<T0, T1>::ImplicitTreap;\n  AddMinQuery(): AddMinQuery(numeric_limits<T0>::max(), 0) {}\n  T0 f0(T0 x, T0 y) override { return min(x, y); }\n  T1 f1(T1 x, T1 y) override { return x + y; }\n  T0 g(T0 x, T1 y) override { return x + y; }\n  T1 p(T1 x, int len) override { return x; }\n};"
  },
  "ImplicitTreap_Update_Sum": {
    "prefix": "ImplicitTreap_Update_Sum",
    "body": "template<typename T0, typename T1> struct UpdateSumQuery : public ImplicitTreap<T0, T1> {\n  using ImplicitTreap<T0, T1>::ImplicitTreap;\n  UpdateSumQuery(): UpdateSumQuery(0, numeric_limits<T1>::min()) {}\n  T0 f0(T0 x, T0 y) override { return x + y; }\n  T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }\n  T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }\n  T1 p(T1 x, int len) override { return x == numeric_limits<T1>::min() ? numeric_limits<T1>::min() : x * len; }\n};"
  },
  "ImplicitTreap_Affine_Sum": {
    "prefix": "ImplicitTreap_Affine_Sum",
    "body": "template<typename T0> struct AffineSumQuery : public ImplicitTreap<T0, pair<T0, T0>> {\n  using T1 = pair<T0, T0>;  // first * x + second\n  using ImplicitTreap<T0, T1>::ImplicitTreap;\n  AffineSumQuery(): AffineSumQuery(0, {1, 0}) {}\n  T0 f0(T0 x, T0 y) override { return x + y; }\n  T1 f1(T1 x, T1 y) override { return {x.first * y.first, x.second * y.first + y.second}; }\n  T0 g(T0 x, T1 y) override { return y.first * x + y.second; }\n  T1 p(T1 x, int len) override { return {x.first, x.second * len}; }\n  // update(i, j, {a, b}); // [i, j)にax + bを作用\n  // update(i, j, {0, a}); // update\n  // update(i, j, {1, a}); // 加算\n  // update(i, j, {a, 0}); // 倍\n};"
  },
  "ImplicitTreap_Affine_MinMax": {
    "prefix": "ImplicitTreap_Affine_MinMax",
    "body": "template<typename T> struct AffineMinMaxQuery : public ImplicitTreap<pair<T, T>, pair<T, T>> {\n  using T0 = pair<T, T>;  // {min, max}\n  using T1 = pair<T, T>;  // first * x + second\n  using ImplicitTreap<T0, T1>::ImplicitTreap;\n  AffineMinMaxQuery(): AffineMinMaxQuery({numeric_limits<T>::max(), -numeric_limits<T>::max()}, {1, 0}) {\n  }\n  T0 f0(T0 x, T0 y) override { return {min(x.first, y.first), max(x.second, y.second)}; }\n  T1 f1(T1 x, T1 y) override { return {x.first * y.first, x.second * y.first + y.second}; }\n  T0 g(T0 x, T1 y) override {\n    T0 ret = {x.first * y.first + y.second, x.second * y.first + y.second};\n    if(y.first < 0) swap(ret.first, ret.second);\n    return ret;\n  }\n  T1 p(T1 x, int len) override { return x; }\n  // update(i, j, {a, b}); // [i, j)にax + bを作用\n  // update(i, j, {0, a}); // update\n  // update(i, j, {1, a}); // 加算\n  // update(i, j, {a, 0}); // 倍\n};"
  },
  // "PrioritySum_multi": {
  //   "prefix": "PrioritySum_multi",
  //   "body": "using T = pair<ll, ll>;\nT op(T l, T r) { return {l.first + r.first, l.second + r.second}; }\nT e() { return {0, 0}; }\nll tar;\nbool F(T x) { return tar > x.second; }\n\nstruct PrioritySum {\n  int n;\n  segtree<T, op, e> seg;\n  vector<ll> s;\n  PrioritySum() {}\n  void use(ll x) { s.emplace_back(x); }\n  void build() {\n    ranges::sort(s);\n    s.erase(unique(s.begin(), s.end()), s.end());\n    n = s.size();\n    seg = segtree<T, op, e>(n);\n  }\n  void insert(ll x, ll c = 1) {\n    int idx = ranges::lower_bound(s, x) - s.begin();\n    auto [sum, cnt] = seg.get(idx);\n    seg.set(idx, {sum + x * c, cnt + c});\n  }\n  void erase(ll x, ll c = 1) { insert(x, -c); }\n  ll min(int k) const {\n    if(!k) { return 0; }\n    tar = k;\n    int idx = seg.max_right<F>(0);\n    auto [sum, cnt] = seg.prod(0, idx);\n    sum += s[idx] * (k - cnt);\n    return sum;\n  }\n  ll max(int k) const {\n    if(!k) { return 0; }\n    tar = k;\n    int idx = seg.min_left<F>(n) - 1;\n    auto [sum, cnt] = seg.prod(idx, n);\n    sum -= s[idx] * (cnt - k);\n    return sum;\n  }\n} s;"
  // },
  "PairQuery": {
    "prefix": "_PairQuery",
    "body": "template<typename T0, typename T1> struct ImplicitTreap {\n private:\n  virtual T0 f0(T0, T0) = 0;\n  const T0 u0;\n  virtual T1 f1(T1, T1) = 0;\n  const T1 u1;\n  virtual T0 g(T0, T1) = 0;\n  virtual T1 p(T1, int) = 0;\n  struct xorshift {\n    uint64_t x;\n    xorshift() {\n      mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n      x = rnd();\n      for(int i = 0; i < 100; i++) { random(); }\n    }\n    uint64_t random() {\n      x = x ^ (x << 7);\n      return x = x ^ (x >> 9);\n    }\n  } rnd;\n  struct Node {\n    T0 value, acc;\n    T1 lazy;\n    int priority, cnt;\n    bool rev;\n    Node *l, *r;\n    Node(T0 value_, int priority_, T0 u0_, T1 u1_): value(value_), acc(u0_), lazy(u1_), priority(priority_), cnt(1), rev(false), l(nullptr), r(nullptr) {}\n  } *root = nullptr;\n  using Tree = Node *;\n  int cnt(Tree t) { return t ? t->cnt : 0; }\n  T0 acc(Tree t) { return t ? t->acc : u0; }\n  void update_cnt(Tree t) {\n    if(t) { t->cnt = 1 + cnt(t->l) + cnt(t->r); }\n  }\n  void update_acc(Tree t) {\n    if(t) { t->acc = f0(acc(t->l), f0(t->value, acc(t->r))); }\n  }\n  void pushup(Tree t) { update_cnt(t), update_acc(t); }\n  void pushdown(Tree t) {\n    if(t && t->rev) {\n      t->rev = false;\n      swap(t->l, t->r);\n      if(t->l) { t->l->rev ^= 1; }\n      if(t->r) { t->r->rev ^= 1; }\n    }\n    if(t && t->lazy != u1) {\n      if(t->l) {\n        t->l->lazy = f1(t->l->lazy, t->lazy);\n        t->l->acc = g(t->l->acc, p(t->lazy, cnt(t->l)));\n      }\n      if(t->r) {\n        t->r->lazy = f1(t->r->lazy, t->lazy);\n        t->r->acc = g(t->r->acc, p(t->lazy, cnt(t->r)));\n      }\n      t->value = g(t->value, p(t->lazy, 1));\n      t->lazy = u1;\n    }\n    pushup(t);\n  }\n  void split(Tree t, int key, Tree &l, Tree &r) {\n    if(!t) {\n      l = r = nullptr;\n      return;\n    }\n    pushdown(t);\n    int implicit_key = cnt(t->l) + 1;\n    if(key < implicit_key) { split(t->l, key, l, t->l), r = t; }\n    else { split(t->r, key - implicit_key, t->r, r), l = t; }\n    pushup(t);\n  }\n  void insert(Tree &t, int key, Tree item) {\n    Tree t1, t2;\n    split(t, key, t1, t2);\n    merge(t1, t1, item);\n    merge(t, t1, t2);\n  }\n  void merge(Tree &t, Tree l, Tree r) {\n    pushdown(l);\n    pushdown(r);\n    if(!l || !r) { t = l ? l : r; }\n    else if(l->priority > r->priority) { merge(l->r, l->r, r), t = l; }\n    else { merge(r->l, l, r->l), t = r; }\n    pushup(t);\n  }\n  void erase(Tree &t, int key) {\n    Tree t1, t2, t3;\n    split(t, key + 1, t1, t2);\n    split(t1, key, t1, t3);\n    merge(t, t1, t2);\n  }\n  void update(Tree t, int l, int r, T1 x) {\n    if(l >= r) return;\n    Tree t1, t2, t3;\n    split(t, l, t1, t2);\n    split(t2, r - l, t2, t3);\n    t2->lazy = f1(t2->lazy, x);\n    t2->acc = g(t2->acc, p(x, cnt(t2)));\n    merge(t2, t2, t3);\n    merge(t, t1, t2);\n  }\n  T0 query(Tree t, int l, int r) {\n    if(l == r) return u0;\n    Tree t1, t2, t3;\n    split(t, l, t1, t2);\n    split(t2, r - l, t2, t3);\n    T0 ret = t2->acc;\n    merge(t2, t2, t3);\n    merge(t, t1, t2);\n    return ret;\n  }\n  int find(Tree t, T0 x, int offset, bool left = true) {\n    if(f0(t->acc, x) == x) { return -1; }\n    else {\n      if(left) {\n        if(t->l && f0(t->l->acc, x) != x) { return find(t->l, x, offset, left); }\n        else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->r, x, offset + cnt(t->l) + 1, left); }\n      }\n      else {\n        if(t->r && f0(t->r->acc, x) != x) { return find(t->r, x, offset + cnt(t->l) + 1, left); }\n        else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->l, x, offset, left); }\n      }\n    }\n  }\n  void reverse(Tree t, int l, int r) {\n    if(l > r) { return; }\n    Tree t1, t2, t3;\n    split(t, l, t1, t2);\n    split(t2, r - l, t2, t3);\n    t2->rev ^= 1;\n    merge(t2, t2, t3);\n    merge(t, t1, t2);\n  }\n  void rotate(Tree t, int l, int m, int r) {\n    reverse(t, l, r);\n    reverse(t, l, l + r - m);\n    reverse(t, l + r - m, r);\n  }\n  void dump(Tree t) {\n    if(!t) return;\n    pushdown(t);\n    dump(t->l);\n    cout << t->value << \" \";\n    dump(t->r);\n  }\n\n public:\n  ImplicitTreap(T0 u0_, T1 u1_): u0(u0_), u1(u1_) {}\n  void set_by_vector(const vector<T0> &a) {\n    for(int i = 0; i < a.size(); i++) {\n      insert(i, a[i]);\n    }\n  }\n  int size() { return cnt(root); }\n  void insert(int pos, T0 x) { insert(root, pos, new Node(x, rnd.random(), u0, u1)); }\n  void update(int l, int r, T1 x) { update(root, l, r, x); }\n  T0 query(int l, int r) { return query(root, l, r); }\n  int binary_search(int l, int r, T0 x, bool left = true) {\n    if(l >= r) return -1;\n    Tree t1, t2, t3;\n    split(root, l, t1, t2);\n    split(t2, r - l, t2, t3);\n    int ret = find(t2, x, l, left);\n    merge(t2, t2, t3);\n    merge(root, t1, t2);\n    return ret;\n  }\n  void erase(int pos) { erase(root, pos); }\n  void reverse(int l, int r) { reverse(root, l, r); }\n  void rotate(int l, int m, int r) { rotate(root, l, m, r); }\n  void dump() {\n    dump(root);\n    cout << endl;\n  }\n  T0 operator[](int pos) { return query(pos, pos + 1); }\n};\n\ntemplate<typename T0, typename T1> struct UpdateSumQuery : public ImplicitTreap<T0, T1> {\n  using ImplicitTreap<T0, T1>::ImplicitTreap;\n  UpdateSumQuery(): UpdateSumQuery(0, numeric_limits<T1>::min()) {}\n  T0 f0(T0 x, T0 y) override { return x + y; }\n  T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }\n  T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }\n  T1 p(T1 x, int len) override { return x == numeric_limits<T1>::min() ? numeric_limits<T1>::min() : x * len; }\n};\n\ntemplate<typename T0, typename T1> struct UpdateMinQuery : public ImplicitTreap<T0, T1> {\n  using ImplicitTreap<T0, T1>::ImplicitTreap;\n  UpdateMinQuery(): UpdateMinQuery(numeric_limits<T0>::max(), numeric_limits<T1>::min()) {}\n  T0 f0(T0 x, T0 y) override { return min(x, y); }\n  T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }\n  T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }\n  T1 p(T1 x, int len) override { return x; }\n};\n\nnamespace std {\ntemplate<typename T0, typename T1> class numeric_limits<pair<T0, T1>>\n{\n public:\n  static constexpr pair<T0, T1> min() { return {numeric_limits<T0>::min(), numeric_limits<T1>::min()}; }\n  static constexpr pair<T0, T1> max() { return {numeric_limits<T0>::max(), numeric_limits<T1>::max()}; }\n};\n}  // namespace std\n\ntemplate<typename T0, typename T1, bool ascending = true> struct PairQuery {\n  UpdateSumQuery<T1, T1> tr;\n  UpdateMinQuery<pair<T0, T1>, pair<T0, T1>> tr2;\n  int cnt = 0;\n  void insert(const pair<T0, T1> &a) {\n    int p = tr2.binary_search(0, tr2.size(), a, !ascending);\n    if(ascending) {\n      tr.insert(p + 1, a.second);\n      tr2.insert(p + 1, a);\n    }\n    else {\n      if(p == -1) {\n        tr.insert(tr.size(), a.second);\n        tr2.insert(tr2.size(), a);\n      }\n      else {\n        tr.insert(p, a.second);\n        tr2.insert(p, a);\n      }\n    }\n    cnt++;\n  }\n  // 第一要素がxのものとxより左側のものに対し第二要素の累積を返す\n  T1 query(T0 x) {\n    if(ascending) {\n      int p = tr2.binary_search(0, tr2.size(), {x, numeric_limits<T1>::max()}, false);\n      p++;\n      return tr.query(0, p);\n    }\n    else {\n      int p = tr2.binary_search(0, tr2.size(), {x, numeric_limits<T1>::min()});\n      if(p == -1) p = cnt;\n      return tr.query(0, p);\n    }\n  }\n  void erase_at(int k) {\n    assert(0 <= k && k < cnt);\n    tr.erase(k);\n    tr2.erase(k);\n    cnt--;\n  }\n  void erase(const pair<T0, T1> &a) {\n    int p = tr2.binary_search(0, tr2.size(), a, !ascending);\n    if(ascending) { p++; }\n    else {\n      if(p == -1) p = cnt;\n      p--;\n    }\n    assert(0 <= p && p < cnt && tr2[p] == a);\n    erase_at(p);\n  }\n  int size() const { return cnt; }\n  T1 sum(int k) { return tr.query(0, k); }\n  pair<T0, T1> operator[](int k) { return tr2[k]; }\n  void dump() { tr2.dump(); }\n  T1 operator()(int k) { return sum(k); }\n};\n\ntemplate<typename T> using MaxSum = PairQuery<T, T, false>;\ntemplate<typename T> using MinSum = PairQuery<T, T, true>;"
  },
  "array": {
    "prefix": "array",
    "body": "array<ll,$1>$0"
  },
  "va": {
    "prefix": "va",
    "body": "vector<array<ll,$1>>$0"
  },
  // "GcdCount": {
  //   "prefix": "GcdCount",
  //   "body": "bool is_prime(ll N) {\n  if(N == 2 || N == 3 || N == 5 || N == 7) { return true; }\n  if(N % 2 == 0 || N % 3 == 0 || N % 5 == 0 || N % 7 == 0) { return false; }\n  if(N < 121) { return N > 1; }\n  ll d = (N - 1) >> __builtin_ctzll(N - 1);\n  ll p = 1, m = N - 1;\n  auto internal_pow = [&](ll x, ll n) -> __uint128_t {\n    __uint128_t r;\n    x %= N;\n    if(n == 0) { return 1; }\n    r = 1;\n    __uint128_t c = x;\n    for(; n; n >>= 1, c = (c * c) % N) {\n      if(n & 1) { r = r * c % N; }\n    }\n    return r;\n  };\n  auto ok = [&](ll a) {\n    auto y = internal_pow(a, d);\n    ll t = d;\n    for(; y != p && y != m && t != N - 1; t <<= 1) { y = y * y % N; }\n    if(y != m && t % 2 == 0) { return false; }\n    return true;\n  };\n  if(N < (1ll << 32)) {\n    for(ll a : {2, 7, 61}) {\n      if(!ok(a)) { return false; }\n    }\n  }\n  else {\n    for(ll a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {\n      if(N <= a) { return true; }\n      if(!ok(a)) { return false; }\n    }\n  }\n  return true;\n}\n\nll Rho(ll N) {\n  if(N % 2 == 0) { return 2; }\n  if(is_prime(N)) { return N; }\n  ll ds = [&]() -> ll {\n    ll n = ll(sqrt(N));\n    for(ll i = 0; i < 300; ++i) {\n      ll T = (n + i) * (n + i) - N;\n      ll t = ll(sqrt(T));\n      if(t * t == T) { return n + i - t; }\n    }\n    return 0;\n  }();\n  if(ds > 1) { return ds; }\n  auto f = [&](ll x) -> ll { return (__int128_t(x) * x + 1) % N; };\n  ll st = 0;\n  while(true) {\n    ++st;\n    ll x = st, y = f(x);\n    while(true) {\n      ll p = gcd(y - x + N, N);\n      if(p == 0 || p == N) { break; }\n      if(p != 1) { return p; }\n      x = f(x);\n      y = f(f(y));\n    }\n  }\n}\n\nvector<ll> PrimeFactorize(ll N) {\n  if(N == 1) { return {}; }\n  ll p = Rho(N);\n  if(p == N) { return {p}; }\n  vector<ll> l = PrimeFactorize(p), r = PrimeFactorize(N / p);\n  l.insert(l.end(), r.begin(), r.end());\n  ranges::sort(l);\n  return l;\n}\n\nvector<ll> Divisor(const vector<ll> &p) {\n  vector<vector<ll>> x(1, {1});\n  ll num = 1, idx = 0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    num *= p[i];\n    x[idx].emplace_back(num);\n    if(i != (int)p.size() - 1 && p[i + 1] != p[i]) {\n      x.push_back({1});\n      num = 1;\n      idx++;\n    }\n  }\n  ll l = 0, r = 1;\n  vector<ll> ret{1};\n  for(int i = 0; i < (int)x.size(); i++) {\n    for(auto &e : x[i]) {\n      for(int j = l; j < r; j++) { ret.emplace_back(ret[j] * e); }\n    }\n    l = r;\n    r = ret.size();\n  }\n  return vector<ll>(ret.begin() + l, ret.end());\n}\n\n// i∈[1,n] で gcd(i, k) == first となるものの個数/総和を求める\ntemplate<bool sum = false, typename T = ll> vector<pair<ll, T>> GcdCount(ll n, ll k) {\n  auto p = PrimeFactorize(k);\n  auto div = Divisor(p);\n  p.erase(unique(p.begin(), p.end()), p.end());\n  ll s = p.size();\n  vector<pair<ll, bool>> e;\n  for(ll i = 0; i < 1 << s; i++) {\n    ll t = 1;\n    bool odd = false;\n    for(ll j = 0; j < s; j++) {\n      if(i & 1 << j) {\n        t *= p[j];\n        odd = !odd;\n      }\n    }\n    e.emplace_back(t, odd);\n  }\n\n  vector<pair<ll, T>> ret;\n  for(auto &i : div) {\n    T r = 0, tmp;\n    ll K = k / i, N = n / i, cnt;\n    for(auto &[t, odd] : e) {\n      if(K % t) { continue; }\n      cnt = N / t;\n      if(!sum) { tmp = cnt; }\n      else { tmp = T(cnt + 1) * cnt * t * i / 2; }\n      r += odd ? -tmp : tmp;\n    }\n    ret.emplace_back(i, r);\n  }\n  return ret;\n}"
  // },
  "gcdcount": {
    "prefix": "gcdcount",
    "body": "GcdCount($1,$2)"
  },
  "bit": {
    "prefix": "bit",
    "body": "${1:i}>>${2:j}&1"
  },
  "nbit": {
    "prefix": "nbit",
    "body": "~${1:i}>>${2:j}&1"
  },
  // "PrimeEnum": {
  //   "prefix": "PrimeEnum",
  //   "body": "vector<ll> PrimeEnum(ll n) {\n  vector<bool> sieve(n / 3 + 1, true);\n  for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {\n    if(!sieve[i]) { continue; }\n    for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }\n  }\n  vector<ll> ret = {2, 3};\n  for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {\n    if(sieve[i]) { ret.emplace_back(p); }\n  }\n  while(!ret.empty() && ret.back() > n) { ret.pop_back(); }\n  return ret;\n}"
  // },
  "primeenum": {
    "prefix": "primeenum",
    "body": "PrimeEnum($1)"
  },
  // "DivisorTransform": {
  //   "prefix": "DivisorTransform",
  //   "body": "vector<ll> PrimeEnum(ll n) {\n  vector<bool> sieve(n / 3 + 1, true);\n  for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {\n    if(!sieve[i]) { continue; }\n    for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }\n  }\n  vector<ll> ret = {2, 3};\n  for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {\n    if(sieve[i]) { ret.emplace_back(p); }\n  }\n  while(!ret.empty() && ret.back() > n) { ret.pop_back(); }\n  return ret;\n}\n\nstruct DivisorTransform {\n  template<typename T> static void ZetaTransform(vector<T> &v) {\n    const int n = v.size() - 1;\n    for(auto &p : PrimeEnum(n)) {\n      for(ll i = 1; i * p <= n; i++) { v[i * p] += v[i]; }\n    }\n  }\n  template<typename T> static void MobiusTransform(vector<T> &v) {\n    const int n = v.size() - 1;\n    for(auto &p : PrimeEnum(n)) {\n      for(ll i = n / p; i > 0; i--) { v[i * p] -= v[i]; }\n    }\n  }\n  template<typename I, typename T> static void ZetaTransform(map<I, T> &m) {\n    for(auto p = m.rbegin(); p != m.rend(); p++) {\n      for(auto &x : m) {\n        if(p->first == x.first) { break; }\n        if(p->first % x.first == 0) { p->second += x.second; }\n      }\n    }\n  }\n  template<typename I, typename T> static void MobiusTransform(map<I, T> &m) {\n    for(auto &x : m) {\n      for(auto p = m.rbegin(); p != m.rend(); p++) {\n        if(x.first == p->first) { break; }\n        if(p->first % x.first == 0) { p->second -= x.second; }\n      }\n    }\n  }\n};"
  // },
  // "MultipleTransform": {
  //   "prefix": "MultipleTransform",
  //   "body": "vector<ll> PrimeEnum(ll n) {\n  vector<bool> sieve(n / 3 + 1, true);\n  for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {\n    if(!sieve[i]) { continue; }\n    for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }\n  }\n  vector<ll> ret = {2, 3};\n  for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {\n    if(sieve[i]) { ret.emplace_back(p); }\n  }\n  while(!ret.empty() && ret.back() > n) { ret.pop_back(); }\n  return ret;\n}\n\nstruct MultipleTransform {\n  template<typename T> static void ZetaTransform(vector<T> &v) {\n    const int n = v.size() - 1;\n    for(auto &p : PrimeEnum(n)) {\n      for(ll i = n / p; i > 0; i--) { v[i] += v[i * p]; }\n    }\n  }\n  template<typename T> static void MobiusTransform(vector<T> &v) {\n    const int n = v.size() - 1;\n    for(auto &p : PrimeEnum(n)) {\n      for(ll i = 1; i * p <= n; i++) { v[i] -= v[i * p]; }\n    }\n  }\n  template<typename I, typename T> static void ZetaTransform(map<I, T> &m) {\n    for(auto &x : m) {\n      for(auto p = m.rbegin(); p->first != x.first; p++) {\n        if(p->first % x.first == 0) { x.second += p->second; }\n      }\n    }\n  }\n  template<typename I, typename T> static void MobiusTransform(map<I, T> &m) {\n    for(auto p1 = m.rbegin(); p1 != m.rend(); p1++) {\n      for(auto p2 = m.rbegin(); p2 != p1; p2++) {\n        if(p2->first % p1->first == 0) { p1->second -= p2->second; }\n      }\n    }\n  }\n};"
  // },
  // "GcdConvolution": {
  //   "prefix": "GcdConvolution",
  //   "body": "vector<ll> PrimeEnum(ll n) {\n  vector<bool> sieve(n / 3 + 1, true);\n  for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {\n    if(!sieve[i]) { continue; }\n    for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }\n  }\n  vector<ll> ret = {2, 3};\n  for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {\n    if(sieve[i]) { ret.emplace_back(p); }\n  }\n  while(!ret.empty() && ret.back() > n) { ret.pop_back(); }\n  return ret;\n}\n\nstruct MultipleTransform {\n  template<typename T> static void ZetaTransform(vector<T> &v) {\n    const int n = v.size() - 1;\n    for(auto &p : PrimeEnum(n)) {\n      for(ll i = n / p; i > 0; i--) { v[i] += v[i * p]; }\n    }\n  }\n  template<typename T> static void MobiusTransform(vector<T> &v) {\n    const int n = v.size() - 1;\n    for(auto &p : PrimeEnum(n)) {\n      for(ll i = 1; i * p <= n; i++) { v[i] -= v[i * p]; }\n    }\n  }\n};\n\ntemplate<typename T> vector<T> GcdConvolution(const vector<T> &a, const vector<T> &b) {\n  assert(a.size() == b.size());\n  auto s = a, t = b;\n  MultipleTransform::ZetaTransform(s);\n  MultipleTransform::ZetaTransform(t);\n  for(int i = 0; i < (int)a.size(); i++) { s[i] *= t[i]; }\n  MultipleTransform::MobiusTransform(s);\n  return s;\n}"
  // },
  // "LcmConvolution": {
  //   "prefix": "LcmConvolution",
  //   "body": "vector<ll> PrimeEnum(ll n) {\n  vector<bool> sieve(n / 3 + 1, true);\n  for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {\n    if(!sieve[i]) { continue; }\n    for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }\n  }\n  vector<ll> ret = {2, 3};\n  for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {\n    if(sieve[i]) { ret.emplace_back(p); }\n  }\n  while(!ret.empty() && ret.back() > n) { ret.pop_back(); }\n  return ret;\n}\n\nstruct DivisorTransform {\n  template<typename T> static void ZetaTransform(vector<T> &v) {\n    const int n = v.size() - 1;\n    for(auto &p : PrimeEnum(n)) {\n      for(ll i = 1; i * p <= n; i++) { v[i * p] += v[i]; }\n    }\n  }\n  template<typename T> static void MobiusTransform(vector<T> &v) {\n    const int n = v.size() - 1;\n    for(auto &p : PrimeEnum(n)) {\n      for(ll i = n / p; i > 0; i--) { v[i * p] -= v[i]; }\n    }\n  }\n};\n\ntemplate<typename T> vector<T> LcmConvolution(const vector<T> &a, const vector<T> &b) {\n  assert(a.size() == b.size());\n  auto s = a, t = b;\n  DivisorTransform::ZetaTransform(s);\n  DivisorTransform::ZetaTransform(t);\n  for(int i = 0; i < (int)a.size(); i++) { s[i] *= t[i]; }\n  DivisorTransform::MobiusTransform(s);\n  return s;\n}"
  // },
  "chmax": {
    "prefix": "chmax",
    "body": "$1=max($1,$2);$0"
  },
  "chmin": {
    "prefix": "chmin",
    "body": "$1=min($1,$2);$0"
  },
  // "BinaryTreePathCount": {
  //   "prefix": "BinaryTreePathCount",
  //   "body": "vector<mint> BinaryTreePathCount(ll n) {\n  ll D = 63 - __builtin_clzll(n + 1), L = n - (1LL << D) + 1;\n  vector<mint> cnt(130), bin(130, 1);\n  for(ll i = 1; i < 130; i++) { bin[i] = bin[i-1] * 2; }\n  map<ll, mint> memo[65][130];\n  for(ll k = 0; k < 130; k++) {\n    auto calc = [&](auto &&calc, ll d, ll l) -> mint {\n      if(!d) { return 0; }\n      if(memo[d][k].contains(l)) { return memo[d][k][l]; }\n      mint r = 0;\n      if(k < d) {\n        r = bin[k];\n        if(k >= 2) { r += bin[k - 2] * (k - 1); }\n      }\n      else if(k >= 2) { r += bin[k - 2] * max(0LL, d * 2 - k - 1); }\n      ll t = 1LL << d - 1;\n      if(l >= t) {\n        r += calc(calc, d, 0) + calc(calc, d - 1, l - t);\n        if(k == d) { r += l; }\n        else if(k > d && k < d * 2) { r += l * bin[k - d - 1]; }\n        else if(k == d * 2) { r += mint(t) * (l - t); }\n      }\n      else {\n        r += calc(calc, d - 1, l) + calc(calc, d - 1, 0);\n        if(k == d) { r += l; }\n        else if(k > d && k < d * 2) { r += l * bin[k - d - 1]; }\n      }\n      return memo[d][k][l] = r;\n    };\n    cnt[k] = calc(calc, D, L);\n  }\n  return cnt;\n}"
  // },
  "binarytreepathcount": {
    "prefix": "binarytreepathcount",
    "body": "BinaryTreePathCount($1)"
  },
  "s1": {
    "prefix": "s1",
    "body": "string ${1:S}; cin>>${1:S};$0"
  },
  "s2": {
    "prefix": "s2",
    "body": "string ${1:s},${2:t}; cin>>${1:s}>>${2:t};$0"
  },
  "assign": {
    "prefix": "assign",
    "body": "assign($1,$2);$0"
  },
  "secsort": {
    "prefix": "secsort",
    "body": "ranges::sort($1, {}, &pair<ll, ll>::second);$0"
  },
  "Maxedge": {
    "prefix": "Maxedge",
    "body": "vector<vector<ll>> mx(n, vector<ll>(24, 0));\nauto DFS = [&](auto &&DFS, ll v, ll p, ll d) -> void {\n  mx[v][0] = d;\n  for(auto &[nv, w] : g[v]) {\n    if(nv == p) { continue; }\n    DFS(DFS, nv, v, w);\n  }\n};\nDFS(DFS, 0, -1, 0);\nfor(ll j = 0; j < 23; j++) {\n  for(ll i = 0; i < n; i++) {\n    ll nx = t.bl[i][j];\n    if(nx != -1) { mx[i][j + 1] = max(mx[i][j], mx[nx][j]); }\n  }\n}\nauto maxedge = [&](ll u, ll v) -> ll {\n  ll l = t.lca(u, v);\n  auto maxedge_lca = [&](ll v, ll l) {\n    ll d = t.depth(v) - t.depth(l), r = 0;\n    while(d) {\n      ll tmp = __builtin_ctz(d);\n      r = max(r, mx[v][tmp]);\n      v = t.bl[v][tmp];\n      d ^= 1 << tmp;\n    }\n    return r;\n  };\n  return max(maxedge_lca(v, l), maxedge_lca(u, l));\n};"
  },
  "maxedge": {
    "prefix": "maxedge",
    "body": "maxedge($1,$2)"
  },
  "Minedge": {
    "prefix": "Minedge",
    "body": "vector<vector<ll>> mn(n, vector<ll>(24, 0));\nauto DFS = [&](auto &&DFS, ll v, ll p, ll d) -> void {\n  mn[v][0] = d;\n  for(auto &[nv, w] : g[v]) {\n    if(nv == p) { continue; }\n    DFS(DFS, nv, v, w);\n  }\n};\nDFS(DFS, 0, -1, 0);\nfor(ll j = 0; j < 23; j++) {\n  for(ll i = 0; i < n; i++) {\n    ll nx = t.bl[i][j];\n    if(nx != -1) { mn[i][j + 1] = min(mn[i][j], mn[nx][j]); }\n  }\n}\nauto minedge = [&](ll u, ll v) -> ll {\n  ll l = t.lca(u, v);\n  auto minedge_lca = [&](ll v, ll l) {\n    ll d = t.depth(v) - t.depth(l), r = 1e18;\n    while(d) {\n      ll tmp = __builtin_ctz(d);\n      r = min(r, mn[v][tmp]);\n      v = t.bl[v][tmp];\n      d ^= 1 << tmp;\n    }\n    return r;\n  };\n  return min(minedge_lca(v, l), minedge_lca(u, l));\n};"
  },
  "minedge": {
    "prefix": "minedge",
    "body": "minedge($1,$2)"
  },
  "stable_sort": {
    "prefix": "stable_sort",
    "body": "ranges::stable_sort($1);$0"
  },
  "subset": {
    "prefix": "subset",
    "body": "for(ll j = i; j > 0; j = (j - 1) & i) {$1}$0"
  },
  "superset": {
    "prefix": "superset",
    "body": "for(ll j = i; j < 1 << n; j = (j + 1) | i){$1}$0"
  },
  // "SupersetTransform": {
  //   "prefix": "SupersetTransform",
  //   "body": "struct SupersetTransform {\n  template<typename T> static void ZetaTransform(vector<T> &v) {\n    const int n = v.size();\n    for(int i = 1; i < n; i <<= 1) {\n      for(int j = 0; j < n; j += i << 1) {\n        for(int k = 0; k < i; k++) { v[j + k] += v[j + k + i]; }\n      }\n    }\n  }\n  template<typename T> static void MobiusTransform(vector<T> &v) {\n    const int n = v.size();\n    for(int i = 1; i < n; i <<= 1) {\n      for(int j = 0; j < n; j += i << 1) {\n        for(int k = 0; k < i; k++) { v[j + k] -= v[j + k + i]; }\n      }\n    }\n  }\n};"
  // },
  // "AndConvolution": {
  //   "prefix": "AndConvolution",
  //   "body": "struct SupersetTransform {\n  template<typename T> static void ZetaTransform(vector<T> &v) {\n    const int n = v.size();\n    for(int i = 1; i < n; i <<= 1) {\n      for(int j = 0; j < n; j += i << 1) {\n        for(int k = 0; k < i; k++) { v[j + k] += v[j + k + i]; }\n      }\n    }\n  }\n  template<typename T> static void MobiusTransform(vector<T> &v) {\n    const int n = v.size();\n    for(int i = 1; i < n; i <<= 1) {\n      for(int j = 0; j < n; j += i << 1) {\n        for(int k = 0; k < i; k++) { v[j + k] -= v[j + k + i]; }\n      }\n    }\n  }\n};\n\ntemplate<typename T> vector<T> AndConvolution(vector<T> a, vector<T> b) {\n  const int n = a.size();\n  assert(a.size() == b.size());\n  assert(!(n & (n - 1)));\n  SupersetTransform::ZetaTransform(a);\n  SupersetTransform::ZetaTransform(b);\n  for(int i = 0; i < n; i++) { a[i] *= b[i]; }\n  SupersetTransform::MobiusTransform(a);\n  return a;\n}"
  // },
  // "SubsetTransform": {
  //   "prefix": "SubsetTransform",
  //   "body": "struct SubsetTransform {\n  template<typename T> static void ZetaTransform(vector<T> &v) {\n    const int n = v.size();\n    for(int i = 1; i < n; i <<= 1) {\n      for(int j = 0; j < n; j += i << 1) {\n        for(int k = 0; k < i; k++) { v[j + k + i] += v[j + k]; }\n      }\n    }\n  }\n  template<typename T> static void MobiusTransform(vector<T> &v) {\n    const int n = v.size();\n    for(int i = 1; i < n; i <<= 1) {\n      for(int j = 0; j < n; j += i << 1) {\n        for(int k = 0; k < i; k++) { v[j + k + i] -= v[j + k]; }\n      }\n    }\n  }\n};"
  // },
  // "OrConvolution": {
  //   "prefix": "OrConvolution",
  //   "body": "struct SubsetTransform {\n  template<typename T> static void ZetaTransform(vector<T> &v) {\n    const int n = v.size();\n    for(int i = 1; i < n; i <<= 1) {\n      for(int j = 0; j < n; j += i << 1) {\n        for(int k = 0; k < i; k++) { v[j + k + i] += v[j + k]; }\n      }\n    }\n  }\n  template<typename T> static void MobiusTransform(vector<T> &v) {\n    const int n = v.size();\n    for(int i = 1; i < n; i <<= 1) {\n      for(int j = 0; j < n; j += i << 1) {\n        for(int k = 0; k < i; k++) { v[j + k + i] -= v[j + k]; }\n      }\n    }\n  }\n};\n\ntemplate<typename T> vector<T> OrConvolution(vector<T> a, vector<T> b) {\n  const int n = a.size();\n  assert(a.size() == b.size());\n  assert(!(n & (n - 1)));\n  SubsetTransform::ZetaTransform(a);\n  SubsetTransform::ZetaTransform(b);\n  for(int i = 0; i < n; i++) { a[i] *= b[i]; }\n  SubsetTransform::MobiusTransform(a);\n  return a;\n}"
  // },
  // "WalshHadamardTransform": {
  //   "prefix": "WalshHadamardTransform",
  //   "body": "template<typename T> void WalshHadamardTransform(vector<T> &v, bool inv) {\n  const int n = v.size();\n  for(int i = 1; i < n; i <<= 1) {\n    for(int j = 0; j < n; j += i << 1) {\n      for(int k = 0; k < i; k++) {\n        T s = v[j + k], t = v[j + k + i];\n        v[j + k] = s + t;\n        v[j + k + i] = s - t;\n      }\n    }\n  }\n  if(inv) {\n    T inv_n = T(1) / n;\n    for(auto &x : v) { x *= inv_n; }\n  }\n}"
  // },
  // "XorConvolution": {
  //   "prefix": "XorConvolution",
  //   "body": "template<typename T> void WalshHadamardTransform(vector<T> &v, bool inv) {\n  const int n = v.size();\n  for(int i = 1; i < n; i <<= 1) {\n    for(int j = 0; j < n; j += i << 1) {\n      for(int k = 0; k < i; k++) {\n        T s = v[j + k], t = v[j + k + i];\n        v[j + k] = s + t;\n        v[j + k + i] = s - t;\n      }\n    }\n  }\n  if(inv) {\n    T inv_n = T(1) / n;\n    for(auto &x : v) { x *= inv_n; }\n  }\n}\n\ntemplate<typename T> vector<T> XorConvolution(vector<T> a, vector<T> b) {\n  const int n = a.size();\n  assert(a.size() == b.size());\n  assert(!(n & (n - 1)));\n  WalshHadamardTransform(a, false);\n  WalshHadamardTransform(b, false);\n  for(int i = 0; i < n; i++) { a[i] *= b[i]; }\n  WalshHadamardTransform(a, true);\n  return a;\n}"
  // },
  "mymin": {
    "prefix": "mymin",
    "body": "*ranges::min_element($1,[&](auto x,auto y){return $2;});$3 // condition to get x"
  },
  "CommonInterval": {
    "prefix": "CommonInterval",
    "body": "ll CommonInterval(pair<ll, ll> x, pair<ll, ll> y) { return max(min(x.second, y.second) - max(x.first, y.first) + 1, 0LL); }"
  },
  "LongestCommonInterval": {
    "prefix": "LongestCommonInterval",
    "body": "template<typename T> T LCI(vector<pair<T, T>> v) {\n  const int n = v.size();\n  ranges::sort(v);\n  T m = v[0].second, r = 0;\n  for(ll i = 1; i < n; i++) {\n    r = max(r, min(m, v[i].second) - v[i].first);\n    m = max(m, v[i].second);\n  }\n  return r;\n}"
  },
  "ShortestCommonInterval": {
    "prefix": "ShortestCommonInterval",
    "body": "template<typename T> vector<T> SCI(vector<pair<T, T>> &v) {\n  auto CI = [](pair<T, T> x, pair<T, T> y) { return max(min(x.second, y.second) - max(x.first, y.first) + 1, 0LL); };\n  pair<T, T> l, r, p;\n  l = *ranges::min_element(v, [&](auto x, auto y) { return x.first > y.first; });\n  r = *ranges::min_element(v, [&](auto x, auto y) { return x.second < y.second; });\n  p = *ranges::min_element(v, [&](auto x, auto y) { return x.second - x.first < y.second - y.first; });\n\n  vector<T> sci;\n  for(auto &i : v) { sci.emplace_back(min({CI(i, l), CI(i, r), CI(i, p)})); }\n  return sci;\n}"
  },
  "count_if": {
    "prefix": "count_if",
    "body": "ranges::count_if($1,[&](auto x){return $2;})"
  },
  // "MEX": {
  //   "prefix": "MEX",
  //   "body": "struct MEX {\n  set<pair<ll, ll>> s;\n  MEX() {\n    s.emplace(-1e18, -1e18);\n    s.emplace(1e18, 1e18);\n  }\n  bool contains(ll x) const {\n    auto it = prev(s.lower_bound({x + 1, x + 1}));\n    auto [l, r] = *it;\n    return l <= x && x <= r;\n  }\n  bool insert(ll x) {\n    auto nit = s.lower_bound({x + 1, x + 1}), it = prev(nit);\n    auto [l, r] = *it;\n    auto [nl, nr] = *nit;\n    if(l <= x && x <= r) { return false; }\n    if(r == x - 1) {\n      if(nl == x + 1) {\n        s.erase(it);\n        s.erase(nit);\n        s.emplace(l, nr);\n      }\n      else {\n        s.erase(it);\n        s.emplace(l, x);\n      }\n    }\n    else {\n      if(nl == x + 1) {\n        s.erase(nit);\n        s.emplace(x, nr);\n      }\n      else { s.emplace(x, x); }\n    }\n    return true;\n  }\n  void erase(ll x) {\n    auto it = prev(s.lower_bound({x + 1, x + 1}));\n    auto [l, r] = *it;\n    s.erase(it);\n    if(l != x) { s.emplace(l, x - 1); }\n    if(r != x) { s.emplace(x + 1, r); }\n  }\n  ll query(ll x = 0) const {\n    auto [l, r] = *prev(s.lower_bound({x + 1, x + 1}));\n    return l <= x && x <= r ? r + 1 : x;\n  }\n} mex;"
  // },
  // "SlopeTrick": {
  //   "prefix": "SlopeTrick",
  //   "body": "struct SlopeTrick {\n  ll min_f, add_l, add_r;\n  priority_queue<ll> L;\n  priority_queue<ll, vector<ll>, greater<ll>> R;\n\n private:\n  void push_R(const ll &a) { R.emplace(a - add_r); }\n  ll top_R() const { return R.empty() ? 1e18 : R.top() + add_r; }\n  ll pop_R() {\n    ll val = top_R();\n    if(!R.empty()) { R.pop(); }\n    return val;\n  }\n  void push_L(const ll &a) { L.emplace(a - add_l); }\n  ll top_L() const { return L.empty() ? -1e18 : L.top() + add_l; }\n  ll pop_L() {\n    ll val = top_L();\n    if(!L.empty()) { L.pop(); }\n    return val;\n  }\n  size_t size() { return L.size() + R.size(); }\n\n public:\n  SlopeTrick(): min_f(0), add_l(0), add_r(0) {}\n  struct Query {\n    ll lx, rx, min_f;\n  };\n  Query query() const { return (Query){top_L(), top_R(), min_f}; }\n  void add_all(const ll &a) { min_f += a; }\n  void add_a_x(const ll &a) {\n    min_f += max(0LL, a - top_R());\n    push_R(a);\n    push_L(pop_R());\n  }\n  void add_x_a(const ll &a) {\n    min_f += max(0LL, top_L() - a);\n    push_L(a);\n    push_R(pop_L());\n  }\n  void add_abs(const ll &a) {\n    add_a_x(a);\n    add_x_a(a);\n  }\n  void clear_right() {\n    while(!R.empty()) { R.pop(); }\n  }\n  void clear_left() {\n    while(!L.empty()) { L.pop(); }\n  }\n  void shift(const ll &a, const ll &b) {\n    assert(a <= b);\n    add_l += a;\n    add_r += b;\n  }\n  void shift(const ll &a) { shift(a, a); }\n  ll get(const ll &x) {\n    ll r = min_f;\n    while(!L.empty()) { r += max(0LL, pop_L() - x); }\n    while(!R.empty()) { r += max(0LL, x - pop_R()); }\n    return r;\n  }\n  void merge(SlopeTrick &st) {\n    if(st.size() > size()) {\n      swap(st.L, L);\n      swap(st.R, R);\n      swap(st.add_l, add_l);\n      swap(st.add_r, add_r);\n      swap(st.min_f, min_f);\n    }\n    while(!st.R.empty()) { add_x_a(st.pop_R()); }\n    while(!st.L.empty()) { add_a_x(st.pop_L()); }\n    min_f += st.min_f;\n  }\n}st;\n// https://ei1333.github.io/library/structure/others/slope-trick.hpp"
  // },
  "slopetrick": {
    "prefix": "slopetrick",
    "body": "SlopeTrick st;"
  },
  // "Root": {
  //   "prefix": "Root",
  //   "body": "uint64_t Root(uint64_t a, int k=2) {\n  if(a <= 1 || k == 1) { return a; }\n  if(k >= 64) { return 1; }\n  auto check = [&](__uint128_t n) {\n    __uint128_t x = 1, m = n;\n    for(ll p = k; p; p >>= 1, m *= m) {\n      if(p & 1) { x *= m; }\n    }\n    return x <= a;\n  };\n  uint64_t n = powl(a, (long double)(1.0) / k);\n  while(!check(n)) { --n; }\n  while(check(n + 1)) { ++n; }\n  return n;\n}"
  // },
  "root": {
    "prefix": "root",
    "body": "Root($1,$2)"
  },
  // "Interval": {
  //   "prefix": "Interval",
  //   "body": "struct Interval {\n  set<pair<ll, ll>> s;\n  ll cnt, inf = 8e18;\n  Interval(): cnt(0) {\n    s.emplace(-inf, -inf);\n    s.emplace(inf, inf);\n  }\n  bool contains(ll l, ll r) const {\n    assert(l <= r);\n    auto [L, R] = *prev(s.lower_bound({l + 1, l + 1}));\n    return L <= l && r <= R;\n  }\n  bool contains(ll x) const { return contains(x, x); }\n  pair<ll, ll> covered_by(ll l, ll r) const {\n    assert(l <= r);\n    auto [L, R] = *prev(s.lower_bound({l + 1, l + 1}));\n    if(L <= l && r <= R) { return {L, R}; }\n    return {-inf, -inf};\n  }\n  pair<ll, ll> covered_by(ll x) const { return covered_by(x, x); }\n  ll insert(ll l, ll r) {\n    assert(l <= r);\n    auto it = prev(s.lower_bound({l + 1, l + 1}));\n    if(it->first <= l && r <= it->second) { return 0; }\n    ll sum_erased = 0;\n    if(it->first <= l && l <= it->second + 1) {\n      l = it->first;\n      sum_erased += it->second - it->first + 1;\n      it = s.erase(it);\n    }\n    else it = next(it);\n    while(r > it->second) {\n      sum_erased += it->second - it->first + 1;\n      it = s.erase(it);\n    }\n    if(it->first - 1 <= r && r <= it->second) {\n      sum_erased += it->second - it->first + 1;\n      r = it->second;\n      s.erase(it);\n    }\n    s.emplace(l, r);\n    cnt += r - l + 1 - sum_erased;\n    return r - l + 1 - sum_erased;\n  }\n  ll insert(ll x) {\n    auto nit = s.lower_bound({x + 1, x + 1}), it = prev(nit);\n    auto [l, r] = *it;\n    auto [nl, nr] = *nit;\n    if(l <= x && x <= r) { return 0; }\n    if(r == x - 1) {\n      if(nl == x + 1) {\n        s.erase(it);\n        s.erase(nit);\n        s.emplace(l, nr);\n      }\n      else {\n        s.erase(it);\n        s.emplace(l, x);\n      }\n    }\n    else {\n      if(nl == x + 1) {\n        s.erase(nit);\n        s.emplace(x, nr);\n      }\n      else { s.emplace(x, x); }\n    }\n    cnt++;\n    return 1;\n  }\n  ll erase(ll l, ll r) {\n    assert(l <= r);\n    auto it = prev(s.lower_bound({l + 1, l + 1}));\n    if(it->first <= l && r <= it->second) {\n      if(it->first < l) { s.emplace(it->first, l - 1); }\n      if(r < it->second) { s.emplace(r + 1, it->second); }\n      s.erase(it);\n      cnt -= r - l + 1;\n      return r - l + 1;\n    }\n    ll ret = 0;\n    if(it->first <= l && l <= it->second) {\n      ret += it->second - l + 1;\n      if(it->first < l) { s.emplace(it->first, l - 1); }\n      it = s.erase(it);\n    }\n    else it = next(it);\n    while(it->second <= r) {\n      ret += it->second - it->first + 1;\n      it = s.erase(it);\n    }\n    if(it->first <= r && r <= it->second) {\n      ret += r - it->first + 1;\n      if(r < it->second) { s.emplace(r + 1, it->second); }\n      s.erase(it);\n    }\n    cnt -= ret;\n    return ret;\n  }\n  ll erase(ll x) {\n    auto it = prev(s.lower_bound({x + 1, x + 1}));\n    auto [l, r] = *it;\n    if(!(l <= x && x <= r)) { return 0; }\n    s.erase(it);\n    if(l != x) { s.emplace(l, x - 1); }\n    if(r != x) { s.emplace(x + 1, r); }\n    cnt--;\n    return 1;\n  }\n  int size() const { return (int)s.size() - 2; }\n  ll count() const { return cnt; }\n  ll mex(ll x = 0) const {\n    auto [l, r] = *prev(s.lower_bound({x + 1, x + 1}));\n    return l <= x && x <= r ? r + 1 : x;\n  }\n  bool same(ll x, ll y) const {\n    auto ix = covered_by(x).first, iy = covered_by(y).first;\n    return ix == iy && ix != -inf;\n  }\n  void dump() const {\n    for(auto &[l, r] : s) {\n      if(l == -inf || r == inf) { continue; }\n      cout << \"[\" << l << \", \" << r << \"] \";\n    }\n    cout << \"\\\\n\";\n  }\n} I;\n\n// bool contains(l,r)/(x) : return if [l,r] / x is covered\n// pair covered_by(l,r)/(x) : return interval [l,r] / x is covered or {-inf,-inf}\n// ll   insert(l,r)/(x)     : insert [l,r] / x, return Δcnt\n// ll   erase(l,r)/(x)      : erase [l,r] / x, return -Δcnt\n// int  size()             : return the number of interval\n// ll   count()             : return the number of integer contained\n// ll   mex(x = 0)          : return mex[x, inf)\n// bool same(x,y)         : return if x and y are covered by same interval\n// void dump()            : output(for debug)\n"
  // },
  "unsigned long long": {
    "prefix": "ull",
    "body": "unsigned long long"
  },
  // "Time": {
  //   "prefix": "Time",
  //   "body": "struct Time {\n  int lim;\n  bool start;\n  chrono::system_clock::time_point t;\n  Time(int lim): lim(lim), start(false){};\n  long double operator()(bool output = true) {\n    if(!start) {\n      t = chrono::system_clock::now();\n      start = true;\n      return 0;\n    }\n    auto d = chrono::system_clock::now() - t;\n    auto msec = chrono::duration_cast<chrono::milliseconds>(d).count();\n    if(output) {\n      cerr << \"\\\\n-------------------------------\\\\n\";\n      if(msec <= lim) {\n        cerr << \"[\\\\033[36mi\\\\033[m] \";\n        cerr << \"\\\\033[36mExecution Time : \" << msec << \" ms\\\\033[m\\\\n\";\n      }\n      else {\n        cerr << \"[\\\\033[33m!\\\\033[m] \";\n        cerr << \"\\\\033[33mExecution Time : \" << msec << \" ms\\\\033[m\\\\n\";\n      }\n      cerr << \"-------------------------------\\\\n\";\n    }\n    return msec;\n  }\n} Time(2000);"
  // },
  // "RollingHash": {
  //   "prefix": "RollingHash",
  //   "body": "struct Modint2_61 {\n  static constexpr unsigned long long MOD = (1ULL << 61) - 1;\n  unsigned long long x;\n  constexpr Modint2_61(): x(0ULL) {}\n  constexpr Modint2_61(unsigned long long y): x(y >= MOD ? y - MOD : y) { assert(y < MOD * 2); }\n  unsigned long long val() const noexcept { return x; }\n  Modint2_61 operator-() const { return Modint2_61(MOD - x); }\n  Modint2_61 operator+(const Modint2_61 &a) const { return Modint2_61(x + a.x); }\n  Modint2_61 operator-(const Modint2_61 &a) const { return Modint2_61(x + MOD - a.x); }\n  Modint2_61 operator*(const Modint2_61 &a) const {\n    __uint128_t r = __uint128_t(x) * a.x;\n    r = (r >> 61) + (r & MOD);\n    return Modint2_61(r);\n  }\n  Modint2_61 operator/(const Modint2_61 &a) const { return *this * a.inv(); }\n  Modint2_61 pow(ll n) const {\n    if(n < 0) { return inv().pow(-n); }\n    Modint2_61 r(1), t = *this;\n    while(n) {\n      if(n & 1) { r *= t; }\n      t *= t;\n      n >>= 1;\n    }\n    return r;\n  }\n  Modint2_61 inv() const { return pow(MOD - 2); }\n  Modint2_61 &operator+=(const Modint2_61 &a) { return *this = *this + a; }\n  Modint2_61 &operator-=(const Modint2_61 &a) { return *this = *this - a; }\n  Modint2_61 &operator*=(const Modint2_61 &a) { return *this = *this * a; }\n  Modint2_61 &operator/=(const Modint2_61 &a) { return *this = *this / a; }\n  template<typename T> friend Modint2_61 operator+(T a, const Modint2_61 &b) { return (Modint2_61(a) += b); }\n  template<typename T> friend Modint2_61 operator-(T a, const Modint2_61 &b) { return (Modint2_61(a) -= b); }\n  template<typename T> friend Modint2_61 operator*(T a, const Modint2_61 &b) { return (Modint2_61(a) *= b); }\n  template<typename T> friend Modint2_61 operator/(T a, const Modint2_61 &b) { return (Modint2_61(a) /= b); }\n  explicit operator bool() const { return x; }\n  bool operator==(const Modint2_61 &a) const { return (x == a.x); }\n  bool operator!=(const Modint2_61 &a) const { return (x != a.x); }\n  bool operator<(const Modint2_61 &a) const { return x < a.x; }  // to use map\n  friend ostream &operator<<(ostream &os, const Modint2_61 &a) { return os << a.x; }\n};\n\nusing mint = Modint2_61;\nconst unsigned long long base = chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now().time_since_epoch()).count() % Modint2_61::MOD;\nstruct RollingHash {\n  vector<mint> hashed, power;\n  int n;\n  RollingHash(){}\n  RollingHash(const string &s): n(ssize(s)) {\n    hashed.assign(n + 1, 0);\n    power.assign(n + 1, 0);\n    power[0] = 1;\n    for(ll i = 0; i < n; i++) {\n      power[i + 1] = power[i] * base;\n      hashed[i + 1] = hashed[i] * base + s[i];\n    }\n  }\n  mint hash(ll l, ll r) const {\n    return hashed[r] - hashed[l] * power[r - l];\n  }\n  static mint hash(const string &s) {\n    mint r = 0;\n    for(auto &i : s) { r = r * base + i; }\n    return r;\n  }\n  mint connect(mint h1, mint h2, ll h2len) const {\n    return h1 * power[h2len] + h2;\n  }\n  void connect(const string &s) {\n    ll m = ssize(s);\n    hashed.resize(n + m + 1);\n    power.resize(n + m + 1);\n    for(ll i = n; i < n + m; i++) {\n      power[i + 1] = power[i] * base;\n      hashed[i + 1] = hashed[i] * base + s[i - n];\n    }\n  }\n  int find(string &s, int lhs = 0) const {\n    mint h = hash(s);\n    for(int i = lhs; i <= n - ssize(s); i++) {\n      if(h == hash(i, i + ssize(s))) { return i; }\n    }\n    return -1;\n  }\n  ll LCP(const RollingHash &b, ll l1, ll r1, ll l2, ll r2) {\n    ll len = min(r1 - l1, r2 - l2);\n    ll low = -1, high = len + 1;\n    while(high - low > 1) {\n      ll mid = (low + high) / 2;\n      if(hash(l1, l1 + mid) == b.hash(l2, l2 + mid)) { low = mid; }\n      else { high = mid; }\n    }\n    return low;\n  }\n};\n// https://github.com/tatyam-prime/kyopro_library/blob/master/RollingHash.cpp\n// https://nyaannyaan.github.io/library/string/rolling-hash.hpp (hash(string),find)"
  // },
  // "Modint2_61": {
  //   "prefix": "Modint2_61",
  //   "body": "struct Modint2_61 {\n  static constexpr unsigned long long MOD = (1ULL << 61) - 1;\n  unsigned long long x;\n  constexpr Modint2_61(): x(0ULL) {}\n  constexpr Modint2_61(unsigned long long y): x(y >= MOD ? y - MOD : y) { assert(y < MOD * 2); }\n  unsigned long long val() const noexcept { return x; }\n  Modint2_61 operator-() const { return Modint2_61(MOD - x); }\n  Modint2_61 operator+(const Modint2_61 &a) const { return Modint2_61(x + a.x); }\n  Modint2_61 operator-(const Modint2_61 &a) const { return Modint2_61(x + MOD - a.x); }\n  Modint2_61 operator*(const Modint2_61 &a) const {\n    __uint128_t r = __uint128_t(x) * a.x;\n    r = (r >> 61) + (r & MOD);\n    return Modint2_61(r);\n  }\n  Modint2_61 operator/(const Modint2_61 &a) const { return *this * a.inv(); }\n  Modint2_61 pow(ll n) const {\n    if(n < 0) { return inv().pow(-n); }\n    Modint2_61 r(1), t = *this;\n    while(n) {\n      if(n & 1) { r *= t; }\n      t *= t;\n      n >>= 1;\n    }\n    return r;\n  }\n  Modint2_61 inv() const { return pow(MOD - 2); }\n  Modint2_61 &operator+=(const Modint2_61 &a) { return *this = *this + a; }\n  Modint2_61 &operator-=(const Modint2_61 &a) { return *this = *this - a; }\n  Modint2_61 &operator*=(const Modint2_61 &a) { return *this = *this * a; }\n  Modint2_61 &operator/=(const Modint2_61 &a) { return *this = *this / a; }\n  template<typename T> friend Modint2_61 operator+(T a, const Modint2_61 &b) { return (Modint2_61(a) += b); }\n  template<typename T> friend Modint2_61 operator-(T a, const Modint2_61 &b) { return (Modint2_61(a) -= b); }\n  template<typename T> friend Modint2_61 operator*(T a, const Modint2_61 &b) { return (Modint2_61(a) *= b); }\n  template<typename T> friend Modint2_61 operator/(T a, const Modint2_61 &b) { return (Modint2_61(a) /= b); }\n  explicit operator bool() const { return x; }\n  bool operator==(const Modint2_61 &a) const { return (x == a.x); }\n  bool operator!=(const Modint2_61 &a) const { return (x != a.x); }\n  bool operator<(const Modint2_61 &a) const { return x < a.x; }  // to use map\n  friend ostream &operator<<(ostream &os, const Modint2_61 &a) { return os << a.x; }\n};\n\nusing mint=Modint2_61;\nconst unsigned long long base = chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now().time_since_epoch()).count() % Modint2_61::MOD;"
  // },
  "gcd": {
    "prefix": "gcd",
    "body": "gcd($1,$2)"
  },
  "lcm": {
    "prefix": "lcm",
    "body": "lcm($1,$2)"
  },
  // "Segtree2D": {
  //   "prefix": "Segtree2D",
  //   "body": "template<typename S, auto op, auto e> struct SegTree2D {\n private:\n  vector<S> seg;\n  bool built;\n  int id(int x, int y) const { return x * 2 * W + y; }\n  S inner_prod(int x, int ly, int ry) {\n    S res = e();\n    for(; ly < ry; ly >>= 1, ry >>= 1) {\n      if(ly & 1) { res = op(res, seg[id(x, ly)]), ly++; }\n      if(ry & 1) { --ry, res = op(res, seg[id(x, ry)]); }\n    }\n    return res;\n  }\n\n public:\n  int H, W;\n  SegTree2D(int x, int y): built(false) {\n    H = W = 1;\n    while(H < x) { H <<= 1; }\n    while(W < y) { W <<= 1; }\n    seg.assign(4 * H * W, e());\n  }\n  void set(int x, int y, const S &s) {\n    if(!built) { seg[id(x + H, y + W)] = s; }\n    else {\n      x += H, y += W;\n      seg[id(x, y)] = s;\n      for(int i = x >> 1; i; i >>= 1) { seg[id(i, y)] = op(seg[id(2 * i, y)], seg[id(2 * i + 1, y)]); }\n      for(; x; x >>= 1) {\n        for(int j = y >> 1; j; j >>= 1) { seg[id(x, j)] = op(seg[id(x, 2 * j)], seg[id(x, 2 * j + 1)]); }\n      }\n    }\n  }\n  void build() {\n    built = true;\n    for(int y = W; y < 2 * W; y++) {\n      for(int x = H - 1; x; x--) { seg[id(x, y)] = op(seg[id(2 * x, y)], seg[id(2 * x + 1, y)]); }\n    }\n    for(int x = 0; x < 2 * H; x++) {\n      for(int y = W - 1; y; y--) { seg[id(x, y)] = op(seg[id(x, 2 * y)], seg[id(x, 2 * y + 1)]); }\n    }\n  }\n  S get(int x, int y) const { return seg[id(x + H, y + W)]; }\n  S operator()(int x, int y) const { return seg[id(x + H, y + W)]; }\n  S prod(int lx, int rx, int ly, int ry) {\n    if(lx >= rx || ly >= ry) { return e(); }\n    S res = e();\n    lx += H, rx += H, ly += W, ry += W;\n    for(; lx < rx; lx >>= 1, rx >>= 1) {\n      if(lx & 1) { res = op(res, inner_prod(lx, ly, ry)), lx++; }\n      if(rx & 1) { --rx, res = op(res, inner_prod(rx, ly, ry)); }\n    }\n    return res;\n  }\n  S operator()(int lx, int rx, int ly, int ry) { return prod(lx, rx, ly, ry); }\n};"
  // },
  "segtree2D": {
    "prefix": "segtree2D",
    "body": "SegTree2D<S,op,e> seg(${1:h},${2:w});"
  },
  // "BSGS": {
  //   "prefix": "BSGS",
  //   "body": "template<typename T> ll BSGS(T s, T g, ll n, ll m, const auto &f, const auto &fm) {\n  unordered_map<T, int> mp;\n  for(int i = 1; i <= m; i++) {\n    g = f(g);\n    mp[g] = -i;\n  }\n  for(int i = 1;; i++) {\n    s = fm(s);\n    if(mp.count(s)) { return m * i + mp[s]; }\n    if(n <= m * i) { return -1; }\n  }\n}"
  // },
  // "C++17": {
  //   "prefix": "C++17",
  //   "body": "#if __cplusplus <= 201703L\n#define ssize(v) ((int)(v).size())\ntemplate<typename T> ll bit_ceil(T n) {\n  ll r = 1;\n  while(r < n) { r <<= 1; }\n  return r;\n}\ntemplate<typename T> ll bit_width(T n) { return 64 - __builtin_clzll(n); }\ntemplate<typename T> ll countr_zero(T n) { return __builtin_ctzll(n); }\ntemplate<typename T> ll popcount(T n) { return __builtin_popcountll(n); }\nnamespace ranges {\ntemplate<typename T> void sort(vector<T> &v) { sort(v.begin(), v.end()); }\ntemplate<typename T> void stable_sort(vector<T> &v) { stable_sort(v.begin(), v.end()); }\ntemplate<typename T, typename F> void sort(vector<T> &v, const F &f) { sort(v.begin(), v.end(), f); }\ntemplate<typename T> void reverse(vector<T> &v) { reverse(v.begin(), v.end()); }\ntemplate<typename T> T max(const vector<T> &v) { return *max_element(v.begin(), v.end()); }\ntemplate<typename T> T min(const vector<T> &v) { return *min_element(v.begin(), v.end()); }\ntemplate<typename T, typename U> bool binary_search(const vector<T> &v, U x) { return binary_search(v.begin(), v.end(), x); }\ntemplate<typename T, typename F> bool all_of(const vector<T> &v, const F &f) { return all_of(v.begin(), v.end(), f); }\ntemplate<typename T, typename F> bool any_of(const vector<T> &v, const F &f) { return any_of(v.begin(), v.end(), f); }\ntemplate<typename T, typename F> bool none_of(const vector<T> &v, const F &f) { return none_of(v.begin(), v.end(), f); }\ntemplate<typename T, typename F> int count_if(const vector<T> &v, const F &f) { return count_if(v.begin(), v.end(), f); }\ntemplate<typename T, typename U> auto lower_bound(const vector<T> &v, U x) { return lower_bound(v.begin(), v.end(), x); }\ntemplate<typename T, typename U> auto upper_bound(const vector<T> &v, U x) { return upper_bound(v.begin(), v.end(), x); }\ntemplate<typename T, typename U, typename F> auto lower_bound(const vector<T> &v, U x, const F &f) { return lower_bound(v.begin(), v.end(), x, f); }\ntemplate<typename T, typename U, typename F> auto upper_bound(const vector<T> &v, U x, const F &f) { return upper_bound(v.begin(), v.end(), x, f); }\ntemplate<typename T> auto max_element(const vector<T> &v) { return max_element(v.begin(), v.end()); }\ntemplate<typename T> auto min_element(const vector<T> &v) { return min_element(v.begin(), v.end()); }\ntemplate<typename T, typename U> void fill(vector<T> &v, U x) { fill(v.begin(), v.end(), x); }\n}  // namespace ranges\n#endif"
  // },
  // "SubsetConvolution": {
  //   "prefix": "SubsetConvolution",
  //   "body": "template<int S> struct SubsetConvolution {\n  using fps = array<mint, S + 1>;\n  static constexpr int s = S;\n  vector<int> pc;\n  SubsetConvolution(): pc(1 << s) {\n    for(int i = 1; i < (1 << s); i++) { pc[i] = pc[i - (i & -i)] + 1; }\n  }\n  void add(fps &l, const fps &r, int d) {\n    for(int i = 0; i < d; ++i) { l[i] += r[i]; }\n  }\n  void sub(fps &l, const fps &r, int d) {\n    for(int i = d; i <= s; ++i) { l[i] -= r[i]; }\n  }\n  void zeta(vector<fps> &a) {\n    int n = a.size();\n    for(int w = 1; w < n; w *= 2) {\n      for(int k = 0; k < n; k += w * 2) {\n        for(int i = 0; i < w; ++i) { add(a[k + w + i], a[k + i], pc[k + w + i]); }\n      }\n    }\n  }\n  void mobius(vector<fps> &a) {\n    int n = a.size();\n    for(int w = n >> 1; w; w >>= 1) {\n      for(int k = 0; k < n; k += w * 2) {\n        for(int i = 0; i < w; ++i) { sub(a[k + w + i], a[k + i], pc[k + w + i]); }\n      }\n    }\n  }\n  vector<fps> lift(const vector<mint> &a) {\n    vector<fps> A(a.size());\n    for(int i = 0; i < (int)a.size(); i++) {\n      ranges::fill(A[i], 0);\n      A[i][pc[i]] = a[i];\n    }\n    return A;\n  }\n  vector<mint> unlift(const vector<fps> &A) {\n    vector<mint> a(A.size());\n    for(int i = 0; i < (int)A.size(); i++) { a[i] = A[i][pc[i]]; }\n    return a;\n  }\n  void prod(vector<fps> &A, const vector<fps> &B) {\n    int n = A.size(), d = __builtin_ctz(n);\n    for(int i = 0; i < n; i++) {\n      fps c{};\n      for(int j = 0; j <= d; j++) {\n        for(int k = 0; k <= d - j; k++) { c[j + k] += A[i][j] * B[i][k]; }\n      }\n      A[i].swap(c);\n    }\n  }\n  vector<mint> multiply(const vector<mint> &a, const vector<mint> &b) {\n    vector<fps> A = lift(a), B = lift(b);\n    zeta(A), zeta(B);\n    prod(A, B);\n    mobius(A);\n    return unlift(A);\n  }\n};\n// https://nyaannyaan.github.io/library/set-function/subset-convolution.hpp.html"
  // },
  // "BlockCutTree": {
  //   "prefix": "BlockCutTree",
  //   "body": "struct Lowlink {\n private:\n  int dfs(int idx, int k, int par) {\n    low[idx] = (ord[idx] = k++);\n    int cnt = 0;\n    bool arti = false, second = false;\n    for(auto &to : g[idx]) {\n      if(ord[to] == -1) {\n        cnt++;\n        k = dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        arti |= (par != -1) && (low[to] >= ord[idx]);\n        if(ord[idx] < low[to]) { bridge.emplace_back(minmax(idx, to)); }\n      }\n      else if(to != par || second) { low[idx] = min(low[idx], ord[to]); }\n      else { second = true; }\n    }\n    arti |= par == -1 && cnt > 1;\n    if(arti) { articulation.emplace_back(idx); }\n    return k;\n  }\n\n public:\n  const vector<vector<int>> g;\n  int N;\n  vector<int> ord, low;\n  vector<int> articulation;\n  vector<pair<int, int>> bridge;\n  Lowlink(const vector<vector<int>> &g_): g(g_), N(g.size()), ord(N, -1), low(N, -1) {\n    for(int i = 0, k = 0; i < N; i++) {\n      if(ord[i] == -1) { k = dfs(i, k, -1); }\n    }\n  }\n};\n\nstruct BiConnectedComponents : Lowlink {\n private:\n  void build() {\n    used.assign(this->g.size(), 0);\n    for(int i = 0; i < ssize(used); i++) {\n      if(!used[i]) { dfs(i, -1); }\n    }\n  }\n  void dfs(int idx, int par) {\n    used[idx] = true;\n    for(auto &to : this->g[idx]) {\n      if(to == par) { continue; }\n      if(!used[to] || this->ord[to] < this->ord[idx]) { tmp.emplace_back(minmax<int>(idx, to)); }\n      if(!used[to]) {\n        dfs(to, idx);\n        if(this->low[to] >= this->ord[idx]) {\n          bc.emplace_back();\n          while(true) {\n            auto e = tmp.back();\n            bc.back().emplace_back(e);\n            tmp.pop_back();\n            if(e.first == min<int>(idx, to) && e.second == max<int>(idx, to)) { break; }\n          }\n        }\n      }\n    }\n  }\n\n public:\n  vector<int> used;\n  vector<vector<pair<int, int>>> bc;\n  vector<pair<int, int>> tmp;\n  BiConnectedComponents(const vector<vector<int>> &g): Lowlink(g) { build(); }\n};\n\nstruct BlockCutTree {\n private:\n  void build() {\n    auto ar = bcc.articulation;\n    idar.resize(g.size(), -1);\n    idcc.resize(g.size(), -1);\n    for(int i = 0; i < ssize(ar); i++) { idar[ar[i]] = i; }\n    tree.resize(ar.size() + bcc.bc.size());\n    vector<int> last(g.size(), -1);\n    for(int i = 0; i < ssize(bcc.bc); i++) {\n      vector<int> st;\n      for(auto &[u, v] : bcc.bc[i]) {\n        st.emplace_back(u);\n        st.emplace_back(v);\n      }\n      for(auto &u : st) {\n        if(idar[u] == -1) { idcc[u] = i + ar.size(); }\n        else if(last[u] != i) {\n          add(i + ar.size(), idar[u]);\n          last[u] = i;\n        }\n      }\n    }\n  }\n  void add(int i, int j) {\n    if(i == -1 || j == -1) { return; }\n    tree[i].emplace_back(j);\n    tree[j].emplace_back(i);\n  }\n\n public:\n  const vector<vector<int>> &g;\n  BiConnectedComponents bcc;\n  vector<vector<int>> tree;\n  vector<int> idar, idcc;\n  BlockCutTree(const vector<vector<int>> &g): g(g), bcc(g) { build(); }\n\n  vector<int> &operator[](int i) { return tree[i]; }\n  int size() const { return tree.size(); }\n  int id(int i) { return idar[i] == -1 ? idcc[i] : idar[i]; }\n  bool is_arti(int i) { return idar[i] != -1; }\n  int arti() const { return bcc.articulation.size(); }\n};"
  // },
  // "SternBrocotTree": {
  //   "prefix": "SternBrocotTree",
  //   "body": "struct SternBrocotTree {\n  using Node = SternBrocotTree;\n  ll lx, ly, x, y, rx, ry;\n  vector<ll> seq;\n  SternBrocotTree(): lx(0), ly(1), x(1), y(1), rx(1), ry(0) {}\n  SternBrocotTree(ll X, ll Y): SternBrocotTree() {\n    assert(X >= 1 && Y >= 1);\n    ll g = gcd(X, Y);\n    X /= g, Y /= g;\n    while(min(X, Y) > 0) {\n      if(X > Y) {\n        ll d = X / Y;\n        X -= d * Y;\n        go_right(d - (X == 0 ? 1 : 0));\n      }\n      else {\n        ll d = Y / X;\n        Y -= d * X;\n        go_left(d - (Y == 0 ? 1 : 0));\n      }\n    }\n  }\n  SternBrocotTree(const pair<ll, ll> &xy): SternBrocotTree(xy.first, xy.second) {}\n  SternBrocotTree(const vector<ll> &_seq): SternBrocotTree() {\n    for(const ll &d : _seq) {\n      assert(d != 0);\n      if(d > 0) { go_right(d); }\n      if(d < 0) { go_left(d); }\n    }\n    assert(seq == _seq);\n  }\n\n  pair<ll, ll> get() const { return make_pair(x, y); }\n  pair<ll, ll> lower_bound() const { return make_pair(lx, ly); }\n  pair<ll, ll> upper_bound() const { return make_pair(rx, ry); }\n  ll depth() const {\n    ll r = 0;\n    for(auto &s : seq) { r += abs(s); }\n    return r;\n  }\n  void go_left(ll d = 1) {\n    if(d <= 0) { return; }\n    if(seq.empty() || seq.back() > 0) { seq.emplace_back(0); }\n    seq.back() -= d;\n    rx += lx * d, ry += ly * d;\n    x = rx + lx, y = ry + ly;\n  }\n  void go_right(ll d = 1) {\n    if(d <= 0) { return; }\n    if(seq.empty() || seq.back() < 0) { seq.emplace_back(0); }\n    seq.back() += d;\n    lx += rx * d, ly += ry * d;\n    x = rx + lx, y = ry + ly;\n  }\n  bool go_parent(ll d = 1) {\n    if(d <= 0) { return true; }\n    while(d != 0) {\n      if(seq.empty()) { return false; }\n      ll d2 = min(d, abs(seq.back()));\n      if(seq.back() > 0) {\n        x -= rx * d2, y -= ry * d2;\n        lx = x - rx, ly = y - ry;\n        seq.back() -= d2;\n      }\n      else {\n        x -= lx * d2, y -= ly * d2;\n        rx = x - lx, ry = y - ly;\n        seq.back() += d2;\n      }\n      d -= d2;\n      if(seq.back() == 0) { seq.pop_back(); }\n      if(d2 == 0) { break; }\n    }\n    return true;\n  }\n  static Node lca(const Node &lhs, const Node &rhs) {\n    Node n;\n    for(int i = 0; i < min<int>(lhs.seq.size(), rhs.seq.size()); i++) {\n      ll val1 = lhs.seq[i], val2 = rhs.seq[i];\n      if((val1 < 0) != (val2 < 0)) { break; }\n      if(val1 < 0) { n.go_left(min(-val1, -val2)); }\n      if(val1 > 0) { n.go_right(min(val1, val2)); }\n      if(val1 != val2) { break; }\n    }\n    return n;\n  }\n  friend ostream &operator<<(ostream &os, const Node &rhs) {\n    os << \"\\\\n\";\n    os << \"L : (\" << rhs.lx << \", \" << rhs.ly << \" )\\\\n\";\n    os << \"M : (\" << rhs.x << \", \" << rhs.y << \" )\\\\n\";\n    os << \"R : (\" << rhs.rx << \", \" << rhs.ry << \" )\\\\n\";\n    os << \"seq : {\";\n    for(auto &x : rhs.seq) { os << x << \", \"; }\n    os << \"}\\\\n\";\n    return os;\n  }\n  friend bool operator<(const Node &lhs, const Node &rhs) { return lhs.x * rhs.y < rhs.x * lhs.y; }\n  friend bool operator==(const Node &lhs, const Node &rhs) { return lhs.x == rhs.x && lhs.y == rhs.y; }\n};"
  // },
  // "SternBrocotTree_BinarySearch": {
  //   "prefix": "SternBrocotTree_BinarySearch",
  //   "body": "pair<pair<ll, ll>, pair<ll, ll>> SternBrocotTree_BinarySearch(function<bool(pair<ll, ll>)> f, const ll &INF) {\n  assert(INF >= 0);\n  SternBrocotTree m;\n  if(INF == 0) { return {m.lower_bound(), m.upper_bound()}; }\n  auto over = [&](bool return_value) {\n    return max(m.x, m.y) > INF || f(m.get()) == return_value;\n  };\n  if(f(make_pair(0, 1))) { return {m.lower_bound(), m.upper_bound()}; }\n  ll go_left = over(true);\n  for(; true; go_left ^= 1) {\n    if(go_left) {\n      ll a = 1;\n      for(; true; a *= 2) {\n        m.go_left(a);\n        if(over(false)) {\n          m.go_parent(a);\n          break;\n        }\n      }\n      for(a /= 2; a != 0; a /= 2) {\n        m.go_left(a);\n        if(over(false)) { m.go_parent(a); }\n      }\n      m.go_left();\n      if(max(m.get().first, m.get().second) > INF) { return {m.lower_bound(), m.upper_bound()}; }\n    }\n    else {\n      ll a = 1;\n      for(; true; a *= 2) {\n        m.go_right(a);\n        if(over(true)) {\n          m.go_parent(a);\n          break;\n        }\n      }\n      for(a /= 2; a != 0; a /= 2) {\n        m.go_right(a);\n        if(over(true)) { m.go_parent(a); }\n      }\n      m.go_right();\n      if(max(m.get().first, m.get().second) > INF) { return {m.lower_bound(), m.upper_bound()}; }\n    }\n  }\n}"
  // },
  // "CartesianTree": {
  //   "prefix": "CartesianTree",
  //   "body": "template<typename T> pair<vector<vector<int>>, int> CartesianTree(vector<T> &v) {\n  int N = ssize(v);\n  vector<vector<int>> g(N);\n  vector<int> p(N, -1), st;\n  st.reserve(N);\n  for(int i = 0; i < N; i++) {\n    int pre = -1;\n    while(!st.empty() && v[i] < v[st.back()]) {\n      pre = st.back();\n      st.pop_back();\n    }\n    if(pre != -1) { p[pre] = i; }\n    if(!st.empty()) { p[i] = st.back(); }\n    st.emplace_back(i);\n  }\n  int root = -1;\n  for(int i = 0; i < N; i++) {\n    if(p[i] != -1) { g[p[i]].emplace_back(i); }\n    else root = i;\n  }\n  return {g, root};\n}"
  // },
  // "PrimeRange": {
  //   "prefix": "PrimeRange",
  //   "body": "vector<ll> PrimeEnum(ll n) {\n  vector<bool> sieve(n / 3 + 1, true);\n  for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {\n    if(!sieve[i]) { continue; }\n    for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }\n  }\n  vector<ll> ret = {2, 3};\n  for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {\n    if(sieve[i]) { ret.emplace_back(p); }\n  }\n  while(!ret.empty() && ret.back() > n) { ret.pop_back(); }\n  return ret;\n}\n\nuint64_t Root(uint64_t a, int k = 2) {\n  if(a <= 1 || k == 1) { return a; }\n  if(k >= 64) { return 1; }\n  auto check = [&](__uint128_t n) {\n    __uint128_t x = 1, m = n;\n    for(ll p = k; p; p >>= 1, m *= m) {\n      if(p & 1) { x *= m; }\n    }\n    return x <= a;\n  };\n  uint64_t n = powl(a, (long double)(1.0) / k);\n  while(!check(n)) { --n; }\n  while(check(n + 1)) { ++n; }\n  return n;\n}\n\nvector<vector<pair<ll, ll>>> PrimeRange(ll l, ll r) {\n  int n = r - l + 1;\n  vector<ll> v(n);\n  iota(v.begin(), v.end(), l);\n  vector<vector<pair<ll, ll>>> p(n);\n  for(auto &i : PrimeEnum(Root(r))) {\n    for(ll j = (l + i - 1) / i * i; j <= r; j += i) {\n      int c = 0;\n      while(v[j - l] % i == 0) {\n        v[j - l] /= i;\n        c++;\n      }\n      if(c) { p[j - l].emplace_back(i, c); }\n    }\n  }\n  for(int i = 0; i < n; i++) {\n    if(v[i] != 1) { p[i].emplace_back(v[i], 1); }\n  }\n  return p;\n}"
  // },
  "primerange": {
    "prefix": "primerange",
    "body": "PrimeRange($1,$2)$0"
  },
  "LinkCutTree": {
    "prefix": "LinkCutTree",
    "body": "template<typename T> struct LinkCutTree {\n public:\n  struct node {\n    int sz, sub1, sub2;\n    T val, al, lazy, sum1, sum2;\n    node *left, *right, *par;\n    bool rev;\n    node(const T _val): sz(1), sub1(1), sub2(0), val(_val), al(_val), lazy(0), sum1(_val), sum2(0), left(nullptr), right(nullptr), par(nullptr), rev(false) {}\n    bool isRoot() const { return (!par) || (par->left != this && par->right != this); }\n    void push() {\n      if(lazy != 0) {\n        val += lazy;\n        al += lazy * sz;\n        if(left) { left->lazy += lazy; }\n        if(right) { right->lazy += lazy; }\n        lazy = 0;\n      }\n      if(!rev) { return; }\n      swap(left, right);\n      if(left) { left->rev = !(left->rev); }\n      if(right) { right->rev = !(right->rev); }\n      rev = false;\n    }\n    void eval() {\n      sz = 1;\n      sub1 = sub2 + 1;\n      al = val;\n      sum1 = sum2 + val;\n      if(left) {\n        left->push();\n        sz += left->sz;\n        sub1 += left->sub1;\n        al += left->al;\n        sum1 += left->sum1;\n      }\n      if(right) {\n        right->push();\n        sz += right->sz;\n        sub1 += right->sub1;\n        al += right->al;\n        sum1 += right->sum1;\n      }\n    }\n  };\n\n private:\n  void rotate(node *u, bool right) {\n    node *p = u->par, *g = p->par;\n    if(right) {\n      if((p->left = u->right)) { u->right->par = p; }\n      u->right = p;\n      p->par = u;\n    }\n    else {\n      if((p->right = u->left)) { u->left->par = p; }\n      u->left = p;\n      p->par = u;\n    }\n    p->eval();\n    u->eval();\n    u->par = g;\n    if(!g) { return; }\n    if(g->left == p) { g->left = u; }\n    if(g->right == p) { g->right = u; }\n    g->eval();\n  }\n  void splay(node *u) {\n    while(!(u->isRoot())) {\n      node *p = u->par, *gp = p->par;\n      if(p->isRoot()) {\n        p->push();\n        u->push();\n        rotate(u, (u == p->left));\n      }\n      else {\n        gp->push();\n        p->push();\n        u->push();\n        bool flag = (u == p->left);\n        if((u == p->left) == (p == gp->left)) {\n          rotate(p, flag);\n          rotate(u, flag);\n        }\n        else {\n          rotate(u, flag);\n          rotate(u, !flag);\n        }\n      }\n    }\n    u->push();\n  }\n  node *access(node *u) {\n    node *last = nullptr;\n    for(node *v = u; v; v = v->par) {\n      splay(v);\n      if(v->right) {\n        v->sub2 += v->right->sub1;\n        v->sum2 += v->right->sum1;\n      }\n      v->right = last;\n      if(v->right) {\n        v->sub2 -= v->right->sub1;\n        v->sum2 -= v->right->sum1;\n      }\n      v->eval();\n      last = v;\n    }\n    splay(u);\n    return last;\n  }\n  bool same(node *u, node *v) {\n    access(u);\n    access(v);\n    return u == v || u->par;\n  }\n  void unite(node *u, node *v) {\n    evert(u);\n    access(v);\n    u->par = v;\n    v->sub2 += u->sub1;\n    v->sum2 += u->sum1;\n  }\n  void cut(node *u) {\n    access(u);\n    u->left->par = nullptr;\n    u->left = nullptr;\n    u->eval();\n  }\n  void cut(node *u, node *v) {\n    access(u);\n    access(v);\n    if(u->isRoot()) {\n      v->sub2 -= u->sub1;\n      v->sum2 -= u->sum1;\n      u->par = nullptr;\n    }\n    else {\n      v->left->par = nullptr;\n      v->left = nullptr;\n      v->eval();\n    }\n  }\n  node *lca(node *u, node *v) {\n    access(u);\n    return access(v);\n  }\n  void evert(node *u) {\n    access(u);\n    u->rev = !(u->rev);\n    u->push();\n  }\n  int depth(node *u) {\n    access(u);\n    return u->sz - 1;\n  }\n  void toRoot_range(node *u, const T x) {\n    access(u);\n    u->lazy += x;\n    u->push();\n  }\n  T toRoot_query(node *u) {\n    access(u);\n    return u->al;\n  }\n  void range(node *u, node *v, const T x) {\n    evert(u);\n    access(v);\n    v->lazy += x;\n    v->push();\n  }\n  T query(node *u, node *v) {\n    evert(u);\n    access(v);\n    return v->al;\n  }\n  int component_size(node *u) {\n    evert(u);\n    return u->sub1;\n  }\n  int subtree_size(node *u) {\n    access(u);\n    return u->sub2 + 1;\n  }\n  T component_query(node *u) {\n    evert(u);\n    return u->sum1;\n  }\n  T subtree_query(node *u) {\n    access(u);\n    return u->sum2 + u->val;\n  }\n\n public:\n  const int V;\n  node **arr;\n  LinkCutTree(const vector<T> &init_node_value): V((int)init_node_value.size()) {\n    arr = new node *[V];\n    for(int i = 0; i < V; i++) { arr[i] = new node(init_node_value[i]); }\n  }\n  bool same(int i, int j) { return same(arr[i], arr[j]); }\n  void unite(int i, int j) { return unite(arr[i], arr[j]); }\n  void cut(int i) { return cut(arr[i]); }\n  void cut(int i, int j) { return cut(arr[i], arr[j]); }\n  int lca(int i, int j) { return static_cast<size_t>(lca(arr[i], arr[j]) - arr[0]); }\n  void evert(int i) { return evert(arr[i]); }\n  int depth(int i) { return depth(arr[i]); }\n  void toRoot_range(int i, const T x) { return toRoot_range(arr[i], x); }\n  T toRoot_query(int i) { return toRoot_query(arr[i]); }\n  void range(int i, int j, const T x) { return range(arr[i], arr[j], x); }\n  T query(int i, int j) { return query(arr[i], arr[j]); }\n  int component_size(int i) { return component_size(arr[i]); }\n  int subtree_size(int i) { return subtree_size(arr[i]); }\n  T component_query(int i) { return component_query(arr[i]); }\n  T subtree_query(int i) { return subtree_query(arr[i]); }\n};\n\n// bool same(i,j)         : i と j が同じ木(連結成分)に属するか\n// void unite(i,j)        : i を j の non-preferred edge にする\n// void cut(i)            : i とその親の間の辺を削除する\n// void cut(i,j)          : i と j の間の辺を削除する\n// int  lca(i,j)          : i と j の LCA を求める\n// void evert(i)          : 元の木の根を i にする\n// int  depth(i)          : i の深さを求める\n// void toRoot_range(i,x) : i から根までの間にある頂点すべてに x を足す\n// T    toRoot_query(i)   : i から根までの間にある頂点すべてのコストの総和を求める\n// void range(i,j,x)      : i と j の間にある頂点すべてに x を足す\n// T    query(i,j)        : i と j の間にある頂点すべてのコストの総和を求める\n// int component_size(i)  : i の属する連結成分のサイズを返す\n// int subtree_size(i)    : i を根とする部分木のサイズを返す\n// T   component_query(i) : i の属する連結成分内のコストの総和を返す\n// T   subtree_query(i)   : i を根とする部分木内のコストの総和を返す\n"
  },
  // "PrimitiveRoot": {
  //   "prefix": "PrimitiveRoot",
  //   "body": "constexpr ll safe_mod(ll x, ll m) {\n  x %= m;\n  if(x < 0) { x += m; }\n  return x;\n}\n\nconstexpr ll pow_mod_constexpr(ll x, ll n, int m) {\n  if(m == 1) { return 0; }\n  unsigned int _m = (unsigned int)(m);\n  unsigned long long r = 1, y = safe_mod(x, m);\n  while(n) {\n    if(n & 1) { r = (r * y) % _m; }\n    y = (y * y) % _m;\n    n >>= 1;\n  }\n  return r;\n}\n\nconstexpr int PrimitiveRoot(int m) {\n  if(m == 2) { return 1; }\n  if(m == 167772161) { return 3; }\n  if(m == 469762049) { return 3; }\n  if(m == 754974721) { return 11; }\n  if(m == 998244353) { return 3; }\n  int divs[20] = {};\n  divs[0] = 2;\n  int cnt = 1, x = (m - 1) / 2;\n  while(x % 2 == 0) { x /= 2; }\n  for(int i = 3; (ll)(i)*i <= x; i += 2) {\n    if(x % i == 0) {\n      divs[cnt++] = i;\n      while(x % i == 0) { x /= i; }\n    }\n  }\n  if(x > 1) { divs[cnt++] = x; }\n  for(int g = 2;; g++) {\n    bool ok = true;\n    for(int i = 0; i < cnt; i++) {\n      if(pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n        ok = false;\n        break;\n      }\n    }\n    if(ok) { return g; }\n  }\n}"
  // },
  // "Order": {
  //   "prefix": "Order",
  //   "body": "vector<pair<ll, ll>> Prime(ll n) {\n  vector<pair<ll, ll>> r;\n  for(ll i = 2; i*i <= n; i++) {\n    if(n % i != 0) {continue;}\n    ll e = 0;\n    while(n % i == 0) {e++, n /= i;}\n    r.emplace_back(i, e);\n  }\n  if(n != 1) {r.emplace_back(n, 1);}\n  return r;\n}\n\nstruct Order {\n private:\n  ll mod;\n  size_t n;\n  vector<pair<ll, ll>> fac;\n  vector<ll> prod;\n  ll internal_pow(ll x, ll k) const {\n    ll r = 1;\n    for(; k; k >>= 1) {\n      if(k & 1) { r = __int128_t(r) * x % mod; }\n      x = __int128_t(x) * x % mod;\n    }\n    return r;\n  }\n  int exponent(size_t i, ll x) const {\n    const auto &[p, e] = fac[i];\n    for(int j = 0; j < e; j++) {\n      if(x == 1) { return j; }\n      x = internal_pow(x, p);\n    }\n    return e;\n  }\n  ll query(size_t l, size_t r, ll x) const {\n    ll res = 1;\n    if(r - l == 1) {\n      ll p = fac[l].first;\n      int f = exponent(l, x);\n      while(f--) { res *= p; }\n      return res;\n    }\n    const size_t m = (l + r) >> 1;\n    res *= query(l, m, internal_pow(x, prod[r] / prod[m]));\n    res *= query(m, r, internal_pow(x, prod[m] / prod[l]));\n    return res;\n  }\n\n public:\n  Order(ll p): mod(p) {\n    fac = Prime(p - 1);\n    n = fac.size();\n    prod.resize(n + 1);\n    prod[0] = 1;\n    for(size_t i = 0; i < n; i++) {\n      auto [pf, e] = fac[i];\n      ll ppf = 1;\n      while(e--) { ppf *= pf; }\n      prod[i + 1] = prod[i] * ppf;\n    }\n  }\n  ll query(ll x) const { return n ? query(0, n, x) : 0; }\n  inline ll operator()(ll x) const { return query(x); }\n};"
  // },
  // "Trie": {
  //   "prefix": "Trie",
  //   "body": "template<size_t X = 26, char margin = 'a'> struct Trie {\n  struct Node {\n    array<int, X> nxt;\n    vector<int> idxs;\n    int idx;\n    char key;\n    Node(char c): idx(-1), key(c) { ranges::fill(nxt, -1); }\n  };\n  vector<Node> st;\n  Trie(char c = '$') { st.emplace_back(c); }\n  inline int &next(int i, int j) { return st[i].nxt[j]; }\n  void add(const string &s, int x) {\n    int pos = 0;\n    for(int i = 0; i < ssize(s); i++) {\n      int k = s[i] - margin;\n      if(~next(pos, k)) {\n        pos = next(pos, k);\n        continue;\n      }\n      int npos = st.size();\n      next(pos, k) = npos;\n      st.emplace_back(s[i]);\n      pos = npos;\n    }\n  }\n  int find(const string &s) {\n    int pos = 0;\n    for(int i = 0; i < ssize(s); i++) {\n      int k = s[i] - margin;\n      if(next(pos, k) < 0) { return -1; }\n      pos = next(pos, k);\n    }\n    return pos;\n  }\n  int move(int pos, char c) {\n    return pos < 0 ? -1 : next(pos, c - margin);\n  }\n  int size() const { return st.size(); }\n  int idx(int pos) { return pos < 0 ? -1 : st[pos].idx; }\n  vector<int> idxs(int pos) { return pos < 0 ? vector<int>() : st[pos].idxs; }\n};"
  // },
  // "AhoCorasick": {
  //   "prefix": "AhoCorasick",
  //   "body": "template<size_t X = 26, char margin = 'a'> struct Trie {\n  struct Node {\n    array<int, X> nxt;\n    vector<int> idxs;\n    int idx;\n    char key;\n    Node(char c): idx(-1), key(c) { ranges::fill(nxt, -1); }\n  };\n  int c = 0;\n  vector<Node> st;\n  Trie() { st.emplace_back('$'); }\n  Trie(const vector<string> &v) {\n    st.emplace_back('$');\n    for(auto &i : v) { insert(i); }\n  }\n  void clear() {\n    st.clear();\n    st.emplace_back('$');\n  }\n  inline int &next(int i, int j) { return st[i].nxt[j]; }\n  void insert(const string &s) {\n    int pos = 0;\n    for(int i = 0; i < ssize(s); i++) {\n      int k = s[i] - margin;\n      if(~next(pos, k)) {\n        pos = next(pos, k);\n        continue;\n      }\n      int npos = st.size();\n      next(pos, k) = npos;\n      st.emplace_back(s[i]);\n      pos = npos;\n    }\n    st[pos].idx = c;\n    st[pos].idxs.emplace_back(c);\n    c++;\n  }\n  int find(const string &s) {\n    int pos = 0;\n    for(int i = 0; i < ssize(s); i++) {\n      int k = s[i] - margin;\n      if(next(pos, k) < 0) { return -1; }\n      pos = next(pos, k);\n    }\n    return pos;\n  }\n  int move(int pos, char c) {\n    return pos < 0 ? -1 : next(pos, c - margin);\n  }\n  int size() const { return st.size(); }\n  int idx(int pos) { return pos < 0 ? -1 : st[pos].idx; }\n  vector<int> idxs(int pos) { return pos < 0 ? vector<int>() : st[pos].idxs; }\n};\n\ntemplate<size_t X = 26, char margin = 'a'> struct AhoCorasick : Trie<X + 1, margin> {\n  using TRIE = Trie<X + 1, margin>;\n  using TRIE::c;\n  using TRIE::next;\n  using TRIE::st;\n  using TRIE::TRIE;\n  vector<int> cnt;\n  void build(bool heavy = false) {\n    int n = st.size();\n    cnt.resize(n);\n    for(int i = 0; i < n; i++) {\n      if(heavy) { ranges::sort(st[i].idxs); }\n      cnt[i] = st[i].idxs.size();\n    }\n    queue<int> q;\n    for(int i = 0; i < (int)X; i++) {\n      if(~next(0, i)) {\n        next(next(0, i), X) = 0;\n        q.emplace(next(0, i));\n      }\n      else { next(0, i) = 0; }\n    }\n    while(!q.empty()) {\n      auto &x = st[q.front()];\n      int fail = x.nxt[X];\n      cnt[q.front()] += cnt[fail];\n      q.pop();\n      for(int i = 0; i < (int)X; i++) {\n        int &nx = x.nxt[i];\n        if(nx < 0) {\n          nx = next(fail, i);\n          continue;\n        }\n        q.emplace(nx);\n        next(nx, X) = next(fail, i);\n        if(heavy) {\n          auto &idx = st[nx].idxs, &idy = st[next(fail, i)].idxs;\n          vector<int> idz;\n          ranges::set_union(idx, idy, back_inserter(idz));\n          idx = idz;\n        }\n      }\n    }\n  }\n  ll match_count(string s) {\n    int res = 0, pos = 0;\n    for(auto &c : s) {\n      pos = next(pos, c - margin);\n      res += cnt[pos];\n    }\n    return res;\n  }\n  vector<vector<int>> match(string s) {\n    vector<vector<int>> res(c);\n    int pos = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n      pos = next(pos, s[i] - margin);\n      for(auto &x : st[pos].idxs) { res[x].emplace_back(i); }\n    }\n    return res;\n  }\n  int count(int pos) { return cnt[pos]; }\n};"
  // },
  // "EnumMultiset": {
  //   "prefix": "EnumMultiset",
  //   "body": "// 各要素が[0, k)で長さnの広義単調増加列\nvector<vector<ll>> EnumMultiset(int n, int k) {\n  vector<vector<ll>> r;\n  vector<ll> v(n);\n  auto DFS = [&](auto &&DFS, int p, int s) -> void {\n    if(p == n) {\n      r.emplace_back(v);\n      return;\n    }\n    for(ll i = s; i < k; i++) {\n      v[p] = i;\n      DFS(DFS, p + 1, i);\n    }\n  };\n  DFS(DFS, 0, 0);\n  return r;\n}"
  // },
  // "EnumProduct": {
  //   "prefix": "EnumProduct",
  //   "body": "// [0, v_0) x [0, v_1) x ...\nvector<vector<ll>> EnumProduct(vector<ll> v) {\n  vector<vector<ll>> r;\n  int N = ssize(v);\n  auto DFS = [&](auto &&DFS, vector<ll> &p) -> void {\n    int n = ssize(p);\n    if(n == N) {\n      r.emplace_back(p);\n      return;\n    }\n    for(ll i = 0; i < v[n]; i++) {\n      p.emplace_back(i);\n      DFS(DFS, p);\n      p.pop_back();\n    }\n  };\n  vector<ll> p;\n  DFS(DFS, p);\n  return r;\n}"
  // },
  // "EnumXor": {
  //   "prefix": "EnumXor",
  //   "body": "// L <= x ^ a < R となる x の区間 [l, r)の列挙\nvector<pair<ll, ll>> EnumXor(uint64_t a, uint64_t L, uint64_t R) {\n  vector<pair<ll, ll>> r;\n  for(ll i = 0; i < 64; i++) {\n    if(L == R) { break; }\n    ll b = 1LL << i;\n    if(L & b) {\n      r.emplace_back(L ^ a, (L ^ a) + b);\n      L += b;\n    }\n    if(R & b) {\n      r.emplace_back((R - b) ^ a, ((R - b) ^ a) + b);\n      R -= b;\n    }\n    if(a & b) { a ^= b; }\n  }\n  return r;\n}"
  // },
  // "Doubling": {
  //   "prefix": "Doubling",
  //   "body": "struct Doubling {\n private:\n  int n = 0;\n  vector<vector<ll>> nxts;\n  void build() {\n    vector<ll> nxt(n);\n    for(int i = 0; i < n; i++) {\n      if(int j = nxts.back()[i]; in(j)) { nxt[i] = nxts.back()[j]; }\n      else { nxt[i] = j; }\n    }\n    nxts.emplace_back(move(nxt));\n  }\n  inline bool in(int i) const noexcept { return 0 <= i && i < n; }\n  int pow_next(int s, int d) {\n    assert(in(s));\n    while(ssize(nxts) <= d) { build(); }\n    return nxts[d][s];\n  }\n\n public:\n  Doubling() = default;\n  Doubling(const vector<ll> &nxt): n(ssize(nxt)), nxts(1, nxt) { build(); }\n  int next(int s, ll k) {\n    for(int d = 0; k > 0 && in(s); d++, k >>= 1) {\n      if(k & 1) { s = pow_next(s, d); }\n    }\n    return s;\n  }\n};"
  // },
  "doubling": {
    "prefix": "doubling",
    "body": "Doubling D($1);$0"
  },
  // "Doubling_op": {
  //   "prefix": "Doubling_op",
  //   "body": "template<typename T, typename F> struct Doubling {\n private:\n  int n = 0;\n  vector<vector<ll>> nxts;\n  vector<vector<T>> prds;\n  const F &op;\n\n  void build() {\n    vector<ll> nxt(n);\n    vector<T> prd(n);\n    for(int i = 0; i < n; i++) {\n      if(int j = nxts.back()[i]; in(j)) {\n        nxt[i] = nxts.back()[j];\n        prd[i] = op(prds.back()[i], prds.back()[j]);\n      }\n      else {\n        nxt[i] = j;\n        prd[i] = prds.back()[i];\n      }\n    }\n    nxts.emplace_back(move(nxt));\n    prds.emplace_back(move(prd));\n  }\n  inline bool in(int i) const noexcept { return 0 <= i && i < n; }\n  int pow_next(int s, int d) {\n    assert(in(s));\n    while(ssize(nxts) <= d) { build(); }\n    return nxts[d][s];\n  }\n  const T &pow_prod(int s, int d) {\n    assert(in(s));\n    while(ssize(nxts) <= d) { build(); }\n    return prds[d][s];\n  }\n\n public:\n  Doubling() = default;\n  Doubling(const vector<ll> &g, vector<T> &w, const F &op): n(ssize(g)), nxts(1, g), prds(1, w), op(op) { assert(ssize(g) == ssize(w)); }\n  int next(int s, ll k) {\n    for(int d = 0; k > 0 && in(s); d++, k >>= 1) {\n      if(k & 1) { s = pow_next(s, d); }\n    }\n    return s;\n  }\n  T prod(int s, ll len) {\n    assert(in(s));\n    assert(len > 0);\n    int d = 0;\n    while(!(len & 1)) {\n      d++;\n      len /= 2;\n    }\n    T r = pow_prod(s, d);\n    s = pow_next(s, d);\n    for(++d, len /= 2; len && in(s); d++, len /= 2) {\n      if(len & 1) {\n        r = op(r, pow_prod(s, d));\n        s = pow_next(s, d);\n      }\n    }\n    return r;\n  }\n  int distance(int s, int l, int r) {\n    assert(in(s));\n    if(s <= l || r <= s) { return 0; }\n    int d = 0;\n    while(l < pow_next(s, d) && pow_next(s, d) < r) {\n      if((1 << d) >= n) { return -1; }\n      d++;\n    }\n    int ret = 0, cur = s;\n    for(--d; d >= 0; d--) {\n      if(int nxt = pow_next(cur, d); l < nxt && nxt < r) {\n        ret += 1 << d;\n        cur = nxt;\n      }\n    }\n    return ret + 1;\n  }\n  template<typename F_> ll maxlen(const int s, F_ f, const int maxd = 60) {\n    assert(in(s));\n    int d = 0;\n    while(d <= maxd && f(pow_prod(s, d))) {\n      if(!in(pow_next(s, d))) { return 1LL << maxd; }\n      d++;\n    }\n    if(d > maxd) { return 1LL << maxd; }\n    d--;\n    int cur = pow_next(s, d);\n    ll len = 1LL << d;\n    T p = pow_prod(s, d);\n    for(int e = d - 1; e >= 0; e--) {\n      if(T nxtp = op(p, pow_prod(cur, e)); f(nxtp)) {\n        swap(p, nxtp);\n        cur = pow_next(cur, e);\n        len += 1LL << e;\n      }\n    }\n    return len;\n  }\n};\n// https://hitonanode.github.io/cplib-cpp/other_algorithms/binary_lifting.hpp"
  // },
  "doubling_op": {
    "prefix": "doubling_op",
    "body": "Doubling<ll,decltype(op)> D($1,$2,op);$0"
  },
  // "Matinv": {
  //   "prefix": "Matinv",
  //   "body": "template<typename T> pair<ll, T> GaussianElimination(Matrix<T> &v, ll pivot_end = -1, bool diagonalize = false) {\n  int H = v.size(), W = v[0].size(), rank = 0;\n  if(pivot_end == -1) { pivot_end = W; }\n  T det = 1;\n  for(int j = 0; j < pivot_end; j++) {\n    int idx = -1;\n    for(int i = rank; i < H; i++) {\n      if(v[i][j] != T(0)) {\n        idx = i;\n        break;\n      }\n    }\n    if(idx == -1) {\n      det = 0;\n      continue;\n    }\n    if(rank != idx) {\n      det = -det;\n      swap(v[rank], v[idx]);\n    }\n    det *= v[rank][j];\n    if(diagonalize && v[rank][j] != T(1)) {\n      T c = T(1) / v[rank][j];\n      for(int k = j; k < W; k++) { v[rank][k] *= c; }\n    }\n    int is = diagonalize ? 0 : rank + 1;\n    for(int i = is; i < H; i++) {\n      if(i == rank) { continue; }\n      if(v[i][j] != T(0)) {\n        T c = v[i][j] / v[rank][j];\n        for(int k = j; k < W; k++) { v[i][k] -= v[rank][k] * c; }\n      }\n    }\n    rank++;\n  }\n  return make_pair(rank, det);\n}\n\ntemplate<typename T> Matrix<T> Matinv(const Matrix<T> &v) {\n  int N = v.size();\n  assert(N > 0);\n  assert(N == (int)v[0].size());\n\n  Matrix<T> m(N, 2 * N);\n  for(int i = 0; i < N; i++) {\n    ranges::copy(v[i], m[i].begin());\n    m[i][N + i] = 1;\n  }\n  auto [rank, det] = GaussianElimination(m, N, true);\n  if(rank != N) { return {}; }\n\n  Matrix<T> b(N, 0);\n  for(int i = 0; i < N; i++) { copy(m[i].begin() + N, m[i].end(), back_inserter(b[i])); }\n  return b;\n}"
  // },
  // "F2_Matrix": {
  //   "prefix": "F2_Matrix",
  //   "body": "template<size_t N> bool operator<(const bitset<N> &a, const bitset<N> &b) {\n  int f = (a ^ b)._Find_first();\n  return f == N ? false : a[f];\n}\n\ntemplate<size_t H_MAX, size_t W_MAX> struct F2_Matrix {\n  int H, W;\n  array<bitset<W_MAX>, H_MAX> A;\n  F2_Matrix(int h = H_MAX, int w = W_MAX): H(h), W(w) {\n    assert(h >= 0 && h <= (int)(H_MAX));\n    assert(w >= 0 && w <= (int)(W_MAX));\n    for(int i = 0; i < (int)H_MAX; i++) { A[i].reset(); }\n  }\n  inline bitset<W_MAX> &operator[](int i) { return A[i]; }\n  inline const bitset<W_MAX> &operator[](int i) const { return A[i]; }\n  static F2_Matrix I(int n) {\n    F2_Matrix a(n, n);\n    for(int i = 0; i < n; i++) { a[i][i] = true; }\n    return a;\n  }\n  F2_Matrix &operator*=(const F2_Matrix &B) {\n    F2_Matrix C(H, B.W);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(A[i][j]) { C[i] ^= B[j]; }\n      }\n    }\n    swap(A, C.A);\n    return *this;\n  }\n  F2_Matrix operator*(const F2_Matrix &B) const { return F2_Matrix(*this) *= B; }\n  friend F2_Matrix and_or_product(const F2_Matrix &A, const F2_Matrix &B) {\n    F2_Matrix C(A.H, B.W);\n    for(int i = 0; i < A.H; i++) {\n      for(int j = 0; j < A.W; j++) {\n        if(A[i][j]) { C[i] |= B[j]; }\n      }\n    }\n    return C;\n  }\n  int sweep(ll wr = -1) {\n    if(wr == -1) { wr = W; }\n    int t = 0;\n    for(int u = 0; u < wr; u++) {\n      int piv = -1;\n      for(int i = t; i < H; i++) {\n        if(A[i][u]) {\n          piv = i;\n          break;\n        }\n      }\n      if(piv == -1) { continue; }\n      if(piv != t) { swap(A[piv], A[t]); }\n      for(int i = 0; i < H; i++) {\n        if(i != t && A[i][u]) { A[i] ^= A[t]; }\n      }\n      t++;\n    }\n    return t;\n  }\n  F2_Matrix inv() const {\n    assert(H == W);\n    int N = H;\n    F2_Matrix<H_MAX, W_MAX * 2> c(H, W * 2);\n    for(int i = 0; i < N; i++) {\n      c[i][i + N] = 1;\n      for(int j = 0; j < N; j++) { c[i][j] = A[i][j]; }\n    }\n    int r = c.sweep();\n    assert(r == N);\n    F2_Matrix b(H, W);\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) { b[i][j] = c[i][i + N]; }\n    }\n    return b;\n  }\n  bool operator<(const F2_Matrix &rhs) const {\n    if(H != rhs.H) { return H < rhs.H; }\n    if(W != rhs.W) { return W < rhs.W; }\n    return A < rhs.A;\n  }\n  bool operator==(const F2_Matrix &rhs) const {\n    return H == rhs.H && W == rhs.W && A == rhs.A;\n  }\n  friend ostream &operator<<(ostream &os, const F2_Matrix &b) {\n    for(int i = 0; i < b.H; i++) {\n      os << \"[ \";\n      for(int j = 0; j < b.W; j++) { os << b[i][j] << \", \"; }\n      os << \"],\\\\n\";\n    }\n    return os;\n  }\n};"
  // },
  // "CompressedBIT2D": {
  //   "prefix": "CompressedBIT2D",
  //   "body": "template<typename S, typename T> struct CompressedBIT2D {\n private:\n  int N;\n  vector<fenwick_tree<T>> bit;\n  vector<vector<S>> ys;\n  vector<pair<S, S>> ps;\n  int id(S x) const {\n    return ranges::lower_bound(ps, make_pair(x, S()), [](const pair<S, S> &a, const pair<S, S> &b) { return a.first < b.first; }) - ps.begin();\n  }\n  int id(int i, S y) const { return ranges::lower_bound(ys[i], y) - ys[i].begin(); }\n\n public:\n  CompressedBIT2D() = default;\n  CompressedBIT2D(int N) { ps.reserve(N); }\n  void use(S x, S y) { ps.emplace_back(x, y); }\n  void build() {\n    ranges::sort(ps);\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n    N = ps.size();\n    bit.resize(N + 1);\n    ys.resize(N + 1);\n    for(int i = 0; i <= N; ++i) {\n      for(int j = i + 1; j <= N; j += j & -j) { ys[j].emplace_back(ps[i].second); }\n      ranges::sort(ys[i]);\n      ys[i].erase(unique(ys[i].begin(), ys[i].end()), ys[i].end());\n      bit[i] = fenwick_tree<T>(ys[i].size() + 1);\n    }\n  }\n  void add(S x, S y, T a) {\n    int i = ranges::lower_bound(ps, make_pair(x, y)) - ps.begin();\n    assert(ps[i] == make_pair(x, y));\n    for(++i; i <= N; i += i & -i) { bit[i].add(id(i, y), a); }\n  }\n  T sum(S x, S y) {\n    T r = T();\n    for(int a = id(x); a; a -= a & -a) { r += bit[a].sum(0, id(a, y)); }\n    return r;\n  }\n  T sum(S lx, S rx, S ly, S ry) {\n    T r = T();\n    int a = id(lx), b = id(rx);\n    while(a != b) {\n      if(a < b) {\n        r += bit[b].sum(id(b, ly), id(b, ry));\n        b -= b & -b;\n      }\n      else {\n        r -= bit[a].sum(id(a, ly), id(a, ry));\n        a -= a & -a;\n      }\n    }\n    return r;\n  }\n};"
  // },
  "compressedBIT2D": {
    "prefix": "compressedBIT2D",
    "body": "CompressedBIT2D<ll,ll> W;"
  },
  // "CompressedSegTree2D": {
  //   "prefix": "CompressedSegTree2D",
  //   "body": "template<typename S, typename T, auto op, auto e> struct CompressedSegTree2D {\n private:\n  int N;\n  vector<segtree<T, op, e>> seg;\n  vector<vector<S>> ys;\n  vector<pair<S, S>> ps;\n  int id(S x) const {\n    return ranges::lower_bound(ps, make_pair(x, S()), [](const pair<S, S> &a, const pair<S, S> &b) { return a.first < b.first; }) - ps.begin();\n  }\n  int id(int i, S y) const { return ranges::lower_bound(ys[i], y) - ys[i].begin(); }\n\n public:\n  CompressedSegTree2D() = default;\n  void use(S x, S y) { ps.emplace_back(x, y); }\n  void build() {\n    ranges::sort(ps);\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n    N = ps.size();\n    seg.resize(2 * N);\n    ys.resize(2 * N);\n    for(int i = 0; i < N; i++) {\n      ys[i + N].emplace_back(ps[i].second);\n      seg[i + N] = segtree<T, op, e>(1);\n    }\n    for(int i = N - 1; i; i--) {\n      ys[i].resize(ys[i << 1].size() + ys[i << 1 | 1].size());\n      ranges::merge(ys[i << 1], ys[i << 1 | 1], ys[i].begin());\n      ys[i].erase(unique(ys[i].begin(), ys[i].end()), ys[i].end());\n      seg[i] = segtree<T, op, e>(ys[i].size());\n    }\n  }\n  void set(S x, S y, T a) {\n    int i = ranges::lower_bound(ps, make_pair(x, y)) - ps.begin();\n    assert(ps[i] == make_pair(x, y));\n    for(i += N; i; i >>= 1) { seg[i].set(id(i, y), a); }\n  }\n  T prod(S lx, S rx, S ly, S ry) {\n    T L = e(), R = e();\n    int a = id(lx), b = id(rx);\n    for(a += N, b += N; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) {\n        L = op(L, seg[a].prod(id(a, ly), id(a, ry)));\n        a++;\n      }\n      if(b & 1) {\n        b--;\n        R = op(seg[b].prod(id(b, ly), id(b, ry)), R);\n      }\n    }\n    return op(L, R);\n  }\n};"
  // },
  "compressedSegTree2D": {
    "prefix": "compressedSegTree2D",
    "body": "CompressedSegTree2D<ll,S,op,e> seg;"
  },
  // "GoldenSectionSearch": {
  //   "prefix": "GoldenSectionSearch",
  //   "body": "template<typename T, bool get_min = true> pair<ll, T> GoldenSectionSearch(const auto &f, ll Min, ll Max) {\n  assert(Min <= Max);\n  ll a = Min - 1, x, b, s = 1, t = 2;\n  while(t < Max - Min + 2) { swap(s += t, t); }\n  x = a + t - s;\n  b = a + t;\n  T fx = f(x), fy;\n  while(a + b != 2 * x) {\n    ll y = a + b - x;\n    if(Max < y || (fy = f(y), get_min ? fx < fy : fx > fy)) {\n      b = a;\n      a = y;\n    }\n    else {\n      a = x;\n      x = y;\n      fx = fy;\n    }\n  }\n  return {x, f(x)};\n}"
  // },
  // "ChromaticNumber": {
  //   "prefix": "ChromaticNumber",
  //   "body": "namespace ChromaticNumberImpl {\ntemplate<unsigned mod> int calc(int n, vector<pair<int, int>> hist) {\n  for(int c = 1; c <= n; c++) {\n    ll sm = 0;\n    for(auto &[i, x] : hist) { sm += (x = ll(x) * i % mod); }\n    if(sm % mod != 0) { return c; }\n  }\n  return n;\n}\n}  // namespace ChromaticNumberImpl\n\nint ChromaticNumber(vector<vector<ll>> &g) {\n  int n = g.size();\n  vector<int> adj(n), dp(1 << n);\n  for(int i = 0; i < n; i++) {\n    for(auto &j : g[i]) {\n      adj[i] |= 1 << j;\n      adj[j] |= 1 << i;\n    }\n  }\n  dp[0] = 1;\n  for(int i = 1; i < 1 << n; i++) {\n    int j = __builtin_ctz(i), k = i & (i - 1);\n    dp[i] = dp[k] + dp[k & ~adj[j]];\n  }\n  vector<int> memo((1 << n) + 1);\n  for(int i = 0; i < (1 << n); i++) { memo[dp[i]] += __builtin_parity(i) ? -1 : 1; }\n  vector<pair<int, int>> hist;\n  for(int i = 1; i <= (1 << n); i++) {\n    if(memo[i]) { hist.emplace_back(i, memo[i]); }\n  }\n  return min(ChromaticNumberImpl::calc<1000000021>(n, hist), ChromaticNumberImpl::calc<1000000033>(n, hist));\n}"
  // },
  "fill": {
    "prefix": "fill",
    "body": "ranges::fill($0);"
  },
  // "AuxiliaryTree": {
  //   "prefix": "AuxiliaryTree",
  //   "body": "struct AuxiliaryTree : Tree {\n  vector<vector<ll>> g;\n  vector<ll> id, inv;\n  AuxiliaryTree(const vector<vector<ll>> &g, ll r = 0): Tree(g, r), inv(g.size()) {}\n  int build(const vector<ll> &v) {\n    int N = v.size();\n    g.assign(N, vector<ll>());\n    id = v;\n    ranges::sort(id, [&](auto x, auto y) { return (*this).in(x) < (*this).in(y); });\n    stack<int> s;\n    s.emplace(id[0]);\n    inv[id[0]] = 0;\n    for(int i = 0; i < N - 1; i++) {\n      int u = (*this).lca(id[i], id[i + 1]);\n      if(u != id[i]) {\n        int p = inv[s.top()];\n        while(true) {\n          s.pop();\n          if(s.empty() || (*this).depth(u) >= (*this).depth(s.top())) { break; }\n          int tmp = inv[s.top()];\n          g[tmp].emplace_back(p);\n          p = tmp;\n        }\n        if(s.empty() || s.top() != u) {\n          s.emplace(u);\n          id.emplace_back(u);\n          inv[u] = g.size();\n          g.push_back({p});\n        }\n        else { g[inv[u]].emplace_back(p); }\n      }\n      s.emplace(id[i + 1]);\n      inv[id[i + 1]] = i + 1;\n    }\n    int p = ((s.size() > 1) ? inv[s.top()] : -1);\n    while(s.size() > 1) {\n      s.pop();\n      int tmp = inv[s.top()];\n      g[tmp].emplace_back(p);\n      p = tmp;\n    }\n    return inv[s.top()];\n  }\n  ll size() { return g.size(); }\n  inline vector<ll> operator[](ll i) { return g[i]; }\n  inline ll operator()(ll i) { return id[i]; }\n};"
  // },
  // "CompressedBIT": {
  //   "prefix": "CompressedBIT",
  //   "body": "template<typename S, typename T> struct CompressedBIT {\n private:\n  fenwick_tree<T> f;\n  vector<S> p;\n  int id(S x) const { return ranges::lower_bound(p, x) - p.begin(); }\n\n public:\n  CompressedBIT() = default;\n  CompressedBIT(int N) { p.reserve(N); }\n  void use(S x) { p.emplace_back(x); }\n  void build() {\n    ranges::sort(p);\n    p.erase(unique(p.begin(), p.end()), p.end());\n    f = fenwick_tree<T>(p.size());\n  }\n  void add(S i, T x) { f.add(id(i), x); }\n  T sum(S l, S r) { return f.sum(id(l), id(r)); }\n};"
  // },
  "compressedBIT": {
    "prefix": "compressedBIT",
    "body": "CompressedBIT<ll,ll> B;"
  },
  // "CompressedSegTree": {
  //   "prefix": "CompressedSegTree",
  //   "body": "template<typename T, typename S, auto op, auto e> struct CompressedSegTree {\n private:\n  segtree<S, op, e> seg;\n  vector<T> p;\n  int id(T x) { return ranges::lower_bound(p, x) - p.begin(); }\n\n public:\n  CompressedSegTree() = default;\n  CompressedSegTree(int N) { p.reserve(N); }\n  void use(ll x) { p.emplace_back(x); }\n  void build() {\n    ranges::sort(p);\n    p.erase(unique(p.begin(), p.end()), p.end());\n    seg = segtree<S, op, e>(p.size());\n  }\n  void set(T i, S x) { seg.set(id(i), x); }\n  S get(T i) { return seg.get(id(i)); }\n  S prod(T l, T r) { return seg.prod(id(l), id(r)); }\n  S all_prod() { return seg.all_prod(); }\n  template<auto f> int max_right(T l) {\n    return seg.max_right(id(l), [](S x) { return f(x); });\n  }\n  template<auto f> int min_left(T r) {\n    return seg.min_left(id(r), [](S x) { return f(x); });\n  }\n};"
  // },
  "compressedSegTree": {
    "prefix": "compressedSegTree",
    "body": "CompressedSegTree<ll,S,op,e> seg;"
  },
  // "CompressedLazySegTree": {
  //   "prefix": "CompressedLazySegTree",
  //   "body": "template<typename T, typename S, auto op, auto e, typename F, auto fx, auto fg, auto id> struct CompressedLazySegTree {\n private:\n  lazy_segtree<S, op, e, F, fx, fg, id> seg;\n  vector<T> p;\n  int idx(T x) { return ranges::lower_bound(p, x) - p.begin(); }\n\n public:\n  CompressedLazySegTree() = default;\n  CompressedLazySegTree(int N) { p.reserve(N); }\n  void use(T x) { p.emplace_back(x); }\n  void build() {\n    ranges::sort(p);\n    p.erase(unique(p.begin(), p.end()), p.end());\n    seg = lazy_segtree<S, op, e, F, fx, fg, id>(p.size());\n  }\n  void set(T i, S x) { seg.set(idx(i), x); }\n  S get(T i) { return seg.get(idx(i)); }\n  S prod(T l, T r) { return seg.prod(idx(l), idx(r)); }\n  S all_prod() { return seg.all_prod(); }\n  void apply(T i, F f) { seg.apply(idx(i), f); }\n  void apply(T l, T r, F f) { seg.apply(idx(l), idx(r), f); }\n  template<auto f> int max_right(T l) {\n    return seg.max_right(idx(l), [](S x) { return f(x); });\n  }\n  template<auto f> int min_left(T r) {\n    return seg.min_left(idx(r), [](S x) { return f(x); });\n  }\n};"
  // },
  "compressedLazySegTree": {
    "prefix": "compressedLazySegTree",
    "body": "CompressedLazySegTree<ll,S,op,e,F,fx,fg,id> seg;"
  },
  // "RequireIn": {
  //   "prefix": "RequireIn",
  //   "body": "template<typename T> int RequireIn(vector<vector<T>> &g_) {\n  int N = g_.size();\n  scc_graph s(N);\n  vector<vector<int>> g(N);\n  for(int i = 0; i < N; i++) {\n    for(auto &j : g_[i]) {\n      s.add_edge(i, j);\n      g[j].emplace_back(i);\n    }\n  }\n  auto scc = s.scc();\n  for(auto &i : scc) { ranges::sort(i); }\n  int r = 0;\n  for(auto &i : scc) {\n    bool in = false;\n    for(auto &j : i) {\n      for(auto &k : g[j]) {\n        if(!ranges::binary_search(i, k)) {\n          in = true;\n          break;\n        }\n      }\n      if(in) { break; }\n    }\n    if(!in) { r++; }\n  }\n  return r;\n}"
  // },
  // "Palindrome": {
  //   "prefix": "Palindrome",
  //   "body": "template<typename T> vector<int> Manacher(const T &S) {\n  const int N = S.size();\n  vector<int> r(N);\n  int i = 0, j = 0;\n  while(i < N) {\n    while(i - j >= 0 && i + j < N && S[i - j] == S[i + j]) { j++; }\n    r[i] = j;\n    int k = 1;\n    while(i - k >= 0 && i + k < N && k + r[i - k] < j) {\n      r[i + k] = r[i - k];\n      k++;\n    }\n    i += k;\n    j -= k;\n  }\n  return r;\n}\n\ntemplate<typename T> vector<pair<int, int>> WidestPalindrome(const T &vec) {\n  using U = typename T::value_type;\n  vector<U> v;\n  const int N = vec.size();\n  for(int i = 0; i < N - 1; i++) {\n    v.emplace_back(vec[i]);\n    v.emplace_back(-1);\n  }\n  v.emplace_back(vec.back());\n  const auto m = Manacher(v);\n  vector<pair<int, int>> r;\n  for(int i = 0; i < N * 2 - 1; i++) {\n    if(i & 1) {\n      int w = m[i] / 2;\n      r.emplace_back((i + 1) / 2 - w, (i + 1) / 2 + w);\n    }\n    else {\n      int w = (m[i] - 1) / 2;\n      r.emplace_back(i / 2 - w, i / 2 + w + 1);\n    }\n  }\n  return r;\n}\n\ntemplate<typename T> vector<int> LeftmostPalindrome(const T &vec) {\n  const int N = vec.size();\n  vector<int> v(N, -1);\n  for(auto &[l, r] : WidestPalindrome(vec)) { v[r - 1] = max(v[r - 1], r - l); }\n  for(int i = N - 2; i >= 0; i--) { v[i] = max(v[i], v[i + 1] - 2); }\n  vector<int> r(N);\n  for(int i = 0; i < N; i++) { r[i] = i + 1 - v[i]; }\n  return r;\n}"
  // },
  // "SegTreeBeats": {
  //   "prefix": "SegTreeBeats",
  //   "body": "struct SegTreeBeats {\n private:\n  static constexpr ll INF = numeric_limits<ll>::max() / 2.1;\n  struct alignas(32) Node {\n    ll sum = 0, add = 0;\n    ll g1 = 0, g2 = -INF, gc = 1;\n    ll l1 = 0, l2 = INF, lc = 1;\n  };\n\n  vector<Node> v;\n  ll n, log;\n\n  void update(int k) {\n    Node &p = v[k], &l = v[k * 2], &r = v[k * 2 + 1];\n    p.sum = l.sum + r.sum;\n    if(l.g1 == r.g1) {\n      p.g1 = l.g1;\n      p.g2 = max(l.g2, r.g2);\n      p.gc = l.gc + r.gc;\n    }\n    else {\n      bool f = l.g1 > r.g1;\n      p.g1 = f ? l.g1 : r.g1;\n      p.gc = f ? l.gc : r.gc;\n      p.g2 = max(f ? r.g1 : l.g1, f ? l.g2 : r.g2);\n    }\n    if(l.l1 == r.l1) {\n      p.l1 = l.l1;\n      p.l2 = min(l.l2, r.l2);\n      p.lc = l.lc + r.lc;\n    }\n    else {\n      bool f = l.l1 < r.l1;\n      p.l1 = f ? l.l1 : r.l1;\n      p.lc = f ? l.lc : r.lc;\n      p.l2 = min(f ? r.l1 : l.l1, f ? l.l2 : r.l2);\n    }\n  }\n  void push_add(int k, ll x) {\n    Node &p = v[k];\n    p.sum += x << (log + __builtin_clz(k) - 31);\n    p.g1 += x;\n    p.l1 += x;\n    if(p.g2 != -INF) { p.g2 += x; }\n    if(p.l2 != INF) { p.l2 += x; }\n    p.add += x;\n  }\n  void push_min(int k, ll x) {\n    Node &p = v[k];\n    p.sum += (x - p.g1) * p.gc;\n    if(p.l1 == p.g1) { p.l1 = x; }\n    if(p.l2 == p.g1) { p.l2 = x; }\n    p.g1 = x;\n  }\n  void push_max(int k, ll x) {\n    Node &p = v[k];\n    p.sum += (x - p.l1) * p.lc;\n    if(p.g1 == p.l1) { p.g1 = x; }\n    if(p.g2 == p.l1) { p.g2 = x; }\n    p.l1 = x;\n  }\n  void push(int k) {\n    Node &p = v[k];\n    if(p.add) {\n      push_add(k * 2, p.add);\n      push_add(k * 2 + 1, p.add);\n      p.add = 0;\n    }\n    if(p.g1 < v[k * 2].g1) { push_min(k * 2, p.g1); }\n    if(p.l1 > v[k * 2].l1) { push_max(k * 2, p.l1); }\n    if(p.g1 < v[k * 2 + 1].g1) { push_min(k * 2 + 1, p.g1); }\n    if(p.l1 > v[k * 2 + 1].l1) { push_max(k * 2 + 1, p.l1); }\n  }\n  void subtree_chmin(int k, ll x) {\n    if(v[k].g1 <= x) { return; }\n    if(v[k].g2 < x) {\n      push_min(k, x);\n      return;\n    }\n    push(k);\n    subtree_chmin(k * 2, x);\n    subtree_chmin(k * 2 + 1, x);\n    update(k);\n  }\n  void subtree_chmax(int k, ll x) {\n    if(x <= v[k].l1) { return; }\n    if(x < v[k].l2) {\n      push_max(k, x);\n      return;\n    }\n    push(k);\n    subtree_chmax(k * 2, x);\n    subtree_chmax(k * 2 + 1, x);\n    update(k);\n  }\n  template<int cmd> inline void apply(int k, ll x) {\n    if constexpr(cmd == 1) { subtree_chmin(k, x); }\n    if constexpr(cmd == 2) { subtree_chmax(k, x); }\n    if constexpr(cmd == 3) { push_add(k, x); }\n    if constexpr(cmd == 4) {\n      subtree_chmax(k, x);\n      subtree_chmax(k, x);\n    }\n  }\n  template<int cmd> void apply(int l, int r, ll x) {\n    if(l == r) { return; }\n    l += n, r += n;\n    for(int i = log; i >= 1; i--) {\n      if(((l >> i) << i) != l) { push(l >> i); }\n      if(((r >> i) << i) != r) { push((r - 1) >> i); }\n    }\n    {\n      int l2 = l, r2 = r;\n      while(l < r) {\n        if(l & 1) { apply<cmd>(l++, x); }\n        if(r & 1) { apply<cmd>(--r, x); }\n        l >>= 1;\n        r >>= 1;\n      }\n      l = l2, r = r2;\n    }\n    for(int i = 1; i <= log; i++) {\n      if(((l >> i) << i) != l) { update(l >> i); }\n      if(((r >> i) << i) != r) { update((r - 1) >> i); }\n    }\n  }\n  template<int cmd> inline ll e() {\n    if constexpr(cmd == 1) { return INF; }\n    if constexpr(cmd == 2) { return -INF; }\n    return 0;\n  }\n  template<int cmd> inline void op(ll &a, const Node &b) {\n    if constexpr(cmd == 1) { a = min(a, b.l1); }\n    if constexpr(cmd == 2) { a = max(a, b.g1); }\n    if constexpr(cmd == 3) { a += b.sum; }\n  }\n  template<int cmd> ll prod(int l, int r) {\n    if(l == r) { return e<cmd>(); }\n    l += n, r += n;\n    for(int i = log; i >= 1; i--) {\n      if(((l >> i) << i) != l) { push(l >> i); }\n      if(((r >> i) << i) != r) { push((r - 1) >> i); }\n    }\n    ll lx = e<cmd>(), rx = e<cmd>();\n    while(l < r) {\n      if(l & 1) { op<cmd>(lx, v[l++]); }\n      if(r & 1) { op<cmd>(rx, v[--r]); }\n      l >>= 1;\n      r >>= 1;\n    }\n    if constexpr(cmd == 1) { lx = min(lx, rx); }\n    if constexpr(cmd == 2) { lx = max(lx, rx); }\n    if constexpr(cmd == 3) { lx += rx; }\n    return lx;\n  }\n\n public:\n  SegTreeBeats() {}\n  SegTreeBeats(int N): SegTreeBeats(vector<ll>(N)) {}\n  SegTreeBeats(const vector<ll> &vc): n(1), log(0) {\n    while(n < ssize(vc)) {\n      n <<= 1;\n      log++;\n    }\n    v.resize(2 * n);\n    for(ll i = 0; i < ssize(vc); i++) { v[i + n].sum = v[i + n].g1 = v[i + n].l1 = vc[i]; }\n    for(ll i = n - 1; i; i--) { update(i); }\n  }\n\n  void chmin(int l, int r, ll x) { apply<1>(l, r, x); }\n  void chmax(int l, int r, ll x) { apply<2>(l, r, x); }\n  void add(int l, int r, ll x) { apply<3>(l, r, x); }\n  void update(int l, int r, ll x) { apply<4>(l, r, x); }\n  ll getmin(int l, int r) { return prod<1>(l, r); }\n  ll getmax(int l, int r) { return prod<2>(l, r); }\n  ll getsum(int l, int r) { return prod<3>(l, r); }\n};"
  // },
  // "Lazy_add/or_max/and/or": {
  //   "prefix": "Lazy_add/or_max/and/or",
  //   "body": "template<class S, auto op, auto e, class F, auto mapping, auto composition, auto id> struct lazy_segtree {\n public:\n  lazy_segtree(): lazy_segtree(0) {}\n  explicit lazy_segtree(int n): lazy_segtree(vector<S>(n, e())) {}\n  explicit lazy_segtree(const vector<S> &v): _n(int(v.size())) {\n    size = (int)bit_ceil((unsigned int)(_n));\n    log = countr_zero((unsigned int)size);\n    d = vector<S>(2 * size, e());\n    lz = vector<F>(size, id());\n    for(int i = 0; i < _n; i++) { d[size + i] = v[i]; }\n    for(int i = size - 1; i >= 1; i--) { update(i); }\n  }\n  void set(int p, S x) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for(int i = log; i >= 1; i--) { push(p >> i); }\n    d[p] = x;\n    for(int i = 1; i <= log; i++) { update(p >> i); }\n  }\n  S get(int p) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for(int i = log; i >= 1; i--) { push(p >> i); }\n    return d[p];\n  }\n  S prod(int l, int r) {\n    assert(0 <= l && l <= r && r <= _n);\n    if(l == r) { return e(); }\n    l += size;\n    r += size;\n    for(int i = log; i >= 1; i--) {\n      if(((l >> i) << i) != l) { push(l >> i); }\n      if(((r >> i) << i) != r) { push((r - 1) >> i); }\n    }\n    S sml = e(), smr = e();\n    while(l < r) {\n      if(l & 1) { sml = op(sml, d[l++]); }\n      if(r & 1) { smr = op(d[--r], smr); }\n      l >>= 1;\n      r >>= 1;\n    }\n    return op(sml, smr);\n  }\n  S all_prod() { return d[1]; }\n  void apply(int p, F f) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for(int i = log; i >= 1; i--) { push(p >> i); }\n    d[p] = mapping(f, d[p]);\n    for(int i = 1; i <= log; i++) { update(p >> i); }\n  }\n  void apply(int l, int r, F f) {\n    assert(0 <= l && l <= r && r <= _n);\n    if(l == r) return;\n    l += size;\n    r += size;\n    for(int i = log; i >= 1; i--) {\n      if(((l >> i) << i) != l) { push(l >> i); }\n      if(((r >> i) << i) != r) { push((r - 1) >> i); }\n    }\n    {\n      int l2 = l, r2 = r;\n      while(l < r) {\n        if(l & 1) { all_apply(l++, f); }\n        if(r & 1) { all_apply(--r, f); }\n        l >>= 1;\n        r >>= 1;\n      }\n      l = l2;\n      r = r2;\n    }\n    for(int i = 1; i <= log; i++) {\n      if(((l >> i) << i) != l) { update(l >> i); }\n      if(((r >> i) << i) != r) { update((r - 1) >> i); }\n    }\n  }\n  template<bool (*g)(S)> int max_right(int l) {\n    return max_right(l, [](S x) { return g(x); });\n  }\n  template<class G> int max_right(int l, G g) {\n    assert(0 <= l && l <= _n);\n    assert(g(e()));\n    if(l == _n) { return _n; }\n    l += size;\n    for(int i = log; i >= 1; i--) { push(l >> i); }\n    S sm = e();\n    do {\n      while(l % 2 == 0) l >>= 1;\n      if(!g(op(sm, d[l]))) {\n        while(l < size) {\n          push(l);\n          l = (2 * l);\n          if(g(op(sm, d[l]))) {\n            sm = op(sm, d[l]);\n            l++;\n          }\n        }\n        return l - size;\n      }\n      sm = op(sm, d[l]);\n      l++;\n    } while((l & -l) != l);\n    return _n;\n  }\n  template<bool (*g)(S)> int min_left(int r) {\n    return min_left(r, [](S x) { return g(x); });\n  }\n  template<class G> int min_left(int r, G g) {\n    assert(0 <= r && r <= _n);\n    assert(g(e()));\n    if(r == 0) { return 0; }\n    r += size;\n    for(int i = log; i >= 1; i--) { push((r - 1) >> i); }\n    S sm = e();\n    do {\n      r--;\n      while(r > 1 && (r % 2)) r >>= 1;\n      if(!g(op(d[r], sm))) {\n        while(r < size) {\n          push(r);\n          r = (2 * r + 1);\n          if(g(op(d[r], sm))) {\n            sm = op(d[r], sm);\n            r--;\n          }\n        }\n        return r + 1 - size;\n      }\n      sm = op(d[r], sm);\n    } while((r & -r) != r);\n    return 0;\n  }\n\n private:\n  int _n, size, log;\n  vector<S> d;\n  vector<F> lz;\n  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n  void all_apply(int k, F f) {\n    d[k] = mapping(f, d[k]);\n    if(k < size) {\n      lz[k] = composition(f, lz[k]);\n      if(d[k].fail) { push(k), update(k); }\n    }\n  }\n  void push(int k) {\n    all_apply(2 * k, lz[k]);\n    all_apply(2 * k + 1, lz[k]);\n    lz[k] = id();\n  }\n};\n\nusing ull = unsigned long long;\nconstexpr ull dig = 60, mask = (1ULL << dig) - 1;\n\nstruct S {\n  ull max, range_or, range_and;\n  bool fail;\n  S(ull x = 0): max(x), range_or(x), range_and(x), fail(false) {}\n};\nstruct F {\n  ull bit_and, bit_or;\n  F(): bit_and(mask), bit_or(0) {}\n  F(ull a, ull o): bit_and(a), bit_or(o) {}\n  static F b_and(ull x) noexcept { return {x, 0}; }\n  static F b_or(ull x) noexcept { return {mask, x}; }\n};\nS op(S l, S r) {\n  l.max = max(l.max, r.max);\n  l.range_or |= r.range_or;\n  l.range_and &= r.range_and;\n  return l;\n}\nS e() { return S(); }\nS fx(F f, S x) {\n  if((x.range_or - x.range_and) & (~f.bit_and | f.bit_or)) {\n    x.fail = true;\n    return x;\n  }\n  x.range_or = (x.range_or & f.bit_and) | f.bit_or;\n  x.range_and = (x.range_and & f.bit_and) | f.bit_or;\n  x.max = (x.max & f.bit_and) | f.bit_or;\n  return x;\n}\nF fg(F f, F g) { return F{f.bit_and & g.bit_and, f.bit_or | g.bit_or}; }\nF id() { return F(); }"
  // },
  // "Lazy_update/gcd_max/sum": {
  //   "prefix": "Lazy_update/gcd_max/sum",
  //   "body": "template<class S, auto op, auto e, class F, auto mapping, auto composition, auto id> struct lazy_segtree {\n public:\n  lazy_segtree(): lazy_segtree(0) {}\n  explicit lazy_segtree(int n): lazy_segtree(vector<S>(n, e())) {}\n  explicit lazy_segtree(const vector<S> &v): _n(int(v.size())) {\n    size = (int)bit_ceil((unsigned int)(_n));\n    log = countr_zero((unsigned int)size);\n    d = vector<S>(2 * size, e());\n    lz = vector<F>(size, id());\n    for(int i = 0; i < _n; i++) { d[size + i] = v[i]; }\n    for(int i = size - 1; i >= 1; i--) { update(i); }\n  }\n  void set(int p, S x) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for(int i = log; i >= 1; i--) { push(p >> i); }\n    d[p] = x;\n    for(int i = 1; i <= log; i++) { update(p >> i); }\n  }\n  S get(int p) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for(int i = log; i >= 1; i--) { push(p >> i); }\n    return d[p];\n  }\n  S prod(int l, int r) {\n    assert(0 <= l && l <= r && r <= _n);\n    if(l == r) { return e(); }\n    l += size;\n    r += size;\n    for(int i = log; i >= 1; i--) {\n      if(((l >> i) << i) != l) { push(l >> i); }\n      if(((r >> i) << i) != r) { push((r - 1) >> i); }\n    }\n    S sml = e(), smr = e();\n    while(l < r) {\n      if(l & 1) { sml = op(sml, d[l++]); }\n      if(r & 1) { smr = op(d[--r], smr); }\n      l >>= 1;\n      r >>= 1;\n    }\n    return op(sml, smr);\n  }\n  S all_prod() { return d[1]; }\n  void apply(int p, F f) {\n    assert(0 <= p && p < _n);\n    p += size;\n    for(int i = log; i >= 1; i--) { push(p >> i); }\n    d[p] = mapping(f, d[p]);\n    for(int i = 1; i <= log; i++) { update(p >> i); }\n  }\n  void apply(int l, int r, F f) {\n    assert(0 <= l && l <= r && r <= _n);\n    if(l == r) return;\n    l += size;\n    r += size;\n    for(int i = log; i >= 1; i--) {\n      if(((l >> i) << i) != l) { push(l >> i); }\n      if(((r >> i) << i) != r) { push((r - 1) >> i); }\n    }\n    {\n      int l2 = l, r2 = r;\n      while(l < r) {\n        if(l & 1) { all_apply(l++, f); }\n        if(r & 1) { all_apply(--r, f); }\n        l >>= 1;\n        r >>= 1;\n      }\n      l = l2;\n      r = r2;\n    }\n    for(int i = 1; i <= log; i++) {\n      if(((l >> i) << i) != l) { update(l >> i); }\n      if(((r >> i) << i) != r) { update((r - 1) >> i); }\n    }\n  }\n  template<bool (*g)(S)> int max_right(int l) {\n    return max_right(l, [](S x) { return g(x); });\n  }\n  template<class G> int max_right(int l, G g) {\n    assert(0 <= l && l <= _n);\n    assert(g(e()));\n    if(l == _n) { return _n; }\n    l += size;\n    for(int i = log; i >= 1; i--) { push(l >> i); }\n    S sm = e();\n    do {\n      while(l % 2 == 0) l >>= 1;\n      if(!g(op(sm, d[l]))) {\n        while(l < size) {\n          push(l);\n          l = (2 * l);\n          if(g(op(sm, d[l]))) {\n            sm = op(sm, d[l]);\n            l++;\n          }\n        }\n        return l - size;\n      }\n      sm = op(sm, d[l]);\n      l++;\n    } while((l & -l) != l);\n    return _n;\n  }\n  template<bool (*g)(S)> int min_left(int r) {\n    return min_left(r, [](S x) { return g(x); });\n  }\n  template<class G> int min_left(int r, G g) {\n    assert(0 <= r && r <= _n);\n    assert(g(e()));\n    if(r == 0) { return 0; }\n    r += size;\n    for(int i = log; i >= 1; i--) { push((r - 1) >> i); }\n    S sm = e();\n    do {\n      r--;\n      while(r > 1 && (r % 2)) r >>= 1;\n      if(!g(op(d[r], sm))) {\n        while(r < size) {\n          push(r);\n          r = (2 * r + 1);\n          if(g(op(d[r], sm))) {\n            sm = op(d[r], sm);\n            r--;\n          }\n        }\n        return r + 1 - size;\n      }\n      sm = op(d[r], sm);\n    } while((r & -r) != r);\n    return 0;\n  }\n\n private:\n  int _n, size, log;\n  vector<S> d;\n  vector<F> lz;\n  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n  void all_apply(int k, F f) {\n    d[k] = mapping(f, d[k]);\n    if(k < size) {\n      lz[k] = composition(f, lz[k]);\n      if(d[k].fail) { push(k), update(k); }\n    }\n  }\n  void push(int k) {\n    all_apply(2 * k, lz[k]);\n    all_apply(2 * k + 1, lz[k]);\n    lz[k] = id();\n  }\n};\n\nconstexpr ll INF = 2e9;\nstruct S {\n  ll max, lcm, sz, sum;\n  bool fail;\n  S(): max(0), lcm(1), sz(0), sum(0), fail(false) {}\n  S(ll x, ll sz = 1): max(x), lcm(x), sz(sz), sum(x * sz), fail(false) {}\n};\nstruct F {\n  ll g, upd;\n  F(): g(0), upd(0) {}\n  F(ll g, ll upd): g(g), upd(upd) {}\n  static F gcd(ll x) noexcept { return F(x, 0); }\n  static F update(ll x) noexcept { return F(0, x); }\n};\nS op(S l, S r) {\n  if(!r.sz) { return l; }\n  if(!l.sz) { return r; }\n  S ret;\n  ret.max = std::max(l.max, r.max);\n  ret.sum = l.sum + r.sum;\n  ret.lcm = min(INF, std::lcm(l.lcm, r.lcm));\n  ret.sz = l.sz + r.sz;\n  return ret;\n}\nS e() { return S(); }\nS fx(F f, S x) {\n  if(x.fail) { return x; }\n  if(f.upd) { x = S(f.upd, x.sz); }\n  if(f.g) {\n    if(x.sz * x.max == x.sum) { x = S(gcd(x.max, f.g), x.sz); }\n    else if(x.lcm == INF || f.g % x.lcm) { x.fail = true; }\n  }\n  return x;\n}\nF fg(F f, F g) {\n  if(f.upd) { return F::update(f.upd); }\n  else if(g.upd) { return F::update(gcd(f.g, g.upd)); }\n  else { return F::gcd(gcd(f.g, g.g)); }\n}\nF id() { return F(); }"
  // },
  // "CentroidDecomposition": {
  //   "prefix": "CentroidDecomposition",
  //   "body": "struct CentroidDecomposition {\n private:\n  const vector<vector<ll>> &g;\n  vector<int> sub;\n  vector<bool> vis;\n  vector<vector<int>> tree;\n  int root;\n  int get_size(int v, int p) {\n    sub[v] = 1;\n    for(auto &nv : g[v]) {\n      if(nv == p || vis[nv]) { continue; }\n      sub[v] += get_size(nv, v);\n    }\n    return sub[v];\n  }\n  int get_centroid(int v, int p, int mid) {\n    for(auto &nv : g[v]) {\n      if(nv == p || vis[nv]) { continue; }\n      if(sub[nv] > mid) { return get_centroid(nv, v, mid); }\n    }\n    return v;\n  }\n  int dfs(int v) {\n    int centroid = get_centroid(v, -1, get_size(v, -1) / 2);\n    vis[centroid] = true;\n    for(auto &nv : g[centroid]) {\n      if(!vis[nv]) {\n        int nxt = dfs(nv);\n        if(centroid != nxt) { tree[centroid].emplace_back(nxt); }\n      }\n    }\n    vis[centroid] = false;\n    return centroid;\n  }\n\n public:\n  CentroidDecomposition(const vector<vector<ll>> &g): g(g), sub(g.size(), 0), vis(g.size(), false), tree(g.size()) {}\n  int build() { return root = dfs(0); }\n  inline vector<int> operator[](ll i) { return tree[i]; }\n};"
  // },
  // "DualSegTree": {
  //   "prefix": "DualSegTree",
  //   "body": "template<typename S, auto op, auto e> struct DualSegTree {\n  vector<S> seg;\n  int N, size = 1;\n  DualSegTree(int n): DualSegTree(vector<S>(n, e())) {}\n  DualSegTree(const vector<S> &v): N(v.size()) {\n    while(size < N) { size <<= 1; }\n    seg = vector<S>(size * 2, e());\n    for(int i = 0; i < N; i++) { seg[size + i] = v[i]; }\n  }\n  void set(int i, const S &x) {\n    i += size;\n    for(int h = bit_width((unsigned)i); h; h--) {\n      int j = i >> h;\n      if(seg[j] != e()) {\n        seg[j * 2] = op(seg[j * 2], seg[j]);\n        seg[j * 2 + 1] = op(seg[j * 2 + 1], seg[j]);\n        seg[j] = e();\n      }\n    }\n    seg[i] = x;\n  }\n  S get(int i) {\n    S r = e();\n    for(i += size; i; i >>= 1) { r = op(r, seg[i]); }\n    return r;\n  }\n  void apply(int l, int r, const S &x) {\n    for(l += size, r += size; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) { seg[l++] = op(seg[l], x); }\n      if(r & 1) { seg[r] = op(seg[--r], x); }\n    }\n  }\n};"
  // },
  "dualsegtree": {
    "prefix": "dualsegtree",
    "body": "DualSegTree<S,op,e> seg($0);"
  },
  // "ErasablePriorityQueue": {
  //   "prefix": "ErasablePriorityQueue",
  //   "body": "template<typename T, typename Compare> struct ErasablePriorityQueue {\n  priority_queue<T, vector<T>, Compare> q1, q2;\n  ErasablePriorityQueue() {}\n  ErasablePriorityQueue(initializer_list<T> ini): q1(ini.begin(), ini.end()) {}\n  void push(T x) { q1.emplace(x); }\n  void erase(T x) {\n    if(!q1.empty() && q1.top() == x) {\n      q1.pop();\n      while(!q2.empty() && q1.top() == q2.top()) {\n        q1.pop();\n        q2.pop();\n      }\n    }\n    else { q2.emplace(x); }\n  }\n  T top() const { return q1.top(); }\n  int size() const { return q1.size() - q2.size(); }\n  bool empty() const { return q1.empty(); }\n};"
  // },
  "ErasablePQ": {
    "prefix": "ErasablePQ",
    "body": "ErasablePriorityQueue<${1:ll}, greater<${1:ll}>> $0"
  },
  "ErasableQP": {
    "prefix": "ErasableQP",
    "body": "ErasablePriorityQueue<${1:ll}, less<${1:ll}>> $0"
  },
  // "DynamicSegTree": {
  //   "prefix": "DynamicSegTree",
  //   "body": "template<typename S, auto op, auto e, int n> struct DynamicSegTree {\n private:\n  struct Node;\n  using Node_ptr = unique_ptr<Node>;\n  struct Node {\n    int idx;\n    S val, prod;\n    Node_ptr l, r;\n    Node(int idx, S val): idx(idx), val(val), prod(val), l(nullptr), r(nullptr) {}\n    void update() { prod = op(op(l ? l->prod : e(), val), r ? r->prod : e()); }\n  };\n  Node_ptr root;\n  void set(Node_ptr &t, int a, int b, int p, S x) const {\n    if(!t) {\n      t = make_unique<Node>(p, x);\n      return;\n    }\n    if(t->idx == p) {\n      t->val = x;\n      t->update();\n      return;\n    }\n    int c = (a + b) >> 1;\n    if(p < c) {\n      if(t->idx < p) {\n        swap(t->idx, p);\n        swap(t->val, x);\n      }\n      set(t->l, a, c, p, x);\n    }\n    else {\n      if(t->idx > p) {\n        swap(t->idx, p);\n        swap(t->val, x);\n      }\n      set(t->r, c, b, p, x);\n    }\n    t->update();\n  }\n  S get(const Node_ptr &t, int a, int b, int p) const {\n    if(!t) { return e(); }\n    if(t->idx == p) { return t->val; }\n    int c = (a + b) >> 1;\n    if(p < c) { return get(t->l, a, c, p); }\n    else { return get(t->r, c, b, p); }\n  }\n  S prod(const Node_ptr &t, int a, int b, int l, int r) const {\n    if(!t || b <= l || r <= a) { return e(); }\n    if(l <= a && b <= r) { return t->prod; }\n    int c = (a + b) >> 1;\n    S res = prod(t->l, a, c, l, r);\n    if(l <= t->idx && t->idx < r) { res = op(res, t->val); }\n    return op(res, prod(t->r, c, b, l, r));\n  }\n  void reset(Node_ptr &t, int a, int b, int l, int r) const {\n    if(!t || b <= l || r <= a) { return; }\n    if(l <= a && b <= r) {\n      t->reset();\n      return;\n    }\n    int c = (a + b) >> 1;\n    reset(t->l, a, c, l, r);\n    reset(t->r, c, b, l, r);\n    t->update();\n  }\n  template<typename F> int max_right(const Node_ptr &t, int a, int b, int l, const F &f, S &p) const {\n    if(!t || b <= l) { return n; }\n    if(f(op(p, t->prod))) {\n      p = op(p, t->prod);\n      return n;\n    }\n    int c = (a + b) >> 1;\n    int res = max_right(t->l, a, c, l, f, p);\n    if(res != n) { return res; }\n    if(l <= t->idx) {\n      p = op(p, t->val);\n      if(!f(p)) { return t->idx; }\n    }\n    return max_right(t->r, c, b, l, f, p);\n  }\n  template<typename F> int min_left(const Node_ptr &t, int a, int b, int r, const F &f, S &p) const {\n    if(!t || r <= a) { return 0; }\n    if(f(op(p, t->prod))) {\n      p = op(p, t->prod);\n      return 0;\n    }\n    int c = (a + b) >> 1;\n    int res = min_left(t->r, c, b, r, f, p);\n    if(res) { return res; }\n    if(t->idx < r) {\n      p = op(p, t->val);\n      if(!f(p)) { return t->idx + 1; }\n    }\n    return min_left(t->l, a, c, r, f, p);\n  }\n\n public:\n  DynamicSegTree(): root(nullptr) {}\n  void set(int i, S x) { set(root, 0, n, i, x); }\n  S get(int i) const { return get(root, 0, n, i); }\n  S prod(int l, int r) const { return prod(root, 0, n, l, r); }\n  S all_prod() const { return root ? root->prod : e(); }\n  void reset(int l, int r) { reset(root, 0, n, l, r); }\n  template<auto f> int max_right(int l) const {\n    return max_right(l, [](S x) { return f(x); });\n  }\n  template<typename F> int max_right(int l, const F &f) const {\n    S p = e();\n    return max_right(root, 0, n, l, f, p);\n  }\n  template<auto f> int min_left(int r) const {\n    return min_left(r, [](S x) { return f(x); });\n  }\n  template<typename F> int min_left(int r, const F &f) const {\n    S p = e();\n    return min_left(root, 0, n, r, f, p);\n  }\n};"
  // },
  "dynamicsegtree": {
    "prefix": "dynamicsegtree",
    "body": "DynamicSegTree<S,op,e,$1> seg;$0"
  },
  "vb": {
    "prefix": "vb",
    "body": "vector<bool> "
  },
  // "DualBIT": {
  //   "prefix": "DualBIT",
  //   "body": "template<typename T> struct DualBIT {\n  fenwick_tree<T> f1, f2;\n  DualBIT(int N): f1(N + 1), f2(N + 1) {}\n  void add(int i, T x) { add(i, i + 1, x); }\n  void add(int l, int r, T x) {\n    f1.add(l, x), f1.add(r, -x);\n    f2.add(l, -x * (l - 1)), f2.add(r, x * (r - 1));\n  }\n  T sum(int i) { return f1.sum(0, i) * (i - 1) + f2.sum(0, i); }\n  T sum(int l, int r) { return sum(r) - sum(l); }\n  T operator[](int i) { return sum(i + 1) - sum(i); }\n};"
  // },
  "dualBIT": {
    "prefix": "dualBIT",
    "body": "DualBIT<ll>"
  },
  // "OfflineDynamicConnectivity": {
  //   "prefix": "OfflineDynamicConnectivity",
  //   "body": "template<typename S, auto op, auto e> struct RollbackUnionfind {\n private:\n  vector<int> par;\n  vector<S> val;\n  stack<tuple<int, int, S, int>> history;\n  int snap, cnt;\n\n public:\n  RollbackUnionfind() = default;\n  RollbackUnionfind(int n): RollbackUnionfind(vector<S>(n, e())) {}\n  RollbackUnionfind(const vector<S> &v): par(v.size(), -1), val(v), snap(0), cnt(v.size()) {}\n  int root(int v) const {\n    if(par[v] < 0) { return v; }\n    return root(par[v]);\n  }\n  void unite(int u, int v) {\n    u = root(u), v = root(v);\n    history.emplace(-1, 0, e(), cnt);\n    history.emplace(u, par[u], val[u], cnt);\n    history.emplace(v, par[v], val[v], cnt);\n    if(u == v) { return; }\n    if(par[u] > par[v]) { swap(u, v); }\n    par[u] += par[v];\n    par[v] = u;\n    val[u] = op(val[u], val[v]);\n    cnt--;\n  }\n  void undo() {\n    assert(!history.empty());\n    while(true) {\n      auto [v, p, x, c] = history.top();\n      history.pop();\n      if(v == -1) { break; }\n      par[v] = p;\n      val[v] = x;\n      cnt = c;\n    }\n  }\n  bool same(int u, int v) const { return root(u) == root(v); }\n  int size(int v) const { return -par[root(v)]; }\n  int count() const { return cnt; }\n  S prod(int v) const { return val[root(v)]; }\n  void update(int v, const S &x) {\n    v = root(v);\n    history.emplace(-1, 0, e(), cnt);\n    history.emplace(v, par[v], val[v], cnt);\n    val[v] = op(val[x], x);\n  }\n  int state() const { return history.size(); }\n  void snapshot() { snap = history.size(); }\n  void rollback(int p = -1) {\n    if(p == -1) { p = snap; }\n    while(p < (int)history.size()) { undo(); }\n  }\n};\n\ntemplate<typename S, auto op, auto e> struct OfflineDynamicConnectivity {\n private:\n  int idx;\n  multimap<pair<int, int>, int> open;\n  vector<tuple<int, int, int, int>> closed;\n  vector<tuple<int, int, S>> query_update;\n  map<int, pair<int, int>> query_same;\n  map<int, int> query_prod, query_size;\n  vector<int> query_count;\n  vector<S> val;\n\n public:\n  OfflineDynamicConnectivity() = default;\n  OfflineDynamicConnectivity(int n): OfflineDynamicConnectivity(vector<S>(n, e())) {}\n  OfflineDynamicConnectivity(const vector<S> &v): val(v), idx(0) {}\n  void unite(int u, int v) {\n    auto edge = minmax(u, v);\n    open.emplace(edge, ++idx);\n  }\n  void cut(int u, int v) {\n    auto edge = minmax(u, v);\n    auto it = open.find(edge);\n    assert(it != open.end());\n    closed.emplace_back(edge.first, edge.second, it->second, ++idx);\n    open.erase(it);\n  }\n  void update(int v, const S &x) { query_update.emplace_back(++idx, v, x); }\n  void same(int u, int v) { query_same[++idx] = {u, v}; }\n  void prod(int v) { query_prod[++idx] = v; }\n  void size(int v) { query_size[++idx] = v; }\n  void count() { query_count.emplace_back(++idx); }\n  vector<pair<int, S>> build() {\n    idx++;\n    for(auto &[edge, s] : open) { closed.emplace_back(edge.first, edge.second, s, idx); }\n    int size = bit_ceil((unsigned)idx);\n    vector<vector<pair<int, int>>> edges(size << 1);\n    vector<vector<pair<int, S>>> updates(size << 1);\n    for(auto &[u, v, s, t] : closed) {\n      for(s += size, t += size; s < t; s >>= 1, t >>= 1) {\n        if(s & 1) { edges[s++].emplace_back(u, v); }\n        if(t & 1) { edges[--t].emplace_back(u, v); }\n      }\n    }\n    for(auto &[s, v, x] : query_update) {\n      int t = size;\n      for(s += size, t += size; s < t; s >>= 1, t >>= 1) {\n        if(s & 1) { updates[s++].emplace_back(v, x); }\n        if(t & 1) { updates[--t].emplace_back(v, x); }\n      }\n    }\n    RollbackUnionfind<S, op, e> uf(val);\n    vector<pair<int, S>> r;\n    auto dfs = [&](auto &&dfs, int k) -> void {\n      for(auto &[u, v] : edges[k]) { uf.unite(u, v); }\n      for(auto &[v, x] : updates[k]) { uf.update(v, x); }\n      if(k < size) {\n        dfs(dfs, 2 * k);\n        dfs(dfs, 2 * k + 1);\n      }\n      else if(k < size + idx) {\n        if(query_same.contains(k - size)) {\n          auto [u, v] = query_same[k - size];\n          r.emplace_back(uf.same(u, v), e());\n        }\n        if(query_prod.contains(k - size)) { r.emplace_back(false, uf.prod(query_prod[k - size])); }\n        if(query_size.contains(k - size)) { r.emplace_back(uf.size(query_size[k - size]), e()); }\n        if(ranges::binary_search(query_count, k - size)) { r.emplace_back(uf.count(), e()); }\n      }\n      for(int i = 0; i < (int)(edges[k].size() + updates[k].size()); i++) { uf.undo(); }\n    };\n    dfs(dfs, 1);\n    return r;\n  }\n};"
  // },
  "offlinedynamicconnectivity": {
    "prefix": "offlinedynamicconnectivity",
    "body": "OfflineDynamicConnectivity<S,op,e> u(N);"
  },
  // "stringcontains": {
  //   "prefix": "stringcontains",
  //   "body": "// return S⊃T\nbool contains(const string &s, const string &t) {\n  int n = s.size(), m = t.size();\n  auto z = z_algorithm(t + s);\n  for(int i = m; i <= n; i++) {\n    if(z[i] >= m) { return true; }\n  }\n  return false;\n}"
  // },
  "TravelingSalesmanProblem": {
    "prefix": "TravelingSalesmanProblem",
    "body": "vector<vector<ll>> dp(1 << N, vector<ll>(N, 1e18));\nfor(int i = 0; i < N; i++) { dp[1 << i][i] = 0; }\nfor(int i = 0; i < 1 << N; i++) {\n  for(int j = 0; j < N; j++) {\n    if(~i >> j & 1) { continue; }\n    for(int k = 0; k < N; k++) {\n      if(i >> k & 1) { continue; }\n      dp[i | 1 << k][k] = min(dp[i | 1 << k][k], dp[i][j] + d[j][k]);\n    }\n  }\n}"
  },
  "fast_set": {
    "prefix": "fast_set",
    "body": "struct fast_set {\n private:\n  static constexpr int B = 64;\n  int n, cnt;\n  vector<vector<uint64_t>> d;\n  static int bsf(uint64_t x) { return __builtin_ctzll(x); }\n  static int bsr(uint64_t x) { return 63 - __builtin_clzll(x); }\n\n public:\n  fast_set(int n): n(n), cnt(0) {\n    do {\n      n = (n + B - 1) / B;\n      d.emplace_back(vector<uint64_t>(n));\n    } while(n > 1);\n  }\n  bool contains(int i) const { return (d[0][i / B] >> (i % B)) & 1; }\n  void insert(int i) {\n    if(contains(i)) { return; }\n    ++cnt;\n    for(auto &v : d) {\n      bool f = v[i / B];\n      v[i / B] |= 1ULL << (i % B);\n      i /= B;\n      if(f) { break; }\n    }\n  }\n  void erase(int i) {\n    if(!contains(i)) { return; }\n    --cnt;\n    for(auto &v : d) {\n      v[i / B] &= ~(1ULL << (i % B));\n      i /= B;\n      if(v[i]) { break; }\n    }\n  }\n  int next(int i) const {\n    for(auto itr = d.cbegin(); itr != d.cend(); ++itr, i = i / B + 1) {\n      if(i / B >= int(itr->size())) { break; }\n      if(auto t = itr->at(i / B) >> (i % B); t) {\n        i += bsf(t);\n        while(itr != d.cbegin()) { i = i * B + bsf((--itr)->at(i)); }\n        return i;\n      }\n    }\n    return n;\n  }\n  int prev(int i) const {\n    for(auto itr = d.cbegin(); itr != d.cend() && i >= 0; ++itr, i = i / B - 1) {\n      if(auto t = itr->at(i / B) << (B - 1 - i % B); t) {\n        i += bsr(t) - (B - 1);\n        while(itr != d.cbegin()) { i = i * B + bsr((--itr)->at(i)); }\n        return i;\n      }\n    }\n    return -1;\n  }\n  int min() const { return next(0); }\n  int max() const { return prev(n - 1); }\n  int size() const { return cnt; }\n  bool empty() const { return cnt == 0; }\n  void clear() {\n    if(!cnt) { return; }\n    cnt = 0;\n    auto rec = [&](auto &&self, int t, int x) -> void {\n      if(t) {\n        for(auto m = d[t][x]; m;) {\n          int i = bsf(m);\n          m -= 1ULL << i;\n          self(self, t - 1, x * B + i);\n        }\n      }\n      d[t][x] = 0;\n    };\n    rec(rec, d.size() - 1, 0);\n  }\n};"
  },
  // "ProjectSelectionProblem": {
  //   "prefix": "ProjectSelectionProblem",
  //   "body": "struct ProjectSelectionProblem {\n  int N, S, G;\n  ll offset;\n  vector<tuple<int, int, ll>> e;\n  mf_graph<ll> g;\n  ProjectSelectionProblem(int n): N(n + 2), S(n), G(n + 1), offset(0) {}\n  void cost0(int i, ll c) { e.emplace_back(i, G, c); }\n  void cost1(int i, ll c) { e.emplace_back(S, i, c); }\n  void get0(int i, ll c) {\n    offset += c;\n    e.emplace_back(S, i, c);\n  }\n  void get1(int i, ll c) {\n    offset += c;\n    e.emplace_back(i, G, c);\n  }\n  void cost01(int i, int j, ll c) { e.emplace_back(i, j, c); }\n  void cost10(int i, int j, ll c) { e.emplace_back(j, i, c); }\n  void get00(int i, int j, ll c) {\n    offset += c;\n    e.emplace_back(S, N, c);\n    e.emplace_back(N, i, 1e18);\n    e.emplace_back(N, j, 1e18);\n    N++;\n  }\n  void get11(int i, int j, ll c) {\n    offset += c;\n    e.emplace_back(N, G, c);\n    e.emplace_back(i, N, 1e18);\n    e.emplace_back(j, N, 1e18);\n    N++;\n  }\n  template<typename T> void getall0(vector<T> &v, ll c) {\n    offset += c;\n    e.emplace_back(S, N, c);\n    for(auto &i : v) { e.emplace_back(N, i, 1e18); }\n    N++;\n  }\n  template<typename T> void getall1(vector<T> &v, ll c) {\n    offset += c;\n    e.emplace_back(N, G, c);\n    for(auto &i : v) { e.emplace_back(i, N, 1e18); }\n    N++;\n  }\n  ll build() {\n    g = mf_graph<ll>(N);\n    for(auto &[s, t, c] : e) { g.add_edge(s, t, c); }\n    return g.flow(S, G) - offset;\n  }\n  vector<bool> restore() {\n    auto r = g.min_cut(S);\n    for(int i = 0; i < N; i++) { r[i] = !r[i]; }\n    return r;\n  }\n};"
  // },
  "projectselectionproblem": {
    "prefix": "projectselectionproblem",
    "body": "ProjectSelectionProblem P(${1:N})"
  },
  // "ManhattanMST": {
  //   "prefix": "ManhattanMST",
  //   "body": "template<typename T> vector<tuple<T, int, int>> ManhattanMST(vector<T> &xs, vector<T> &ys) {\n  const int N = xs.size();\n  vector<int> idx(N);\n  iota(idx.begin(), idx.end(), 0);\n  vector<tuple<T, int, int>> tmp, ret;\n  for(int s = 0; s < 2; s++) {\n    for(int t = 0; t < 2; t++) {\n      ranges::sort(idx, [&](int i, int j) { return xs[i] + ys[i] < xs[j] + ys[j]; });\n      map<T, int> sweep;\n      for(auto &i : idx) {\n        for(auto it = sweep.lower_bound(-ys[i]); it != sweep.end(); it = sweep.erase(it)) {\n          int j = it->second;\n          if(xs[i] - xs[j] < ys[i] - ys[j]) { break; }\n          tmp.emplace_back(abs(xs[i] - xs[j]) + abs(ys[i] - ys[j]), i, j);\n        }\n        sweep[-ys[i]] = i;\n      }\n      swap(xs, ys);\n    }\n    for(auto &x : xs) { x = -x; }\n  }\n  ranges::sort(tmp);\n  dsu u(N);\n  for(auto &[w, a, b] : tmp) {\n    if(u.same(a, b)) { continue; }\n    u.merge(a, b);\n    ret.emplace_back(w, a, b);\n  }\n  return ret;\n}"
  // },
  "manhattanMST": {
    "prefix": "manhattanMST",
    "body": "ManhattanMST(${1:g})"
  },
  // "DequeAggregation": {
  //   "prefix": "DequeAggregation",
  //   "body": "template<typename T, auto op, auto e> struct DequeAggregation {\n private:\n  vector<T> a0, a1, r0, r1;\n  T get0() const { return r0.empty() ? e() : r0.back(); }\n  T get1() const { return r1.empty() ? e() : r1.back(); }\n  void push0(const T &x) {\n    a0.push_back(x);\n    r0.push_back(op(x, get0()));\n  }\n  void push1(const T &x) {\n    a1.push_back(x);\n    r1.push_back(op(get1(), x));\n  }\n  void modify() {\n    int n = a0.size() + a1.size();\n    int s0 = n / 2 + (a0.empty() ? n % 2 : 0);\n    vector<T> a{a0};\n    ranges::reverse(a);\n    ranges::copy(a1, back_inserter(a));\n    a0.clear(), r0.clear();\n    a1.clear(), r1.clear();\n    for(int i = s0 - 1; i >= 0; i--) { push0(a[i]); }\n    for(int i = s0; i < n; i++) { push1(a[i]); }\n  }\n\n public:\n  DequeAggregation() = default;\n  void push_front(const T &x) { push0(x); }\n  void push_back(const T &x) { push1(x); }\n  T front() const { return a0.empty() ? a1.front() : a0.back(); }\n  T pop() const { return a1.empty() ? a0.front() : a1.back(); }\n  void pop_front() {\n    if(a0.empty()) { modify(); }\n    a0.pop_back(), r0.pop_back();\n  }\n  void pop_back() {\n    if(a1.empty()) { modify(); }\n    a1.pop_back(), r1.pop_back();\n  }\n  T prod() { return op(get0(), get1()); }\n};"
  // },
  "dequeaggregation": {
    "prefix": "dequeaggregation",
    "body": "DequeAggregation<T,op,e> Q;"
  },
  // "SubstringSet": {
  //   "prefix": "SubstringSet",
  //   "body": "template<typename T, typename SequenceType> struct SuffixAutomatonBase {\n  struct Node {\n    map<T, int> nxt;\n    int link, len;\n    bool cloned;\n    int index;\n  };\n\n  vector<Node> nodes;\n  int last;\n\n  SuffixAutomatonBase() {\n    nodes.push_back({{}, -1, 0, false, -1});\n    last = 0;\n  }\n  SuffixAutomatonBase(const SequenceType &s): SuffixAutomatonBase() {\n    for(const T &c : s) { append(c); }\n  }\n\n  void append(const T &c) {\n    const int new_node = nodes.size();\n    const int new_node_index = nodes[last].index + 1;\n    nodes.push_back({{}, -1, nodes[last].len + 1, false, new_node_index});\n    int p = last;\n    for(; p != -1 && !nodes[p].nxt.count(c); p = nodes[p].link) { nodes[p].nxt[c] = new_node; }\n    const int q = p == -1 ? 0 : nodes[p].nxt[c];\n    if(p == -1 || nodes[p].len + 1 == nodes[q].len) { nodes[new_node].link = q; }\n    else {\n      const int clone_node = nodes.size();\n      nodes.push_back({nodes[q].nxt, nodes[q].link, nodes[p].len + 1, true, new_node_index});\n      for(; p != -1 && nodes[p].nxt[c] == q; p = nodes[p].link) { nodes[p].nxt[c] = clone_node; }\n      nodes[new_node].link = nodes[q].link = clone_node;\n    }\n    last = new_node;\n  }\n  SuffixAutomatonBase &operator+=(const T &c) {\n    append(c);\n    return *this;\n  }\n\n  int transition(const SequenceType &t, int invalid_state = -1) const {\n    int cur = 0;\n    for(const auto &c : t) {\n      auto it = nodes[cur].nxt.find(c);\n      if(it == nodes[cur].nxt.end()) { return invalid_state; }\n      cur = it->second;\n    }\n    return cur;\n  }\n\n  bool accept(const SequenceType &t) const { return transition(t) != -1; }\n\n  struct SubstringCounter {\n   public:\n    SubstringCounter(const SuffixAutomatonBase *sa): sa(sa), n(sa->nodes.size()), dp(n, 0) {\n      const vector<Node> &nodes = sa->nodes;\n      for(const int u : sa->topological_order(true)) {\n        dp[u] += !nodes[u].cloned;\n        const int p = nodes[u].link;\n        if(p >= 0) { dp[p] += dp[u]; }\n      }\n    }\n    long long count(const SequenceType &t) const {\n      const int state = sa->transition(t);\n      return state == -1 ? 0 : dp[state];\n    }\n\n   private:\n    const SuffixAutomatonBase *sa;\n    int n;\n    vector<long long> dp;\n  };\n\n  SubstringCounter substring_counter() const & { return SubstringCounter{this}; }\n  SubstringCounter substring_counter() const && = delete;\n\n  struct SuffixLinkTree {\n   public:\n    SuffixLinkTree(const SuffixAutomatonBase *sa): sa(sa), g(sa->nodes.size()) {\n      const int n = g.size();\n      for(int i = 1; i < n; i++) { g[sa->nodes[i].link].push_back(i); }\n    }\n    int size() const { return g.size(); }\n    const vector<int> &operator[](int i) const { return g[i]; }\n\n   private:\n    const SuffixAutomatonBase *sa;\n    vector<vector<int>> g;\n  };\n\n  SuffixLinkTree suffix_link_tree() const & { return SuffixLinkTree(this); }\n  SuffixLinkTree suffix_link_tree() const && = delete;\n\n  struct OccurrenceEnumerator {\n   public:\n    OccurrenceEnumerator(const SuffixAutomatonBase *sa): sa(sa), t(sa->suffix_link_tree()) {}\n\n    // returns vector of i s.t. S[i:i+|t|] = t\n    vector<int> enumerate_all_occurrence(const SequenceType &pattern) const {\n      const int state = sa->transition(pattern);\n      if(state == -1) { return {}; }\n      const vector<Node> &nodes = sa->nodes;\n      const int l = pattern.size();\n      vector<int> res;\n      auto dfs = [&](auto self, int u) -> void {\n        if(!nodes[u].cloned) { res.push_back(nodes[u].len - l); }\n        for(const int v : t[u]) { self(self, v); }\n      };\n      dfs(dfs, state);\n      return res;\n    }\n\n   private:\n    const SuffixAutomatonBase *sa;\n    SuffixLinkTree t;\n  };\n\n  OccurrenceEnumerator occurrence_enumerator() const & { return OccurrenceEnumerator(this); }\n  OccurrenceEnumerator occurrence_enumerator() const && = delete;\n\n  struct FirstOccurenceSearcher {\n   public:\n    FirstOccurenceSearcher(const SuffixAutomatonBase *sa): sa(sa) {\n      const vector<Node> &nodes = sa->nodes;\n      dp.resize(nodes.size(), numeric_limits<int>::max());\n      for(const int u : sa->topological_order(true)) {\n        if(!nodes[u].cloned) { dp[u] = nodes[u].len; }\n        const int p = nodes[u].link;\n        if(p >= 0 && nodes[p].cloned) { dp[p] = min(dp[p], dp[u]); }\n      }\n    }\n\n    // returns min { i | S[i:i+|t|] = t }. if such i does !exist, returns -1.\n    int first_occurrence(const SequenceType &t) const {\n      const int state = sa->transition(t);\n      if(state == -1) { return -1; }\n      return dp[state] - t.size();\n    }\n\n   private:\n    const SuffixAutomatonBase *sa;\n    vector<int> dp;\n  };\n\n  FirstOccurenceSearcher first_occurence_searcher() const & { return FirstOccurenceSearcher(this); }\n  FirstOccurenceSearcher first_occurence_searcher() const && = delete;\n\n  // returns { start_s, start_t, len } s.t. lcs = s[start_s: start_s+len] t[start_t: start_t+len]\n  tuple<int, int, int> longest_common_substring(const SequenceType &t) const {\n    if(t.size() == 0) { return {0, 0, 0}; }\n    const Node *v = &nodes[0];\n    int l = 0, max_len = 0, s_end_pos = 0, t_end_pos = 0;\n    for(int i = 0; i < (int)t.size(); i++) {\n      while(v->link != -1 && !v->nxt.count(t[i])) {\n        v = &nodes[v->link];\n        l = v->len;\n      }\n      auto it = v->nxt.find(t[i]);\n      if(it != v->nxt.end()) {\n        v = &nodes[it->second];\n        l++;\n      }\n      if(l > max_len) {\n        max_len = l;\n        t_end_pos = i;\n        s_end_pos = v->index;\n      }\n    }\n    if(max_len == 0) { return {0, 0, 0}; }\n    return {s_end_pos - max_len + 1, t_end_pos - max_len + 1, max_len};\n  }\n\n  vector<int> topological_order(bool reversed = false) const {\n    const int n = nodes.size();\n    vector<int> in(n, 0);\n    for(const auto &node : nodes) {\n      for(const auto &p : node.nxt) { in[p.second]++; }\n    }\n    deque<int> dq;\n    for(int i = 0; i < n; i++) {\n      if(!in[i]) { dq.push_back(i); }\n    }\n    vector<int> res;\n    while(dq.size()) {\n      int u = dq.front();\n      dq.pop_front();\n      res.push_back(u);\n      for(const auto &p : nodes[u].nxt) {\n        if(!--in[p.second]) { dq.push_back(p.second); }\n      }\n    }\n    if(reversed) { ranges::reverse(res); }\n    assert((int)res.size() == n);\n    return res;\n  }\n};\n\ntemplate<typename T> struct SuffixAutomaton : public SuffixAutomatonBase<T, vector<T>> {\n  using SuffixAutomatonBase<T, vector<T>>::SuffixAutomatonBase;\n  using value_type = T;\n  using sequence_type = vector<T>;\n};\n\ntemplate<typename T> SuffixAutomaton(vector<T>) -> SuffixAutomaton<T>;\n\ntemplate<> struct SuffixAutomaton<char> : public SuffixAutomatonBase<char, string> {\n  using SuffixAutomatonBase<char, string>::SuffixAutomatonBase;\n  using value_type = char;\n  using sequence_type = string;\n};\n\nSuffixAutomaton(string) -> SuffixAutomaton<char>;\n\ntemplate<typename T> struct SubstringSet {\n public:\n  using value_type = typename SuffixAutomaton<T>::sequence_type;\n  using size_type = long long;\n  using difference_type = size_type;\n\n  // create empty set\n  SubstringSet(): SubstringSet(value_type{}) {}\n  // create set of all substrings in `s`\n  SubstringSet(const value_type &s) { build(s); }\n  // build set of all substrings in `s`\n  void build(const value_type &s) {\n    sa = SuffixAutomaton(s);\n    dp.resize(sa.nodes.size(), size_type(1));\n    for(const int u : sa.topological_order(true)) {\n      for(const auto &p : sa.nodes[u].nxt) { dp[u] += dp[p.second]; }\n    }\n  }\n  size_type size() const { return dp[0]; }\n  bool contains(const value_type &t) const { return sa.accept(t); }\n  // the k'th lexicographically smallest substring, O(|return value|).\n  value_type operator[](size_type k) const {\n    assert(0 <= k && k < dp[0]);\n    int cur = 0;\n    value_type res;\n    while(k--) {\n      for(const auto &[e, v] : sa.nodes[cur].nxt) {\n        if(k < dp[v]) {\n          res.push_back(e);\n          cur = v;\n          break;\n        }\n        else { k -= dp[v]; }\n      }\n    }\n    return res;\n  }\n  // the k'th lexicographically smallest substring, O(|return value|).\n  value_type kth_element(size_type k) const { return (*this)[k]; }\n  // number of { s | s < t, s is in this set }, O(|min(t, max_substr_len)|).\n  size_type count_lt(const value_type &t) const {\n    size_type res = 0;\n    int cur = 0;\n    for(const T &c : t) {\n      res++;\n      auto it_r = sa.nodes[cur].nxt.lower_bound(c);\n      for(auto it_l = sa.nodes[cur].nxt.begin(); it_l != it_r; it_l++) { res += dp[it_l->second]; }\n      if(it_r == sa.nodes[cur].nxt.end() || it_r->first != c) { break; }\n      cur = it_r->second;\n    }\n    return res;\n  }\n  // number of { s | s <= t, s is in this set }, O(min(|t|, max_substr_len)).\n  size_type count_leq(const value_type &t) const { return count_lt(t) + contains(t); }\n  // number of { s | s > t, s is in this set }, O(min(|t|, max_substr_len)).\n  size_type count_gt(const value_type &t) const { return size() - count_leq(t); }\n  // number of { s | s >= t, s is in this set }, O(min(|t|, max_substr_len)).\n  size_type count_geq(const value_type &t) const { return size() - count_lt(t); }\n  // number of { s | l <= s <= r, s is in this set }, O(min(|t|, max_substr_len)).\n  size_type count_range(const value_type &l, const value_type &r) const { return l >= r ? 0 : count_lt(r) - count_lt(l); }\n\n  // min { s | s >= t, s is in this set }, O(|return value| + min(|t|, max_substr_len))\n  value_type min_geq(const value_type &t) const { return (*this)[count_lt(t)]; }\n  // min { s | s > t, s is in this set }, O(|return value| + min(|t|, max_substr_len))\n  value_type min_gt(const value_type &t) const { return (*this)[count_leq(t)]; }\n  // max { s | s < t, s is in this set }, O(|return value| + min(|t|, max_substr_len))\n  value_type max_lt(const value_type &t) const { return (*this)[count_lt(t) - 1]; }\n  // max { s | s <= t, s is in this set }, O(|return value| + min(|t|, max_substr_len))\n  value_type max_leq(const value_type &t) const { return (*this)[count_leq(t) - 1]; }\n\n  // iterator\n\n  // operator*: O(|return value|), other operations: O(1).\n  struct SubstringSetIterator {\n   public:\n    SubstringSetIterator(const SubstringSet *st, size_type k): st(st), k(k) {}\n    value_type operator*() const { return st->kth_substring(k); }\n    auto &operator=(const SubstringSetIterator &other) {\n      st = other.st;\n      k = other.k;\n      return *this;\n    }\n    auto &operator++() {\n      k++;\n      return *this;\n    }\n    auto &operator--() {\n      k--;\n      return *this;\n    }\n    auto &operator+=(difference_type d) {\n      k += d;\n      return *this;\n    }\n    auto &operator-=(difference_type d) {\n      k -= d;\n      return *this;\n    }\n    auto operator+(difference_type d) { return SubstringSetIterator{st, k + d}; }\n    auto operator-(difference_type d) { return SubstringSetIterator{st, k - d}; }\n    difference_type operator-(const SubstringSetIterator &other) { return k - other.k; }\n    bool operator==(const SubstringSetIterator &other) const { return k == other.k; }\n    bool operator!=(const SubstringSetIterator &other) const { return k != other.k; }\n    bool operator<(const SubstringSetIterator &other) const { return k < other.k; }\n    bool operator<=(const SubstringSetIterator &other) const { return k <= other.k; }\n    bool operator>(const SubstringSetIterator &other) const { return k > other.k; }\n    bool operator>=(const SubstringSetIterator &other) const { return k >= other.k; }\n\n   protected:\n    const SubstringSet *st;\n    size_type k;\n  };\n\n  // operator*: O(|return value|), other operations: O(1).\n  struct ReversedSubstringSetIterator : public SubstringSetIterator {\n    using SubstringSetIterator::SubstringSetIterator;\n    value_type operator*() const { return this->st->kth_element(this->st->size() - this->k - 1); }\n  };\n  using iterator = SubstringSetIterator;\n  using reverse_iterator = ReversedSubstringSetIterator;\n  using const_iterator = iterator;\n  using const_reverse_iterator = reverse_iterator;\n  auto begin() const { return iterator{this, 0LL}; }\n  auto end() const { return iterator{this, size()}; }\n  auto cbegin() const { return begin(); }\n  auto cend() const { return end(); }\n  auto rbegin() const { return reverse_iterator{this, 0LL}; }\n  auto rend() const { return reverse_iterator{this, size()}; }\n  auto crbegin() const { return rbegin(); }\n  auto crend() const { return rend(); }\n  // O(|min(t, max_substr_len)|).\n  auto lower_bound(const value_type &t) const { return iterator{this, count_lt(t)}; }\n  // O(|min(t, max_substr_len)|).\n  auto upper_bound(const value_type &t) const { return iterator{this, count_leq(t)}; }\n  // O(|min(t, max_substr_len)|).\n  auto find(const value_type &t) const {\n    auto it = lower_bound(t);\n    if(it == end() || t != *it) { return end(); }\n    return it;\n  }\n\n private:\n  SuffixAutomaton<T> sa;\n  std::vector<size_type> dp;\n};\n\ntemplate<typename T> SubstringSet(std::vector<T>) -> SubstringSet<T>;\n\nSubstringSet(std::string) -> SubstringSet<char>;"
  // },
  // "MinMaxPlusConvolution": {
  //   "prefix": "MinMaxPlusConvolution",
  //   "body": "namespace SMAWKImpl {\nconstexpr int M = 1 << 20, N = 1 << 20;\nint is0[2 * M], js0[max(2 * M, N)];\ntemplate<typename F> struct SMAWK {\n  const int m, n;\n  const F f;\n  vector<int> v;\n  SMAWK(int m, int n, F f): m(m), n(n), f(f) {\n    for(int i = 0; i < m; i++) { is0[i] = i; }\n    for(int j = 0; j < n; j++) { js0[j] = j; }\n    v.assign(m, -1);\n    rec(is0, m, js0, n);\n  }\n  void rec(int *is, int il, int *js, int jl) {\n    if(!il || !jl) { return; }\n    if(il < jl) {\n      int len = 0;\n      for(int y = 0; y < jl; y++) {\n        const int j = js[y];\n        for(; len && f(is[len - 1], js[len - 1], j); len--) {}\n        if(len != il) { js[len++] = j; }\n      }\n      jl = len;\n    }\n    int *iis = is + il, *jjs = js + jl, iil = 0;\n    for(int x = 1; x < il; x += 2) { iis[iil++] = is[x]; }\n    for(int y = 0; y < jl; y++) { jjs[y] = js[y]; }\n    rec(iis, iil, jjs, jl);\n    for(int x = 0, y = 0; x < il; x += 2) {\n      const int i = is[x];\n      const int j1 = (x + 1 < il) ? v[is[x + 1]] : js[jl - 1];\n      for(;;) {\n        const int j = js[y];\n        if(!~v[i] || f(i, v[i], j)) { v[i] = j; }\n        if(j == j1) { break; }\n        y++;\n      }\n    }\n  }\n};\n}  // namespace SMAWKImpl\n\ntemplate<typename F> vector<int> SMAWK(int m, int n, F f) { return SMAWKImpl::SMAWK<F>(m, n, f).v; }\n\n// C[k] = min[i+j=k] (A[i] + B[j]), A : 下に凸\ntemplate<typename T> vector<T> MinPlusConvolution(const vector<T> &A, const vector<T> &B) {\n  const int a = A.size(), b = B.size();\n  if(!a || !b) { return {}; }\n  const auto v = SMAWK(a + b - 1, b, [&](int i, int j, int k) -> bool {\n    if(i - j >= a) { return true; }\n    if(i - k < 0) { return false; }\n    return A[i - j] + B[j] > A[i - k] + B[k];\n  });\n  vector<T> C(a + b - 1);\n  for(int i = 0; i < a + b - 1; i++) { C[i] = A[i - v[i]] + B[v[i]]; }\n  return C;\n}\n\n// C[k] = max[i+j=k] (A[i] + B[j]), A : 上に凸\ntemplate<typename T> vector<T> MaxPlusConvolution(const vector<T> &A, const vector<T> &B) {\n  const int a = A.size(), b = B.size();\n  if(!a || !b) { return {}; }\n  const auto v = SMAWK(a + b - 1, b, [&](int i, int j, int k) -> bool {\n    if(i - j >= a) { return true; }\n    if(i - k < 0) { return false; }\n    return A[i - j] + B[j] < A[i - k] + B[k];\n  });\n  vector<T> C(a + b - 1);\n  for(int i = 0; i < a + b - 1; i++) { C[i] = A[i - v[i]] + B[v[i]]; }\n  return C;\n}"
  // },
  // "DisjointSparseTable": {
  //   "prefix": "DisjointSparseTable",
  //   "body": "template<typename T, auto op, auto e> struct DisjointSparseTable {\n  vector<vector<T>> t;\n  vector<T> v;\n  DisjointSparseTable() {}\n  DisjointSparseTable(ll N): v(N, e()) {}\n  DisjointSparseTable(const vector<T> &v): v(v) { build(); }\n  void set(ll i, T x) { v[i] = x; }\n  void build() {\n    const int N = v.size() + 2;\n    const int H = 32 - __builtin_clz(N - 1);\n    t.assign(H, vector<T>(N, e()));\n    for(int k = 1; k < H; k++) {\n      auto &s = t[k];\n      const int W = 1 << k;\n      for(int i = W; i < N; i += W * 2) {\n        for(int j = i - 1; j > i - W; j--) { s[j - 1] = op(v[j - 1], s[j]); }\n        const int M = min(i + W - 1, N - 1);\n        for(int j = i; j < M; j++) { s[j + 1] = op(s[j], v[j - 1]); }\n      }\n    }\n  }\n  T get(int i) const { return prod(i, i + 1); }\n  T prod(int l, int r) const {\n    assert(0 <= l && l <= r && r <= ssize(t[0]) - 2);\n    r++;\n    const auto &s = t[31 - __builtin_clz(l ^ r)];\n    return op(s[l], s[r]);\n  }\n};"
  // },
  "disjointsparsetable": {
    "prefix": "disjointsparsetable",
    "body": "DisjointSparseTable<S,op,e> S($1)"
  },
  // "RangeCountDistinct": {
  //   "prefix": "RangeCountDistinct",
  //   "body": "template<typename T> struct RangeCountDistinct {\n private:\n  int N, Q;\n  vector<T> v;\n  vector<pair<int, int>> qs;\n\n public:\n  RangeCountDistinct(): RangeCountDistinct(vector<T>{}) {}\n  explicit RangeCountDistinct(const vector<T> &v): N(v.size()), Q(0), v(v) {}\n  void reserve(int Q) { qs.reserve(Q); }\n  int query(int l, int r) {\n    assert(0 <= l && l <= r && r <= N);\n    qs.emplace_back(l, r);\n    return Q++;\n  }\n  vector<int> solve() const {\n    unordered_map<T, int> last;\n    vector<int> prv(N), idx(N + 2), iq(Q), ans(Q);\n    for(int i = 0; i < N; i++) { prv[i] = exchange(last[v[i]], i + 1); }\n    for(auto &[l, r] : qs) { idx[r]++; }\n    for(int i = 1; i <= N; i++) { idx[i] += idx[i - 1]; }\n    idx[N + 1] = Q;\n    for(int i = 0; i < Q; i++) { iq[--idx[qs[i].second]] = i; }\n    fenwick_tree<int> f(N + 1);\n    for(int r = 0; r <= N; r++) {\n      for(int i = idx[r]; i < idx[r + 1]; i++) {\n        const int id = iq[i], l = qs[id].first;\n        ans[id] = f.sum(0, l + 1) - l;\n      }\n      if(r < N) { f.add(prv[r], 1); }\n    }\n    return ans;\n  }\n};"
  // },
  "rangecountdistinct": {
    "prefix": "rangecountdistinct",
    "body": "RangeCountDistinct S($1);$0"
  },
  // "CompressedRectangleSum": {
  //   "prefix": "CompressedRectangleSum",
  //   "body": "template<typename S, typename T> struct CompressedRectangleSum {\n  struct P {\n    S x, y;\n    T w;\n  };\n  struct Q1 {\n    S lx, ly, rx, ry;\n  };\n  vector<P> ps;\n  vector<Q1> Qs;\n  CompressedRectangleSum() = default;\n  CompressedRectangleSum(int N, int Q) {\n    ps.reserve(N);\n    Qs.reserve(Q);\n  }\n  void add(S x, S y, T w) { ps.emplace_back(P{x, y, w}); }\n  void sum(S lx, S rx, S ly, S ry) { Qs.emplace_back(Q1{lx, ly, rx, ry}); }\n  vector<T> solve() {\n    int N = ps.size(), Q = Qs.size();\n    ranges::sort(ps, [](const P &a, const P &b) { return a.y < b.y; });\n    vector<S> ys;\n    ys.reserve(N);\n    for(P &p : ps) {\n      if(ys.empty() || ys.back() != p.y) { ys.emplace_back(p.y); }\n      p.y = ys.size() - 1;\n    }\n    ys.shrink_to_fit();\n    struct Q2 {\n      S x, ly, ry;\n      bool type;\n      int idx;\n    };\n    vector<Q2> qs;\n    qs.reserve(Q + Q);\n    for(int i = 0; i < Q; i++) {\n      auto &q = Qs[i];\n      int d = ranges::lower_bound(ys, q.ly) - ys.begin(), u = ranges::lower_bound(ys, q.ry) - ys.begin();\n      qs.emplace_back(Q2{q.lx, d, u, false, i});\n      qs.emplace_back(Q2{q.rx, d, u, true, i});\n    }\n    ranges::sort(ps, [](const P &a, const P &b) { return a.x < b.x; });\n    ranges::sort(qs, [](const Q2 &a, const Q2 &b) { return a.x < b.x; });\n    vector<T> ans(Q);\n    int j = 0;\n    fenwick_tree<T> f(ys.size());\n    for(auto &q : qs) {\n      while(j < N && ps[j].x < q.x) {\n        f.add(ps[j].y, ps[j].w);\n        j++;\n      }\n      if(q.type) { ans[q.idx] += f.sum(q.ly, q.ry); }\n      else { ans[q.idx] -= f.sum(q.ly, q.ry); }\n    }\n    return ans;\n  }\n};"
  // },
  "compressedrectanglesum": {
    "prefix": "compressedrectanglesum",
    "body": "CompressedRectangleSum<ll,ll> S"
  },
  // "CompressedInverseBIT2D": {
  //   "prefix": "CompressedInverseBIT2D",
  //   "body": "template<typename S, typename T> struct CompressedInverseBIT2D {\n private:\n  vector<array<S, 4>> rs;\n  vector<T> ws;\n  vector<array<S, 2>> ps;\n  vector<int> ts;\n  static int p2(int x) { return 1 << (31 - __builtin_clz(x)); }\n\n public:\n  CompressedInverseBIT2D() = default;\n  CompressedInverseBIT2D(int N, int Q) {\n    rs.reserve(N);\n    ws.reserve(N);\n    ps.reserve(Q);\n    ts.reserve(Q);\n  }\n  void add(S lx, S rx, S ly, S ry, T w) {\n    assert(lx <= rx && ly <= ry);\n    if(lx == rx || ly == ry) return;\n    rs.push_back({lx, rx, ly, ry});\n    ws.push_back(w);\n  }\n  void get(S x, S y) {\n    ps.push_back({x, y});\n    ts.push_back(rs.size());\n  }\n  vector<T> solve() const {\n    vector<T> ans(ps.size());\n    const int N = rs.size();\n    using Key = pair<S, int>;\n    constexpr auto comp = [](const Key &k1, const Key &k2) { return k1.first < k2.first; };\n    vector<Key> esx(2 * N), esy(2 * N);\n    for(int i = 0; i < N; i++) {\n      esx[2 * i] = Key{rs[i][0], 2 * i};\n      esx[2 * i + 1] = Key{rs[i][1], 2 * i + 1};\n      esy[2 * i] = Key{rs[i][2], 2 * i};\n      esy[2 * i + 1] = Key{rs[i][3], 2 * i + 1};\n    }\n    vector<vector<Key>> psx(N), psy(N);\n    for(int pid = 0; pid < (int)ps.size(); pid++)\n      if(ts[pid]) {\n        const int r = p2(ts[pid]);\n        psx[r - 1].emplace_back(ps[pid][0], pid);\n        psy[r - 1].emplace_back(ps[pid][1], pid);\n      }\n    vector<int> pscy(ps.size()), escy(2 * N);\n    for(int r = 1; r <= N; r++) {\n      const int w = -r & r, l = r - w;\n      for(int t = 1; t < w; t <<= 1) {\n        auto irx = esx.begin() + 2 * r, imx = irx - 2 * t, ilx = imx - 2 * t;\n        inplace_merge(ilx, imx, irx, comp);\n        auto iry = esy.begin() + 2 * r, imy = iry - 2 * t, ily = imy - 2 * t;\n        inplace_merge(ily, imy, iry, comp);\n      }\n      const int n = psx[r - 1].size();\n      if(!n) { continue; }\n      if(r == (-r & r)) {\n        ranges::sort(psx[r - 1], comp);\n        ranges::sort(psy[r - 1], comp);\n      }\n      int ny = 0;\n      {\n        vector<Key> mixy(esy.begin() + 2 * l, esy.begin() + 2 * r);\n        const int msiz = mixy.size(), siz = msiz + n;\n        mixy.reserve(siz);\n        for(const auto &[y, pid] : psy[r - 1]) { mixy.emplace_back(y, ~pid); }\n        inplace_merge(mixy.begin(), mixy.begin() + msiz, mixy.end(), comp);\n        for(int t = 0; t < siz; t++) {\n          const Key pkey = t ? mixy[t - 1] : Key{0, 0}, key = mixy[t];\n          ny += t && comp(pkey, key) && (pkey.second < 0) && (key.second >= 0);\n          const int i = key.second;\n          (i >= 0 ? escy[i] : pscy[~i]) = ny;\n        }\n        ny++;\n      }\n      fenwick_tree<T> f(ny);\n      for(int j = 0, i = 2 * l; j < n; j++) {\n        const auto &[px, pid] = psx[r - 1][j];\n        for(; i < 2 * r; i++) {\n          const auto &[ex, eid] = esx[i];\n          if(px < ex) { break; }\n          const T &w = ws[eid >> 1];\n          f.add(escy[eid & ~1], (eid & 1) ? -w : +w);\n          f.add(escy[eid | 1], (eid & 1) ? +w : -w);\n        }\n        ans[pid] += f.sum(0, pscy[pid] + 1);\n      }\n      for(Key &key : psx[r - 1]) {\n        if(int d = ts[key.second] - r) { psx[r + p2(d) - 1].push_back(move(key)); }\n      }\n      psx[r - 1].clear();\n      psx[r - 1].shrink_to_fit();\n      for(Key &key : psy[r - 1]) {\n        if(int d = ts[key.second] - r) { psy[r + p2(d) - 1].push_back(move(key)); }\n      }\n      psy[r - 1].clear();\n      psy[r - 1].shrink_to_fit();\n    }\n    return ans;\n  }\n};"
  // },
  "compressedinverseBIT2D": {
    "prefix": "compressedinverseBIT2D",
    "body": "CompressedInverseBIT2D<ll,ll> S"
  },
  // "StaticCompressedDualBIT2D": {
  //   "prefix": "StaticCompressedDualBIT2D",
  //   "body": "template<typename S, typename T> struct StaticCompressedDualBIT2D {\n  vector<tuple<S, S, S, S, T>> Add;\n  vector<tuple<S, S, S, S>> Sum;\n  StaticCompressedDualBIT2D() = default;\n  StaticCompressedDualBIT2D(int N, int Q) {\n    Add.reserve(N);\n    Sum.reserve(Q);\n  }\n  void add(S lx, S rx, S ly, S ry, T w) { Add.emplace_back(lx, rx, ly, ry, w); }\n  void sum(S lx, S rx, S ly, S ry) { Sum.emplace_back(lx, rx, ly, ry); }\n  vector<T> solve() {\n    vector<S> ys;\n    vector<tuple<S, S, T>> add;\n    for(const auto &[lx, rx, ly, ry, w] : Add) {\n      ys.emplace_back(ly), ys.emplace_back(ry);\n      add.emplace_back(lx, ly, w), add.emplace_back(rx, ly, -w);\n      add.emplace_back(lx, ry, -w), add.emplace_back(rx, ry, w);\n    }\n    ranges::sort(ys);\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    auto id = [&ys](S y) -> int { return ranges::lower_bound(ys, y) - ys.begin(); };\n    vector<tuple<S, S, int, bool>> sum;\n    for(int i = 0; i < (int)Sum.size(); i++) {\n      const auto &[lx, rx, ly, ry] = Sum[i];\n      sum.emplace_back(lx, ly, i, true), sum.emplace_back(rx, ly, i, false);\n      sum.emplace_back(lx, ry, i, false), sum.emplace_back(rx, ry, i, true);\n    }\n    static constexpr auto comp = [](const auto &q1, const auto &q2) { return get<0>(q1) < get<0>(q2); };\n    ranges::sort(add, comp);\n    ranges::sort(sum, comp);\n    fenwick_tree<T> f[4];\n    for(int i = 0; i < 4; i++) { f[i] = fenwick_tree<T>(ys.size()); }\n    vector<T> ans(Sum.size(), T{0});\n    const int N = add.size(), M = sum.size();\n    for(int i = 0, j = 0; i < N || j < M;) {\n      if(j == M || (i < N && get<0>(add[i]) < get<0>(sum[j]))) {\n        const auto [lx, ly, w] = add[i++];\n        int idy = id(ly);\n        f[0].add(idy, w);\n        f[1].add(idy, -w * ly);\n        f[2].add(idy, -w * lx);\n        f[3].add(idy, w * lx * ly);\n      }\n      else {\n        const auto &[x, y, qid, plus] = sum[j++];\n        T s[4];\n        for(int i = 0, idy = id(y); i < 4; i++) { s[i] = f[i].sum(0, idy); }\n        const T tmp = s[0] * x * y + s[1] * x + s[2] * y + s[3];\n        ans[qid] += (plus ? tmp : -tmp);\n      }\n    }\n    return ans;\n  }\n};"
  // },
  "staticcompresseddualBIT2D": {
    "prefix": "staticcompresseddualBIT2D",
    "body": "StaticCompressedDualBIT2D<ll,ll> S"
  },
  // "CompressedDualBIT2D": {
  //   "prefix": "CompressedDualBIT2D",
  //   "body": "namespace std {\ntemplate<typename T> tuple<T, T, T, T> operator+=(tuple<T, T, T, T> &l, tuple<T, T, T, T> r) {\n  return l = make_tuple(get<0>(l) + get<0>(r), get<1>(l) + get<1>(r), get<2>(l) + get<2>(r), get<3>(l) + get<3>(r));\n}\ntemplate<typename T> tuple<T, T, T, T> operator-(tuple<T, T, T, T> l, tuple<T, T, T, T> r) {\n  return make_tuple(get<0>(l) - get<0>(r), get<1>(l) - get<1>(r), get<2>(l) - get<2>(r), get<3>(l) - get<3>(r));\n}\ntemplate<typename T> tuple<T, T, T, T> operator-=(tuple<T, T, T, T> &l, tuple<T, T, T, T> r) {\n  return l = l - r;\n}\n}  // namespace std\n\ntemplate<typename S, typename T> struct CompressedBIT2D {\n private:\n  struct BIT {\n   private:\n    int n;\n    vector<T> data;\n    T sum(int r) {\n      T s = {0, 0, 0, 0};\n      for(; r > 0; r -= r & -r) { s += data[r - 1]; }\n      return s;\n    }\n\n   public:\n    BIT() = default;\n    explicit BIT(int n): n(n), data(n) {}\n    void add(int p, T x) {\n      for(++p; p <= n; p += p & -p) { data[p - 1] += T(x); }\n    }\n    T sum(int l, int r) { return sum(r) - sum(l); }\n  };\n  int N;\n  vector<BIT> bit;\n  vector<vector<S>> ys;\n  vector<pair<S, S>> ps;\n  int id(S x) const {\n    return ranges::lower_bound(ps, make_pair(x, S()), [](const pair<S, S> &a, const pair<S, S> &b) { return a.first < b.first; }) - ps.begin();\n  }\n  int id(int i, S y) const { return ranges::lower_bound(ys[i], y) - ys[i].begin(); }\n\n public:\n  CompressedBIT2D() = default;\n  CompressedBIT2D(int N) { ps.reserve(N); }\n  void use(S x, S y) { ps.emplace_back(x, y); }\n  void build() {\n    ranges::sort(ps);\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n    N = ps.size();\n    bit.resize(N + 1);\n    ys.resize(N + 1);\n    for(int i = 0; i <= N; ++i) {\n      for(int j = i + 1; j <= N; j += j & -j) { ys[j].emplace_back(ps[i].second); }\n      ranges::sort(ys[i]);\n      ys[i].erase(unique(ys[i].begin(), ys[i].end()), ys[i].end());\n      bit[i] = BIT(ys[i].size() + 1);\n    }\n  }\n  void add(S x, S y, T a) {\n    int i = ranges::lower_bound(ps, make_pair(x, y)) - ps.begin();\n    assert(ps[i] == make_pair(x, y));\n    for(++i; i <= N; i += i & -i) { bit[i].add(id(i, y), a); }\n  }\n  T sum(S x, S y) {\n    T r = T();\n    for(int a = id(x); a; a -= a & -a) { r += bit[a].sum(0, id(a, y)); }\n    return r;\n  }\n  T sum(S lx, S rx, S ly, S ry) {\n    T r = T();\n    int a = id(lx), b = id(rx);\n    while(a != b) {\n      if(a < b) {\n        r += bit[b].sum(id(b, ly), id(b, ry));\n        b -= b & -b;\n      }\n      else {\n        r -= bit[a].sum(id(a, ly), id(a, ry));\n        a -= a & -a;\n      }\n    }\n    return r;\n  }\n};\n\ntemplate<typename S, typename T> struct CompressedDualBIT2D {\n private:\n  CompressedBIT2D<S, tuple<T, T, T, T>> B;\n  static constexpr S inf = numeric_limits<S>::max();\n  void add(S lx, S ly, const T &w) {\n    B.add(lx, ly, make_tuple(w, -w * ly, -w * lx, w * lx * ly));\n  }\n  T sum(S x, S y) {\n    auto [a, b, c, d] = B.sum(-inf, x, -inf, y);\n    return a * x * y + b * x + c * y + d;\n  }\n\n public:\n  CompressedDualBIT2D() = default;\n  void use(S lx, S rx, S ly, S ry) {\n    B.use(lx, ly), B.use(rx, ly);\n    B.use(lx, ry), B.use(rx, ry);\n  }\n  void build() { B.build(); }\n  void add(S lx, S rx, S ly, S ry, const T &val) {\n    add(lx, ly, val), add(rx, ly, -val);\n    add(lx, ry, -val), add(rx, ry, val);\n  }\n  T sum(S lx, S rx, S ly, S ry) { return sum(rx, ry) - sum(rx, ly) - sum(lx, ry) + sum(lx, ly); }\n};"
  // },
  "compresseddualBIT2D": {
    "prefix": "compresseddualBIT2D",
    "body": "CompressedDualBIT2D<ll,ll> S"
  },
  // "DoubleEndedPriorityQueue": {
  //   "prefix": "DoubleEndedPriorityQueue",
  //   "body": "template<typename T> struct DualPriorityQueue {\n private:\n  inline int par(int i) { return (i - 4 + (i & 3)) / 2; }\n\n  void down(int i) {\n    int n = dat.size();\n    if(i % 2 == 0) {\n      while(true) {\n        if(i + 1 < n && dat[i] > dat[i + 1]) { swap(dat[i], dat[i + 1]); }\n        int j = i, l = 2 * i + 2, r = 2 * i + 4;\n        if(l < n && dat[l] < dat[j]) { j = l; }\n        if(r < n && dat[r] < dat[j]) { j = r; }\n        if(i == j) { break; }\n        swap(dat[i], dat[j]);\n        i = j;\n      }\n    }\n    else {\n      while(true) {\n        if(dat[i - 1] > dat[i]) { swap(dat[i - 1], dat[i]); }\n        int j = i, l = 2 * i + 1, r = 2 * i + 3;\n        if(r >= n) { --r; }\n        if(l >= n) { --l; }\n        if(l < n && dat[l] > dat[j]) { j = l; }\n        if(r < n && dat[r] > dat[j]) { j = r; }\n        if(i == j) { break; }\n        swap(dat[i], dat[j]);\n        i = j;\n        if(i % 2 == 0) { break; }\n      }\n    }\n  }\n\n  void up() {\n    int i = dat.size() - 1;\n    if(2 <= i && i % 2 == 0) {\n      int p = par(i) ^ 1;\n      if(dat[p] < dat[i]) { swap(dat[i], dat[p]), i = p; }\n    }\n    if(i % 2 == 1 && dat[i - 1] > dat[i]) { swap(dat[i - 1], dat[i]), --i; }\n    if(i % 2 == 0) {\n      while(i >= 2) {\n        int p = par(i);\n        if(dat[p] <= dat[i]) { break; }\n        swap(dat[p], dat[i]);\n        i = p;\n      }\n      return;\n    }\n    while(i >= 3) {\n      int p = par(i);\n      if(dat[p] >= dat[i]) { break; }\n      swap(dat[p], dat[i]);\n      i = p;\n    }\n  }\n\n public:\n  vector<T> dat;\n  Double_End_Queue() {}\n  Double_End_Queue(vector<T> &A) {\n    dat = A;\n    int n = dat.size();\n    for(int i = n - 1; i >= 0; i--) { down(i); }\n  }\n  int size() { return dat.size(); }\n  bool empty() { return dat.empty(); }\n  T min() { return dat[0]; }\n  T max() { return dat.size() == 1 ? dat[0] : dat[1]; }\n  void push(T x) {\n    dat.emplace_back(x);\n    up();\n  }\n  T pop_min() {\n    assert(!dat.empty());\n    swap(dat[0], dat.back());\n    T res = dat.back();\n    dat.pop_back();\n    down(0);\n    return res;\n  }\n  T pop_max() {\n    assert(!dat.empty());\n    if(dat.size() <= 2) {\n      T res = dat.back();\n      dat.pop_back();\n      return res;\n    }\n    swap(dat[1], dat.back());\n    T res = dat.back();\n    dat.pop_back();\n    down(1);\n    return res;\n  }\n};"
  // },
  "__int128_t_option": {
    "prefix": "__int128_t_option",
    "body": "istream &operator>>(istream &is, __int128_t &v) {\n  string s;\n  is >> s;\n  v = 0;\n  for(const auto &i : s) {\n    if(isdigit(i)) { v = v * 10 + i - '0'; }\n  }\n  if(s[0] == '-') { v = -v; }\n  return is;\n}\n\nostream &operator<<(ostream &os, const __int128_t &v) {\n  if(!v) { return (os << \"0\"); }\n  __int128_t n = v;\n  if(v < 0) {\n    os << '-';\n    n = -n;\n  }\n  string s;\n  for(; n; n /= 10) { s += (n % 10) + '0'; }\n  ranges::reverse(s);\n  return (os << s);\n}"
  },
  // "gradient": {
  //   "prefix": "gradient",
  //   "body": "void grd(ll &dx, ll &dy) {\n  ll g = gcd(dx, dy);\n  dx /= g, dy /= g;\n  if(dx < 0) { dx *= -1, dy *= -1; }\n  if(!dx) { dy = 1; }\n  if(!dy) { dx = 1; }\n}"
  // },
  // "mod_sqrt": {
  //   "prefix": "mod_sqrt",
  //   "body": "ll mod_sqrt(const ll &a, const ll &MOD = 998244353) {\n  modint::set_mod(MOD);\n  ll m = MOD - 1, e = 0;\n  if(!a) { return 0; }\n  if(MOD == 2) { return a; }\n  if(mint(a).pow(m >> 1) != 1) { return -1; }\n  mint b = 1;\n  while(b.pow(m >> 1) == 1) { b++; }\n  while(~m & 1) {\n    m >>= 1;\n    e++;\n  }\n  mint x = mint(a).pow((m - 1) >> 1), y = mint(a) * x * x, z = mint(b).pow(m);\n  x *= a;\n  while(y != 1) {\n    ll j = 0;\n    mint t = y;\n    while(t != 1) {\n      j++;\n      t *= t;\n    }\n    z = z.pow(1LL << (e - j - 1));\n    x *= z;\n    z *= z;\n    y *= z;\n    e = j;\n  }\n  return x.val();\n}"
  // },
  // "RangeModeQuery": {
  //   "prefix": "RangeModeQuery",
  //   "body": "template<typename T> struct RangeModeQuery {\n private:\n  int len, bs, bn;\n  vector<T> sorted;\n  vector<int> a, pos, posinv, start;\n  vector<pair<int, int>> modebs;\n\n  const auto &querybs(int lb, int rb) const { return modebs[lb * (bn + 1) + rb]; }\n  auto &querybs(int lb, int rb) { return modebs[lb * (bn + 1) + rb]; }\n  int checkl(int v, int posid, int l) const { return start[v] <= posid && l <= pos[posid]; }\n  int checkr(int v, int posid, int r) const { return posid < start[v + 1] && pos[posid] < r; }\n  static int cld(int num, int den) { return (num + den - 1) / den; }\n  static int fld(int num, int den) { return num / den; }\n\n public:\n  RangeModeQuery() = default;\n  explicit RangeModeQuery(const vector<T> &v): len(v.size()), bs(sqrt(len)), bn(cld(len, bs)) {\n    sorted = v;\n    ranges::sort(sorted);\n    sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());\n    const int k = sorted.size();\n    a.resize(len);\n    start.assign(k + 1, 0);\n    for(int i = 0; i < len; i++) {\n      a[i] = ranges::lower_bound(sorted, v[i]) - sorted.begin();\n      start[a[i]]++;\n    }\n    for(int i = 0; i < k; i++) { start[i + 1] += start[i]; }\n    pos.resize(len);\n    posinv.resize(len);\n    for(int i = len - 1; i >= 0; i--) {\n      const int posid = --start[a[i]];\n      pos[posid] = i;\n      posinv[i] = posid;\n    }\n    modebs.assign((bn + 1) * (bn + 1), {0, 0});\n    vector<int> freq(k);\n    for(int lb = 0; lb <= bn; lb++) {\n      freq.assign(k, 0);\n      pair<int, int> mode{0, 0};\n      for(int rb = lb + 1; rb <= bn; rb++) {\n        const int lid = (rb - 1) * bs, rid = min(len, rb * bs);\n        for(int i = lid; i < rid; i++) { mode = max(mode, {++freq[a[i]], a[i]}); }\n        querybs(lb, rb) = mode;\n      }\n    }\n  }\n\n  pair<T, int> query(const int l, const int r) const {\n    assert(0 <= l && l < r && r <= len);\n    const int lb = cld(l, bs), rb = fld(r, bs);\n    auto [freq, mode] = querybs(lb, rb);\n    for(int i = l; i < min(r, lb * bs); ++i) {\n      const int v = a[i], posid = posinv[i];\n      if(!checkr(v, posid + freq, r)) { continue; }\n      do { ++freq; } while(checkr(v, posid + freq, r));\n      mode = v;\n    }\n    for(int i = r - 1; i >= max(l, rb * bs); --i) {\n      const int v = a[i], posid = posinv[i];\n      if(!checkl(v, posid - freq, l)) { continue; }\n      do { ++freq; } while(checkl(v, posid - freq, l));\n      mode = v;\n    }\n    return {sorted[mode], freq};\n  }\n  pair<T, int> operator()(int l, int r) const { return query(l, r); }\n};"
  // },
  // "RangeUnionFind": {
  //   "prefix": "RangeUnionFind",
  //   "body": "struct RangeUnionFind {\n  vector<int> data, L, R;\n  RangeUnionFind(int N): data(N, -1), L(N), R(N) {\n    iota(L.begin(), L.end(), 0);\n    iota(R.begin(), R.end(), 1);\n  }\n  int find(int k) { return data[k] < 0 ? k : data[k] = find(data[k]); }\n  int unite(int x, int y) {\n    if((x = find(x)) == (y = find(y))) { return false; }\n    if(data[x] > data[y]) { swap(x, y); }\n    data[x] += data[y];\n    data[y] = x;\n    L[x] = min(L[x], L[y]);\n    R[x] = max(R[x], R[y]);\n    return true;\n  }\n  void range_unite(int l, int r) {  // unite [l, r)\n    if((l = max(l, 0)) >= (r = min(r, (int)data.size()))) { return; }\n    int m;\n    while((m = R[find(l)]) < r) { unite(l, m); }\n  }\n  int size(int k) { return -data[find(k)]; }\n  int same(int x, int y) { return find(x) == find(y); }\n};"
  // },
  "Fail": {
    "prefix": "Fail",
    "body": "void Fail() {\n  cout << ${1:-1} << \"\\\\n\";\n  exit(0);\n}$0"
  },
  "ModRestore": {
    "prefix": "ModRestore",
    "body": "pair<ll, ll> ModRestore(mint x) {\n  for(ll den = 1; den <= 1000; den++) {\n    mint num = x * den;\n    if(num.val() <= 1000) {\n      cout << num.val() << \" \" << den << \"\\\\n\";\n      return {num.val(), den};\n    }\n  }\n  return {-1, -1};\n}"
  },
  // "SwapMatch": {
  //   "prefix": "SwapMatch",
  //   "body": "template<typename T> vector<T> Compress(vector<T> &v) {\n  vector<T> r = v;\n  ranges::sort(r);\n  r.erase(unique(r.begin(), r.end()), r.end());\n  for(auto &i : v) { i = ranges::lower_bound(r, i) - r.begin(); }\n  return r;\n}\n\nll Inversion(vector<ll> &v) {\n  ll r = 0, n = v.size();\n  // Compress(v);\n  fenwick_tree<ll> b(n + 1);\n  for(ll i = 0; i < n; i++) {\n    r += b.sum(v[i] + 1, n + 1);\n    b.add(v[i], 1);\n  }\n  return r;\n}\n\nll SwapMatch(vector<ll> &A, vector<ll> &B, bool check = false) {\n  if(check) {\n    auto a = A, b = B;\n    ranges::sort(a);\n    ranges::sort(b);\n    if(a != b) { return -1; }\n  }\n  if(A.empty()) { return 0; }\n  auto a = A, b = B;\n  Compress(a);\n  Compress(b);\n  ll N = A.size();\n  vector<queue<ll>> q(ranges::max(a) + 1);\n  vector<ll> v;\n  for(ll i = 0; i < N; i++) { q[a[i]].emplace(i); }\n  for(ll i = 0; i < N; i++) {\n    v.emplace_back(q[b[i]].front());\n    q[b[i]].pop();\n  }\n  return Inversion(v);\n}"
  // },
  // "LinearEquation": {
  //   "prefix": "LinearEquation",
  //   "body": "template<typename T> pair<ll, T> GaussianElimination(Matrix<T> &v, ll pivot_end = -1, bool diagonalize = false) {\n  int H = v.size(), W = v[0].size(), rank = 0;\n  if(pivot_end == -1) { pivot_end = W; }\n  T det = 1;\n  for(int j = 0; j < pivot_end; j++) {\n    int idx = -1;\n    for(int i = rank; i < H; i++) {\n      if(v[i][j] != T(0)) {\n        idx = i;\n        break;\n      }\n    }\n    if(idx == -1) {\n      det = 0;\n      continue;\n    }\n    if(rank != idx) {\n      det = -det;\n      swap(v[rank], v[idx]);\n    }\n    det *= v[rank][j];\n    if(diagonalize && v[rank][j] != T(1)) {\n      T c = T(1) / v[rank][j];\n      for(int k = j; k < W; k++) { v[rank][k] *= c; }\n    }\n    int is = diagonalize ? 0 : rank + 1;\n    for(int i = is; i < H; i++) {\n      if(i == rank) { continue; }\n      if(v[i][j] != T(0)) {\n        T c = v[i][j] / v[rank][j];\n        for(int k = j; k < W; k++) { v[i][k] -= v[rank][k] * c; }\n      }\n    }\n    rank++;\n  }\n  return make_pair(rank, det);\n}\n\ntemplate<typename T> Matrix<T> LinearEquation(Matrix<T> a, vector<T> b) {\n  int H = a.size(), W = a[0].size();\n  for(int i = 0; i < H; i++) { a[i].emplace_back(b[i]); }\n  auto p = GaussianElimination(a, W, true);\n  int rank = p.first;\n  for(int i = rank; i < H; i++) {\n    if(a[i][W]) { return Matrix<T>{}; }\n  }\n  Matrix<T> res(1, W);\n  vector<int> pivot(W, -1);\n  for(int i = 0, j = 0; i < rank; i++) {\n    while(!a[i][j]) { j++; }\n    res[0][j] = a[i][W];\n    pivot[j] = i;\n  }\n  for(int j = 0; j < W; j++) {\n    if(pivot[j] == -1) {\n      vector<T> x(W);\n      x[j] = 1;\n      for(int k = 0; k < j; k++) {\n        if(pivot[k] != -1) { x[k] = -a[pivot[k]][j]; }\n      }\n      res.emplace_back(x);\n    }\n  }\n  return res;\n}"
  // },
  // "BipartiteGraph": {
  //   "prefix": "BipartiteGraph",
  //   "body": "struct BipartiteGraph {\n private:\n  vector<int> find_residual_path() {\n    auto res = build_residual_graph();\n    queue<int> q;\n    vector<int> vis(n + m + 2);\n    q.emplace(n + m);\n    vis[n + m] = true;\n    while(!q.empty()) {\n      int idx = q.front();\n      q.pop();\n      for(auto &to : res[idx]) {\n        if(vis[to]) { continue; }\n        vis[to] = true;\n        q.emplace(to);\n      }\n    }\n    return vis;\n  }\n  void build_augment_path() {\n    queue<int> q;\n    d.assign(g.size(), -1);\n    for(int i = 0; i < n; i++) {\n      if(l[i] == -1) {\n        q.emplace(i);\n        d[i] = 0;\n      }\n    }\n    while(!q.empty()) {\n      int a = q.front();\n      q.pop();\n      for(auto &b : g[a]) {\n        int c = r[b];\n        if(c >= 0 && d[c] == -1) {\n          d[c] = d[a] + 1;\n          q.emplace(c);\n        }\n      }\n    }\n  }\n  bool find_minimum_dist_augment_path(int a) {\n    used[a] = t;\n    for(auto &b : g[a]) {\n      int c = r[b];\n      if(c < 0 || (used[c] != t && d[c] == d[a] + 1 && find_minimum_dist_augment_path(c))) {\n        r[b] = a;\n        l[a] = b;\n        return true;\n      }\n    }\n    return false;\n  }\n  bool find_augment_path(int a) {\n    used[a] = t;\n    for(auto &b : g[a]) {\n      int c = r[b];\n      if(c < 0 || (alive[c] == 1 && used[c] != t && find_augment_path(c))) {\n        r[b] = a;\n        l[a] = b;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int n, m, t;\n  vector<vector<int>> g, rg;\n  vector<int> l, r, d, used, alive;\n  bool matched;\n\n public:\n  explicit BipartiteGraph(int n, int m): n(n), m(m), t(0), g(n), rg(m), l(n, -1), r(m, -1), used(n), alive(n, 1), matched(false) {}\n  void add_edge(int u, int v) {\n    g[u].emplace_back(v);\n    rg[v].emplace_back(u);\n  }\n  void erase_edge(int a, int b) {\n    if(l[a] == b) {\n      l[a] = -1;\n      r[b] = -1;\n    }\n    g[a].erase(find(begin(g[a]), end(g[a]), b));\n    rg[b].erase(find(begin(rg[b]), end(rg[b]), a));\n  }\n  vector<pair<int, int>> maximum_matching() {\n    matched = true;\n    while(true) {\n      build_augment_path();\n      t++;\n      int f = 0;\n      for(int i = 0; i < n; i++) {\n        if(l[i] == -1) { f += find_minimum_dist_augment_path(i); }\n      }\n      if(!f) { break; }\n    }\n    vector<pair<int, int>> ret;\n    for(int i = 0; i < n; i++) {\n      if(l[i] >= 0) { ret.emplace_back(i, l[i]); }\n    }\n    return ret;\n  }\n  vector<pair<int, int>> lex_maximum_matching() {\n    if(!matched) { maximum_matching(); }\n    for(auto &vs : g) { ranges::sort(vs); }\n    vector<pair<int, int>> es;\n    for(int i = 0; i < n; i++) {\n      if(l[i] == -1 || alive[i] == 0) { continue; }\n      r[l[i]] = -1;\n      l[i] = -1;\n      t++;\n      find_augment_path(i);\n      alive[i] = 0;\n      es.emplace_back(i, l[i]);\n    }\n    return es;\n  }\n  vector<int> minimum_vertex_cover() {\n    auto vis = find_residual_path();\n    vector<int> ret;\n    for(int i = 0; i < n + m; i++) {\n      if(vis[i] ^ (i < n)) { ret.emplace_back(i); }\n    }\n    return ret;\n  }\n  vector<int> lex_minimum_vertex_cover(const vector<int> &ord) {\n    assert((int)ord.size() == n + m);\n    auto res = build_residual_graph();\n    vector<vector<int>> r_res(n + m + 2);\n    for(int i = 0; i < n + m + 2; i++) {\n      for(auto &j : res[i]) { r_res[j].emplace_back(i); }\n    }\n    queue<int> q;\n    vector<int> vis(n + m + 2, -1);\n    auto exp_l = [&](int t) {\n      if(vis[t] != -1) { return; }\n      q.emplace(t);\n      vis[t] = 1;\n      while(!q.empty()) {\n        int idx = q.front();\n        q.pop();\n        for(auto &to : r_res[idx]) {\n          if(vis[to] != -1) { continue; }\n          vis[to] = 1;\n          q.emplace(to);\n        }\n      }\n    };\n    auto exp_r = [&](int t) {\n      if(vis[t] != -1) { return; }\n      q.emplace(t);\n      vis[t] = 0;\n      while(!q.empty()) {\n        int idx = q.front();\n        q.pop();\n        for(auto &to : res[idx]) {\n          if(vis[to] != -1) { continue; }\n          vis[to] = 0;\n          q.emplace(to);\n        }\n      }\n    };\n    exp_r(n + m);\n    exp_l(n + m + 1);\n    vector<int> ret;\n    for(auto &t : ord) {\n      if(t < n) {\n        exp_l(t);\n        if(vis[t] & 1) { ret.emplace_back(t); }\n      }\n      else {\n        exp_r(t);\n        if(~vis[t] & 1) { ret.emplace_back(t); }\n      }\n    }\n    return ret;\n  }\n  vector<int> maximum_independent_set() {\n    auto vis = find_residual_path();\n    vector<int> ret;\n    for(int i = 0; i < (n + m); i++) {\n      if(vis[i] ^ (i >= n)) { ret.emplace_back(i); }\n    }\n    return ret;\n  }\n  vector<pair<int, int>> minimum_edge_cover() {\n    auto es = maximum_matching();\n    for(int i = 0; i < n; i++) {\n      if(l[i] >= 0) { continue; }\n      if(g[i].empty()) { return {}; }\n      es.emplace_back(i, g[i][0]);\n    }\n    for(int i = 0; i < m; i++) {\n      if(r[i] >= 0) { continue; }\n      if(rg[i].empty()) { return {}; }\n      es.emplace_back(rg[i][0], i);\n    }\n    return es;\n  }\n  // left: [0,n), right: [n,n+m), S: n+m, T: n+m+1\n  vector<vector<int>> build_residual_graph() {\n    if(!matched) { maximum_matching(); }\n    const int S = n + m, T = n + m + 1;\n    vector<vector<int>> res(n + m + 2);\n    for(int i = 0; i < n; i++) {\n      if(l[i] == -1) { res[S].emplace_back(i); }\n      else { res[i].emplace_back(S); }\n    }\n    for(int i = 0; i < m; i++) {\n      if(r[i] == -1) { res[i + n].emplace_back(T); }\n      else { res[T].emplace_back(i + n); }\n    }\n    for(int i = 0; i < n; i++) {\n      for(auto &j : g[i]) {\n        if(l[i] == j) { res[j + n].emplace_back(i); }\n        else { res[i].emplace_back(j + n); }\n      }\n    }\n    return res;\n  }\n};\n// https://ei1333.github.io/library/graph/flow/bipartite-flow.hpp"
  // },
  // "Stirling_1_fixed_N": {
  //   "prefix": "Stirling_1_fixed_N",
  //   "body": "FPS TaylorShift(FPS f, mint c) {\n  const int N = f.size();\n  for(int i = 0; i < N; i++) { f[i] *= C(i); }\n  f = f.rev();\n  FPS g(N, 1);\n  for(int i = 1; i < N; i++) { g[i] = g[i - 1] * c * C[i]; }\n  f = (f * g).pre(N);\n  f = f.rev();\n  for(int i = 0; i < N; i++) { f[i] *= C(-i); }\n  return f;\n}\n\nFPS Stirling1(int N) {  // fixed N\n  if(N <= 0) { return {1}; }\n  int lg = 31 - __builtin_clz(N);\n  FPS f{0, 1};\n  for(int i = lg - 1; i >= 0; i--) {\n    int n = N >> i;\n    f *= TaylorShift(f, mint(n >> 1));\n    if(n & 1) { f = (f << 1) + f * (n - 1); }\n  }\n  return f;\n}"
  // },
  // "Stirling_1_fixed_K": {
  //   "prefix": "Stirling_1_fixed_K",
  //   "body": "FPS Stirling1(int K, int N) {  // fixed K\n  if(N < K) { return {}; }\n  FPS f(N + 1);\n  for(int i = 1; i <= N; i++) { f[i] = C[i]; }\n  f = f.pow(K) * C(-K);\n  for(int i = K; i <= N; i++) { f[i] *= C(i); }\n  return f;\n}"
  // },
  // "Stirling_2_fixed_N": {
  //   "prefix": "Stirling_2_fixed_N",
  //   "body": "FPS Stirling2(int N) {  // fixed N\n  FPS f(N + 1), g(N + 1);\n  for(int i = 0; i <= N; i++) {\n    f[i] = mint(i).pow(N) * C(-i);\n    g[i] = i & 1 ? -C(-i) : C(-i);\n  }\n  return (f * g).pre(N + 1);\n}"
  // },
  // "Stirling_2_fixed_K": {
  //   "prefix": "Stirling_2_fixed_K",
  //   "body": "FPS Stirling2(int K, int N) {  // fixed K\n  if(N < K) { return {}; }\n  FPS f(N + 1);\n  for(int i = 1; i <= N; i++) { f[i] = C(-i); }\n  f = f.pow(K) * C(-K);\n  for(int i = K; i <= N; i++) { f[i] *= C(i); }\n  return f;\n}"
  // },
  // "PartitionNumber": {
  //   "prefix": "PartitionNumber",
  //   "body": "FPS Partition(int N) {\n  FPS f(N + 1);\n  f[0] = 1;\n  for(ll i = 1; i <= N; i++) {\n    ll x = i * (3 * i + 1) / 2, y = i * (3 * i - 1) / 2;\n    if(y > N) { break; }\n    if(x <= N) { f[x] += (i & 1 ? -1 : 1); }\n    if(y <= N) { f[y] += (i & 1 ? -1 : 1); }\n  }\n  return f.inv();\n}"
  // },
  // "CycleDetection": {
  //   "prefix": "CycleDetection",
  //   "body": "struct Cycle {\n private:\n  vector<int> used;\n  int dfs(int v, int p) {\n    if(used[v] == 1) { return v; }\n    if(used[v] == 2) { return -1; }\n    used[v] = 1;\n    for(auto &[nv, id] : g[v]) {\n      if(id == p) { continue; }\n      int nxt = dfs(nv, id);\n      if(nxt == -1) { continue; }\n      if(nxt == -2) { return -2; }\n      cycle.emplace_back(nv, id);\n      if(nxt == v) { return -2; }\n      return nxt;\n    }\n    used[v] = 2;\n    return -1;\n  }\n\n public:\n  int N, e = 0;\n  bool directed;\n  vector<vector<pair<int, int>>> g;\n  vector<pair<int, int>> cycle;  // {v, idx of e}\n  Cycle() {}\n  Cycle(int N, bool directed): N(N), g(N), used(N), directed(directed) {}\n  void add_edge(int u, int v) {\n    g[u].emplace_back(v, e);\n    if(!directed) { g[v].emplace_back(u, e); }\n    e++;\n  }\n  vector<pair<int, int>> build() {\n    for(int i = 0; i < N; i++) {\n      if(dfs(i, -1) == -2) {\n        ranges::reverse(cycle);\n        break;\n      }\n    }\n    return cycle;\n  }\n};"
  // },
  // "MultiConvolution": {
  //   "prefix": "MultiConvolution",
  //   "body": "struct MultiConvolution {\n private:\n  ll N, K, M;\n  vector<int> chi;\n  static constexpr int ceil_pow2(int m) {\n    int r = 1;\n    while(r < m) { r <<= 1; }\n    return r << 1;\n  }\n  auto ranked(const vector<mint> &f) const {\n    vector rf(K, vector<mint>(M, mint{}));\n    for(int i = 0; i < N; i++) { rf[chi[i]][i] = f[i]; }\n    return rf;\n  }\n\n public:\n  MultiConvolution(): MultiConvolution(vector<ll>{}) {}\n  MultiConvolution(const vector<ll> &dim): N(accumulate(dim.begin(), dim.end(), 1, multiplies<int>())), K(dim.size()), M(ceil_pow2(N)), chi(N, 0) {\n    for(int i = 0; i < N; i++) {\n      int den = 1;\n      for(auto e : dim) {\n        den *= e;\n        chi[i] += i / den;\n      }\n      if(K) { chi[i] %= K; }\n    }\n  }\n  int size() const { return N; }\n  int dum_sum() const { return K; }\n  vector<mint> convolution(vector<mint> f, vector<mint> g) const {\n    assert((int)f.size() == N && (int)g.size() == N);\n    if(!K) { return {f[0] * g[0]}; }\n    auto rf = ranked(f), rg = ranked(g);\n    for(auto &v : rf) { internal::butterfly(v); }\n    for(auto &v : rg) { internal::butterfly(v); }\n    vector rh(K, vector<mint>(M, mint{}));\n    for(int i = 0; i < K; i++)\n      for(int j = 0; j < K; j++) {\n        int r = i + j < K ? i + j : i + j - K;\n        for(int p = 0; p < M; ++p) { rh[r][p] += rf[i][p] * rg[j][p]; }\n      }\n    for(auto &v : rh) { internal::butterfly_inv(v); }\n    const mint isz = mint(M).inv();\n    vector<mint> h(N);\n    for(int i = 0; i < N; i++) { h[i] = rh[chi[i]][i] * isz; }\n    return h;\n  }\n};"
  // },
  // "DynamicConvexHull": {
  //   "prefix": "DynamicConvexHull",
  //   "body": "struct DynamicConvexHull {\n private:\n  static constexpr ll inf = numeric_limits<int>::max();\n  struct Point {\n    ll x, y;\n    Point() = default;\n    Point(ll x, ll y): x(x), y(y) {}\n    bool operator==(const Point &other) const { return x == other.x && y == other.y; }\n    bool operator!=(const Point &other) const { return !(operator==(other)); }\n    Point operator+(const Point &other) const { return {x + other.x, y + other.y}; }\n    Point operator-(const Point &other) const { return {x - other.x, y - other.y}; }\n    operator pair<int, int>() const { return {x, y}; }\n    friend ll det(Point p, Point q) { return p.x * q.y - p.y * q.x; }\n  };\n  struct Node {\n    pair<Point, Point> bridge;\n    ll min_x;\n    Node() = default;\n    Node(Point p): bridge(p, p), min_x(p.x) {}\n    Node(pair<Point, Point> bridge, ll min_x): bridge(bridge), min_x(min_x) {}\n    bool operator==(const Node &other) const { return bridge == other.bridge && min_x == other.min_x; }\n    bool operator!=(const Node &other) const { return !(operator==(other)); }\n  };\n  static inline const Node None{Point{-inf, -inf}};\n  int M;\n  vector<int> _xs;\n  vector<set<int>> points_upper, points_lower;\n  vector<Node> seg_upper, seg_lower;\n  static int next_branch(int i, const vector<Node> &seg) {\n    while(seg[2 * i] == None || seg[2 * i + 1] == None) { i = 2 * i + (seg[2 * i] == None); }\n    return i;\n  }\n  static Node merge(int x, int y, vector<Node> &seg) {\n    if(seg[x] == None) { return seg[y]; }\n    if(seg[y] == None) { return seg[x]; }\n    const ll min_x = seg[x].min_x, sep_x = seg[y].min_x;\n    Point a, b, c, d;\n    while(true) {\n      tie(a, b) = seg[x].bridge;\n      tie(c, d) = seg[y].bridge;\n      if(a == b && c == d) { break; }\n      if(a != b && det(b - a, c - a) > 0) { x = 2 * next_branch(x, seg); }\n      else if(c != d && det(c - b, d - b) > 0) { y = 2 * next_branch(y, seg) + 1; }\n      else if(a == b) { y = 2 * next_branch(y, seg); }\n      else if(c == d) { x = 2 * next_branch(x, seg) + 1; }\n      else {\n        __int128_t c1 = det(b - a, c - a), c2 = det(a - b, d - b);\n        if(c1 + c2 == 0 || c1 * d.x + c2 * c.x < sep_x * (c1 + c2)) { x = 2 * next_branch(x, seg) + 1; }\n        else { y = 2 * next_branch(y, seg); }\n      }\n    }\n    return Node({a, c}, min_x);\n  }\n  void inner_set(int i, const Node &dat, vector<Node> &seg) {\n    seg[M + i] = dat;\n    for(i = (M + i) >> 1; i > 0; i >>= 1) { seg[i] = merge(2 * i, 2 * i + 1, seg); }\n  }\n  void insert(int x, int y, vector<Node> &seg, vector<set<int>> &points) {\n    int i = index(x);\n    int old_y = seg[M + i].bridge.first.y;\n    points[i].insert(y);\n    if(old_y >= y) { return; }\n    inner_set(i, Node{Point{x, y}}, seg);\n  }\n  void erase(int x, int y, vector<Node> &seg, vector<set<int>> &points) {\n    int i = index(x);\n    points[i].erase(y);\n    int old_y = seg[M + i].bridge.first.y;\n    if(old_y != y) { return; }\n    inner_set(i, points[i].empty() ? None : Node{Point{x, *points[i].rbegin()}}, seg);\n  }\n  static int ceil_pow2(int n) {\n    int res = 1;\n    while(res < n) { res <<= 1; }\n    return res;\n  }\n  int index(int x) const { return lower_bound(_xs.begin(), _xs.end(), x) - _xs.begin(); }\n  ll linearMax(int a, int b, const vector<Node> &seg) const {\n    ll res = numeric_limits<ll>::min();\n    for(int k = 1;;) {\n      const auto &[p, q] = seg[k].bridge;\n      res = max(res, p.x * a + p.y * b);\n      res = max(res, q.x * a + q.y * b);\n      if(p == q) { break; }\n      k = 2 * next_branch(k, seg) | ((q.y - p.y) * b >= (q.x - p.x) * -a);\n    }\n    return res;\n  }\n  void get_upper_hull(int l, int r, int k, const vector<Node> &seg, vector<pair<int, int>> &res) const {\n    if(l > r || seg[k] == None) { return; }\n    if(k >= M) {\n      res.push_back(seg[k].bridge.first);\n      return;\n    }\n    if(seg[2 * k + 0] == None) { return get_upper_hull(l, r, 2 * k + 1, seg, res); }\n    if(seg[2 * k + 1] == None) { return get_upper_hull(l, r, 2 * k + 0, seg, res); }\n    int bl = seg[k].bridge.first.x, br = seg[k].bridge.second.x;\n    if(r <= bl) { return get_upper_hull(l, r, 2 * k + 0, seg, res); }\n    if(br <= l) { return get_upper_hull(l, r, 2 * k + 1, seg, res); }\n    get_upper_hull(l, bl, 2 * k + 0, seg, res);\n    get_upper_hull(br, r, 2 * k + 1, seg, res);\n  }\n\n public:\n  DynamicConvexHull() = default;\n  template<typename T> DynamicConvexHull(const vector<T> &xs) {\n    ranges::copy(xs, back_inserter(_xs));\n    ranges::sort(_xs);\n    _xs.erase(unique(_xs.begin(), _xs.end()), _xs.end());\n    M = ceil_pow2(_xs.size());\n    points_upper.resize(M);\n    points_lower.resize(M);\n    seg_upper = vector<Node>(2 * M, None);\n    seg_lower = vector<Node>(2 * M, None);\n  }\n  void insert(int x, int y) {\n    insert(x, +y, seg_upper, points_upper);\n    insert(x, -y, seg_lower, points_lower);\n  }\n  void erase(int x, int y) {\n    erase(x, +y, seg_upper, points_upper);\n    erase(x, -y, seg_lower, points_lower);\n  }\n  // returns max { ax + by | (x, y) in S }\n  ll linearMax(int a, int b) const { return b >= 0 ? linearMax(a, +b, seg_upper) : linearMax(a, -b, seg_lower); }\n  // returns min { ax + by | (x, y) in S }\n  ll linearMin(int a, int b) const { return -linearMax(-a, -b); }\n  vector<pair<int, int>> get_upper_hull() const {\n    vector<pair<int, int>> res;\n    get_upper_hull(-inf, inf, 1, seg_upper, res);\n    return res;\n  }\n  vector<pair<int, int>> get_lower_hull() const {\n    vector<pair<int, int>> res;\n    get_upper_hull(-inf, inf, 1, seg_lower, res);\n    for(auto &[x, y] : res) { y = -y; }\n    return res;\n  }\n  vector<pair<int, int>> get_hull() const {\n    auto upper = get_upper_hull();\n    auto lower = get_lower_hull();\n    if(upper.empty()) { return upper; }\n    int xl = upper.front().first, xr = upper.back().first;\n    int yld = lower.front().second, ylu = upper.front().second;\n    int yrd = lower.back().second, yru = upper.back().second;\n    lower.erase(set_difference(lower.begin(), lower.end(), upper.begin(), upper.end(), lower.begin()), lower.end());\n    for(int y : points_upper[index(xr)]) {\n      if(yrd < y && y < yru) { lower.emplace_back(xr, y); }\n    }\n    ranges::reverse(lower);\n    for(auto &p : lower) { upper.push_back(move(p)); }\n    if(xl == xr) { return upper; }\n    for(int y : points_upper[index(xl)]) {\n      if(yld < y && y < ylu) { upper.emplace_back(xl, y); }\n    }\n    return upper;\n  }\n};"
  // },
  // "Lazy_linearadd_min": {
  //   "prefix": "Lazy_linearadd_min",
  //   "body": "template<typename T, typename TN, typename TN2> struct RangeLinearAddRangeMin {\n  struct point {\n    int x;\n    T y;\n    static TN cross(const point &a, const point &b, const point &c) { return (TN)(b.y - a.y) * (c.x - a.x) - (TN)(c.y - a.y) * (b.x - a.x); }\n  };\n  struct node {\n    point lbr, rbr;\n    T lza, lzb;\n    node(int x, T y): lbr{x, y}, rbr{x, y}, lza(0), lzb(0) {}\n    node(): lza(0), lzb(0) {}\n  };\n\n private:\n  int _n, size, log;\n  vector<node> nd;\n  void all_apply(int k, T a, T b) {\n    nd[k].lbr.y += a * nd[k].lbr.x + b;\n    nd[k].rbr.y += a * nd[k].rbr.x + b;\n    if(k < size) { nd[k].lza += a, nd[k].lzb += b; }\n  }\n  void push(int k) {\n    all_apply(2 * k, nd[k].lza, nd[k].lzb);\n    all_apply(2 * k + 1, nd[k].lza, nd[k].lzb);\n    nd[k].lza = nd[k].lzb = 0;\n  }\n  int leftmost(int k) {\n    int msb = 31 - __builtin_clz(k);\n    return (k - (1 << msb)) << (log - msb);\n  }\n  void pull(int k) {\n    assert(k < size);\n    int l = k * 2, r = k * 2 + 1;\n    int splitx = leftmost(r);\n    push(k);\n    T lza = 0, lzb = 0, lzA = 0, lzB = 0;\n    point a = nd[l].lbr, b = nd[l].rbr, c = nd[r].lbr, d = nd[r].rbr;\n    auto movel = [&](int f) {\n      lza += nd[l].lza, lzb += nd[l].lzb;\n      l = l * 2 + f;\n      a = nd[l].lbr, b = nd[l].rbr;\n      a.y += lza * a.x + lzb;\n      b.y += lza * b.x + lzb;\n    };\n    auto mover = [&](int f) {\n      lzA += nd[r].lza, lzB += nd[r].lzb;\n      r = r * 2 + f;\n      c = nd[r].lbr, d = nd[r].rbr;\n      c.y += lzA * c.x + lzB;\n      d.y += lzA * d.x + lzB;\n    };\n    while(l < size || r < size) {\n      TN2 s1 = point::cross(a, b, c);\n      if(l < size && s1 > 0) { movel(0); }\n      else if(r < size && point::cross(b, c, d) > 0) { mover(1); }\n      else if(l >= size) { mover(0); }\n      else if(r >= size) { movel(1); }\n      else {\n        TN2 s2 = point::cross(b, a, d);\n        assert(s1 + s2 >= 0);\n        if(s1 + s2 == 0 || s1 * (d.x - splitx) < s2 * (splitx - c.x)) { movel(1); }\n        else { mover(0); }\n      }\n    }\n    nd[k].lbr = a;\n    nd[k].rbr = c;\n  }\n  T min_subtree(int k) {\n    T a = 0, b = 0;\n    while(k < size) {\n      bool f = (nd[k].lbr.y - nd[k].rbr.y) > a * (nd[k].rbr.x - nd[k].lbr.x);\n      a += nd[k].lza;\n      b += nd[k].lzb;\n      k = k * 2 + f;\n    }\n    return nd[k].lbr.y + a * nd[k].lbr.x + b;\n  }\n\n public:\n  static constexpr T inf = numeric_limits<T>::max();\n  RangeLinearAddRangeMin(): RangeLinearAddRangeMin(0) {}\n  explicit RangeLinearAddRangeMin(int n): RangeLinearAddRangeMin(vector<T>(n, 0)) {}\n  explicit RangeLinearAddRangeMin(const vector<T> &v): _n(int(v.size())) {\n    size = (int)bit_ceil((unsigned int)(_n));\n    log = countr_zero((unsigned int)size);\n    nd = vector<node>(2 * size);\n    for(int i = 0; i < size; i++) { nd[size + i] = node(i, (i < _n ? v[i] : 0)); }\n    for(int i = size - 1; i >= 1; i--) { pull(i); }\n  }\n  T prod(int l, int r) {\n    assert(0 <= l && l <= r && r <= _n);\n    if(l == r) { return inf; }\n    l += size;\n    r += size;\n    for(int i = log; i >= 1; i--) {\n      if(((l >> i) << i) != l) { push(l >> i); }\n      if(((r >> i) << i) != r) { push((r - 1) >> i); }\n    }\n    T res = inf;\n    while(l < r) {\n      if(l & 1) { res = min(res, min_subtree(l++)); }\n      if(r & 1) { res = min(res, min_subtree(--r)); }\n      l >>= 1;\n      r >>= 1;\n    }\n    return res;\n  }\n  void apply(int l, int r, T a, T b) {\n    assert(0 <= l && l <= r && r <= _n);\n    if(l == r) { return; }\n    l += size;\n    r += size;\n    {\n      int l2 = l, r2 = r;\n      while(l < r) {\n        if(l & 1) { all_apply(l++, a, b); }\n        if(r & 1) { all_apply(--r, a, b); }\n        l >>= 1;\n        r >>= 1;\n      }\n      l = l2;\n      r = r2;\n    }\n    for(int i = 1; i <= log; i++) {\n      if(((l >> i) << i) != l) { pull(l >> i); }\n      if(((r >> i) << i) != r) { pull((r - 1) >> i); }\n    }\n  }\n};"
  // },
  // "DSUonTree": {
  //   "prefix": "DSUonTree",
  //   "body": "template<typename G> struct DSUonTree {\n private:\n  G &g;\n  int N, id, root;\n  vector<int> sz, euler, down, up;\n  int dfs1(int v, int p = -1) {\n    sz[v] = 1;\n    if((int)g[v].size() >= 2 && g[v][0] == p) { swap(g[v][0], g[v][1]); }\n    for(auto &nv : g[v]) {\n      if(nv == p) { continue; }\n      sz[v] += dfs1(nv, v);\n      if(sz[nv] > sz[g[v][0]]) { swap(nv, g[v][0]); }\n    }\n    return sz[v];\n  }\n  void dfs2(int v, int p = -1) {\n    euler[id] = v;\n    down[v] = id++;\n    for(auto &nv : g[v]) {\n      if(nv == p) { continue; }\n      dfs2(nv, v);\n    }\n    up[v] = id;\n  }\n\n public:\n  DSUonTree(G &g_, int root = 0): g(g_), N(g_.size()), sz(g_.size()), euler(g_.size()), down(g_.size()), up(g_.size()), id(0), root(root) {\n    dfs1(root);\n    dfs2(root);\n  }\n  int idx(int u) const { return down[u]; }\n  template<typename U, typename Q, typename C, typename R> void run(U &update, Q &query, C &clear, R &reset) {\n    auto dsu = [&](auto dsu, int v, int p = -1, bool keep = false) -> void {\n      for(int i = 1; i < (int)g[v].size(); i++) {\n        if(g[v][i] != p) { dsu(dsu, g[v][i], v, false); }\n      }\n      if(sz[v] != 1) { dsu(dsu, g[v][0], v, true); }\n      if(sz[v] != 1) {\n        for(int i = up[g[v][0]]; i < up[v]; i++) { update(euler[i]); }\n      }\n      update(v);\n      query(v);\n      if(!keep) {\n        for(int i = down[v]; i < up[v]; i++) { clear(euler[i]); }\n        reset();\n      }\n      return;\n    };\n    dsu(dsu, root);\n  }\n};\n// https://nyaannyaan.github.io/library/tree/dsu-on-tree.hpp.html"
  // },
  // "Parser": {
  //   "prefix": "Parser",
  //   "body": "template<typename T> struct Parser {\n private:\n  T exp(const string &s, int &p) {\n    T r = term(s, p);\n    while(s[p] == '+' || s[p] == '-') {\n      if(s[p] == '+') { r += term(s, ++p); }\n      else { r -= term(s, ++p); }\n    }\n    return r;\n  }\n  T term(const string &s, int &p) {\n    T r = fac(s, p);\n    while(s[p] == '*' || s[p] == '/') {\n      if(s[p] == '*') { r *= fac(s, ++p); }\n      else { r /= fac(s, ++p); }\n    }\n    return r;\n  }\n  T fac(const string &s, int &p) {\n    if(isdigit(s[p])) { return num(s, p); }\n    T r = exp(s, ++p);\n    p++;\n    return r;\n  }\n  T num(const string &s, int &p) {\n    T r = 0;\n    do {\n      r *= 10;\n      r += s[p++] - '0';\n    } while(isdigit(s[p]));\n    return r;\n  }\n\n public:\n  Parser() {}\n  T solve(const string &s) {\n    int p = 0;\n    return exp(s, p);\n  }\n};\n"
  // },
  // "MultiplicativeFunctionPrefixSum": {
  //   "prefix": "MultiplicativeFunctionPrefixSum",
  //   "body": "vector<int> PrimeEnum(ll n) {\n  vector<bool> sieve(n / 3 + 1, true);\n  for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {\n    if(!sieve[i]) { continue; }\n    for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }\n  }\n  vector<int> ret = {2, 3};\n  for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {\n    if(sieve[i]) { ret.emplace_back(p); }\n  }\n  while(!ret.empty() && ret.back() > n) { ret.pop_back(); }\n  return ret;\n}\n\ntemplate<typename F, typename T = mint> struct MultiplicativeFunctionPrefixSum {\n private:\n  const F &f;\n  ll M, sq, s;\n  int ps;\n  T ans;\n  vector<int> p;\n  vector<T> buf;\n  void dfs(int i, int c, ll prod, T cur) {\n    ans += cur * f(p[i], c + 1);\n    ll lim = quo(M, prod);\n    if(lim >= 1LL * p[i] * p[i]) { dfs(i, c + 1, p[i] * prod, cur); }\n    cur *= f(p[i], c);\n    ans += cur * (buf[idx(lim)] - buf[idx(p[i])]);\n    int j = i + 1;\n    for(; j < ps && p[j] < (1 << 21) && 1LL * p[j] * p[j] * p[j] <= lim; j++) { dfs(j, 1, prod * p[j], cur); }\n    for(; j < ps && 1LL * p[j] * p[j] <= lim; j++) {\n      T sm = f(p[j], 2);\n      int id1 = idx(quo(lim, p[j])), id2 = idx(p[j]);\n      sm += f(p[j], 1) * (buf[id1] - buf[id2]);\n      ans += cur * sm;\n    }\n  }\n  ll quo(ll n, ll d) { return double(n) / d; }\n  ll idx(ll n) { return n <= sq ? s - n : quo(M, n); }\n\n public:\n  MultiplicativeFunctionPrefixSum(ll m, const F &f): f(f), M(m) {\n    assert(m <= 1e15);\n    sq = sqrt(M);\n    while(sq * sq > M) { sq--; }\n    while((sq + 1) * (sq + 1) <= M) { sq++; }\n    if(M) {\n      ll hls = quo(M, sq);\n      while(hls != 1 && quo(M, hls - 1) == sq) { hls--; }\n      s = hls + sq;\n      p = PrimeEnum(sq);\n      ps = p.size();\n      ans = T{};\n    }\n  }\n  // [i] : M / i 以下の素数の個数\n  vector<T> prime() {\n    if(!M) { return {}; }\n    ll hls = s - sq;\n    vector<ll> hl(hls);\n    for(int i = 1; i < hls; i++) { hl[i] = quo(M, i) - 1; }\n    vector<int> hs(sq + 1);\n    iota(hs.begin(), hs.end(), -1);\n    int pi = 0;\n    for(auto &x : p) {\n      ll x2 = ll(x) * x, imax = min<ll>(hls, quo(M, x2) + 1);\n      for(ll i = 1, ix = x; i < imax; ++i, ix += x) { hl[i] -= (ix < hls ? hl[ix] : hs[quo(M, ix)]) - pi; }\n      for(int n = sq; n >= x2; n--) { hs[n] -= hs[quo(n, x)] - pi; }\n      pi++;\n    }\n    vector<T> res;\n    res.reserve(2 * sq + 10);\n    for(auto &i : hl) { res.push_back(i); }\n    for(int i = hs.size(); --i;) { res.push_back(hs[i]); }\n    assert((int)res.size() == s);\n    return res;\n  }\n  // [r][i] : m で割った余りが r で M / i 以下の素数の個数\n  vector<vector<T>> prime(ll m) {\n    if(m == 1) { return {prime()}; }\n    ll hls = s - sq;\n    vector<vector<ll>> hl(m, vector<ll>(hls, 0)), hs(m, vector<ll>(sq + 1, 0));\n    for(int i = 1; i < hls; i++) {\n      ll q = quo(M, i);\n      for(int j = 0; j < m && j <= q; j++) { hl[j][i] = quo(q - j, m) + (j >= 2); }\n    }\n    for(int i = 0; i <= sq; i++) {\n      for(int j = 0; j < m && j <= i; j++) { hs[j][i] = quo(i - j, m) + (j >= 2); }\n    }\n    vector<int> pi(m, 0);\n    for(auto &x : p) {\n      ll x2 = ll(x) * x, imax = min<ll>(hls, quo(M, x2) + 1);\n      for(ll i = 1, ix = x; i < imax; ++i, ix += x) {\n        for(int j = 0; j < m; j++) { hl[j * x % m][i] -= (ix < hls ? hl[j][ix] : hs[j][quo(M, ix)]) - pi[j]; }\n      }\n      for(int n = sq; n >= x2; n--) {\n        for(int j = 0; j < m; j++) { hs[j * x % m][n] -= hs[j][quo(n, x)] - pi[j]; }\n      }\n      pi[x % m]++;\n    }\n    vector<vector<T>> res(m);\n    for(ll i = 0; i < m; i++) {\n      for(auto &j : hl[i]) { res[i].push_back(j); }\n      for(int j = hs[i].size(); --j;) { res[i].push_back(hs[i][j]); }\n    }\n    assert((int)res[0].size() == s);\n    return res;\n  }\n  // i : M/i 以下の素数の総和\n  vector<T> prime_sum() {\n    if(!M) { return {}; }\n    ll hls = s - sq;\n    vector<T> h(s);\n    T inv2 = T{2}.inv();\n    for(int i = 1; i < hls; i++) {\n      T x = quo(M, i);\n      h[i] = x * (x + 1) * inv2 - 1;\n    }\n    for(int i = 1; i <= sq; i++) {\n      T x = i;\n      h[s - i] = x * (x + 1) * inv2 - 1;\n    }\n    for(auto &x : p) {\n      T xt = x, pi = h[s - x + 1];\n      ll x2 = ll(x) * x, imax = min<ll>(hls, quo(M, x2) + 1), ix = x;\n      for(ll i = 1; i < imax; ++i, ix += x) { h[i] -= ((ix < hls ? h[ix] : h[s - quo(M, ix)]) - pi) * xt; }\n      for(int n = sq; n >= x2; n--) { h[s - n] -= (h[s - quo(n, x)] - pi) * xt; }\n    }\n    assert((int)h.size() == s);\n    return h;\n  }\n  // Fp destructive\n  T solve(const vector<T> &Fp) {\n    if(!M) { return {}; }\n    assert((int)Fp.size() == s);\n    buf = Fp;\n    ans = buf[idx(M)] + 1;\n    for(int i = 0; i < ps; i++) { dfs(i, 1, p[i], 1); }\n    return ans;\n  }\n};"
  // },
  "multiplicativefunctionprefixsum": {
    "prefix": "multiplicativefunctionprefixsum",
    "body": "MultiplicativeFunctionPrefixSum<decltype($3)> $1($2,$3);$0"
  },
  "Parallel_binmin": {
    "prefix": "Parallel_binmin",
    "body": "vector<ll> L(Q, $1), R(Q, $2);\nvector<vector<ll>> ask(${3:$1 ~ $2 の個数});\nwhile(true) {\n  bool fin = true;\n  for(ll i = 0; i < Q; i++) {\n    if(R[i] - L[i] > 1) {\n      ask[(L[i] + R[i]) / 2].emplace_back(i);\n      fin = false;\n    }\n  }\n  if(fin) { break; }\n\n  for(ll Mid = $1; Mid < $2; Mid++) {\n    while(!ask[Mid].empty()) {\n      ll i = ask[Mid].back();\n      ask[Mid].pop_back();\n      bool flag = [&]() -> bool {\n        $4\n      }();\n      flag ? R[i] = Mid : L[i] = Mid;\n    }\n  }\n}"
  },
  "Parallel_binmax": {
    "prefix": "Parallel_binmax",
    "body": "vector<ll> L(Q, $1), R(Q, $2);\nvector<vector<ll>> ask(${3:$1 ~ $2 の個数});\nwhile(true) {\n  bool fin = true;\n  for(ll i = 0; i < Q; i++) {\n    if(R[i] - L[i] > 1) {\n      ask[(L[i] + R[i]) / 2].emplace_back(i);\n      fin = false;\n    }\n  }\n  if(fin) { break; }\n\n  for(ll Mid = $1; Mid < $2; Mid++) {\n    while(!ask[Mid].empty()) {\n      ll i = ask[Mid].back();\n      ask[Mid].pop_back();\n      bool flag = [&]() -> bool {\n        $4\n      }();\n      flag ? L[i] = Mid : R[i] = Mid;\n    }\n  }\n}"
  },
  // "StaticTopTree": {
  //   "prefix": "StaticTopTree",
  //   "body": "enum Type { Vertex,\n            Compress,\n            Rake,\n            Add_Edge,\n            Add_Vertex };\n\nstruct StaticTopTreeBase {\n private:\n  int add(int l, int r, Type t) {\n    if(t == Type::Compress || t == Type::Rake) { assert(l != -1 && r != -1); }\n    if(t == Type::Add_Edge) { assert(l != -1 && r == -1); }\n    assert(t != Type::Vertex && t != Type::Add_Vertex);\n    int k = P.size();\n    P.push_back(-1), L.push_back(l), R.push_back(r), T.push_back(t);\n    if(l != -1) { P[l] = k; }\n    if(r != -1) { P[r] = k; }\n    return k;\n  }\n  int add2(int k, int l, int r, Type t) {\n    assert(k < (int)g.size());\n    assert(t == Type::Vertex || t == Type::Add_Vertex);\n    if(t == Type::Vertex) { assert(l == -1 && r == -1); }\n    else { assert(l != -1 && r == -1); }\n    P[k] = -1, L[k] = l, R[k] = r, T[k] = t;\n    if(l != -1) { P[l] = k; }\n    if(r != -1) { P[r] = k; }\n    return k;\n  }\n  pair<int, int> merge(const vector<pair<int, int>> &a, Type t) {\n    assert(!a.empty());\n    if(a.size() == 1) { return a[0]; }\n    int sum = 0;\n    for(auto &[_, s] : a) { sum += s; }\n    vector<pair<int, int>> b, c;\n    for(auto &[i, s] : a) {\n      (sum > s ? b : c).emplace_back(i, s);\n      sum -= 2 * s;\n    }\n    auto [i, si] = merge(b, t);\n    auto [j, sj] = merge(c, t);\n    return {add(i, j, t), si + sj};\n  }\n  pair<int, int> compress(int i) {\n    vector<pair<int, int>> chs;\n    while(true) {\n      chs.push_back(add_vertex(i));\n      if(g[i].empty()) { break; }\n      i = g[i][0];\n    }\n    return merge(chs, Type::Compress);\n  }\n  pair<int, int> rake(int i) {\n    vector<pair<int, int>> chs;\n    for(int j = 1; j < (int)g[i].size(); j++) { chs.push_back(add_edge(g[i][j])); }\n    if(chs.empty()) { return {-1, 0}; }\n    return merge(chs, Type::Rake);\n  }\n  pair<int, int> add_edge(int i) {\n    auto [j, sj] = compress(i);\n    return {add(j, -1, Type::Add_Edge), sj};\n  }\n  pair<int, int> add_vertex(int i) {\n    auto [j, sj] = rake(i);\n    return {add2(i, j, -1, j == -1 ? Type::Vertex : Type::Add_Vertex), sj + 1};\n  }\n  void build() {\n    auto [i, n] = compress(root);\n    assert((int)g.size() == n);\n    tt_root = i;\n  }\n\n public:\n  vector<vector<int>> g;\n  int root, tt_root;\n  vector<int> P, L, R;\n  vector<Type> T;\n  StaticTopTreeBase(const Tree &t, int r = 0): g(t.size()), root(r), P(t.size(), -1), L(t.size(), -1), R(t.size(), -1), T(t.size(), Type::Vertex) {\n    const int N = g.size();\n    vector<char> f(N, false);\n    f[root] = true;\n    queue<int> q;\n    q.emplace(root);\n    while(!q.empty()) {\n      auto v = q.front();\n      q.pop();\n      for(auto &nv : t[v]) {\n        if(!f[nv]) {\n          f[nv] = true;\n          q.push(nv);\n          g[v].push_back(nv);\n        }\n      }\n    }\n    build();\n  }\n};\n\ntemplate<typename Path, typename Point, typename Vertex, typename Compress, typename Rake, typename Add_Edge, typename Add_Vertex> struct StaticTopTree {\n private:\n  void inner_update(int k) {\n    if(tt.T[k] == Type::Vertex) { path[k] = vertex(k); }\n    if(tt.T[k] == Type::Compress) { path[k] = compress(path[tt.L[k]], path[tt.R[k]]); }\n    if(tt.T[k] == Type::Rake) { point[k] = rake(point[tt.L[k]], point[tt.R[k]]); }\n    if(tt.T[k] == Type::Add_Edge) { point[k] = add_edge(path[tt.L[k]]); }\n    if(tt.T[k] == Type::Add_Vertex) { path[k] = add_vertex(point[tt.L[k]], k); }\n  }\n  void dfs(int k) {\n    if(tt.L[k] != -1) { dfs(tt.L[k]); }\n    if(tt.R[k] != -1) { dfs(tt.R[k]); }\n    inner_update(k);\n  }\n\n public:\n  const StaticTopTreeBase tt;\n  vector<Path> path;\n  vector<Point> point;\n  const Vertex vertex;\n  const Compress compress;\n  const Rake rake;\n  const Add_Edge add_edge;\n  const Add_Vertex add_vertex;\n  StaticTopTree(const Tree &g, const Vertex &vertex, const Compress &compress, const Rake &rake, const Add_Edge &add_edge, const Add_Vertex &add_vertex, int r = 0): tt(g, r), vertex(vertex), compress(compress), rake(rake), add_edge(add_edge), add_vertex(add_vertex) {\n    const int n = tt.P.size();\n    path.resize(n);\n    point.resize(n);\n    dfs(tt.tt_root);\n  }\n  Path get() { return path[tt.tt_root]; }\n  void update(int k) {\n    for(; k != -1; k = tt.P[k]) { inner_update(k); }\n  }\n};"
  // },
  "statictoptree": {
    "prefix": "statictoptree",
    "body": "using Path =\nusing Point =\nauto vertex = [&](int i) -> Path {return };\nauto compress = [&](Path p, Path c) -> Path { return  };\nauto rake = [&](Point l, Point r) -> Point { return  };\nauto add_edge = [&](Path d) -> Point { return };\nauto add_vertex = [&](Point d, int i) -> Path { return};\n\nStaticTopTree<Path, Point, decltype(vertex), decltype(compress), decltype(rake), decltype(add_edge), decltype(add_vertex)> TT(g, vertex, compress, rake, add_edge, add_vertex);"
  },
  // "ArbitraryModBinomial": {
  //   "prefix": "ArbitraryModBinomial",
  //   "body": "struct Barrett {\n  using ull = unsigned long long;\n  unsigned m;\n  ull im;\n  Barrett(): m(), im() {}\n  Barrett(int n): m(n), im(ull(-1) / m + 1) {}\n  constexpr inline ll quo(ull n) {\n    ull x = ull((__uint128_t(n) * im) >> 64);\n    unsigned r = n - x * m;\n    return m <= r ? x - 1 : x;\n  }\n  constexpr inline ll rem(ull n) {\n    ull x = ull((__uint128_t(n) * im) >> 64);\n    unsigned r = n - x * m;\n    return m <= r ? r + m : r;\n  }\n  constexpr inline pair<ll, int> quorem(ull n) {\n    ull x = ull((__uint128_t(n) * im) >> 64);\n    unsigned r = n - x * m;\n    if(m <= r) { return {x - 1, r + m}; }\n    return {x, r};\n  }\n  constexpr inline ll pow(ull n, ll p) {\n    unsigned a = rem(n), r = m == 1 ? 0 : 1;\n    while(p) {\n      if(p & 1) { r = rem(ull(r) * a); }\n      a = rem(ull(a) * a);\n      p >>= 1;\n    }\n    return r;\n  }\n};\n\nstruct PrimePowerBinomial {\n  int p, q, M;\n  vector<int> fac, finv, inv;\n  int delta;\n  Barrett bm, bp;\n\n  PrimePowerBinomial(int _p, int _q): p(_p), q(_q) {\n    assert(1 < p && p <= (1LL << 30) - 1);\n    assert(_q > 0);\n    ll m = 1;\n    while(_q--) {\n      m *= p;\n      assert(m <= (1LL << 30) - 1);\n    }\n    M = m;\n    bm = Barrett(M), bp = Barrett(p);\n    enumerate();\n    delta = (p == 2 && q >= 3) ? 1 : M - 1;\n  }\n  void enumerate() {\n    int MX = min<int>(M, 20000010);\n    fac.resize(MX);\n    finv.resize(MX);\n    inv.resize(MX);\n    fac[0] = finv[0] = inv[0] = 1;\n    fac[1] = finv[1] = inv[1] = 1;\n    for(int i = 2; i < MX; i++) {\n      if(i % p == 0) {\n        fac[i] = fac[i - 1];\n        fac[i + 1] = bm.rem(1LL * fac[i - 1] * (i + 1));\n        i++;\n      }\n      else { fac[i] = bm.rem(1LL * fac[i - 1] * i); }\n    }\n    finv[MX - 1] = bm.pow(fac[MX - 1], M / p * (p - 1) - 1);\n    for(int i = MX - 2; i > 1; --i) {\n      if(i % p == 0) {\n        finv[i] = bm.rem(1LL * finv[i + 1] * (i + 1));\n        finv[i - 1] = finv[i];\n        i--;\n      }\n      else { finv[i] = bm.rem(1LL * finv[i + 1] * (i + 1)); }\n    }\n  }\n\n  ll Lucas(ll n, ll m) {\n    int res = 1;\n    while(n) {\n      int n0, m0;\n      tie(n, n0) = bp.quorem(n);\n      tie(m, m0) = bp.quorem(m);\n      if(n0 < m0) { return 0; }\n      res = bm.rem(1LL * res * fac[n0]);\n      int buf = bm.rem(1LL * finv[n0 - m0] * finv[m0]);\n      res = bm.rem(1LL * res * buf);\n    }\n    return res;\n  }\n\n  ll C(ll n, ll m) {\n    if(n < m || n < 0 || m < 0) return 0;\n    if(q == 1) return Lucas(n, m);\n    ll r = n - m;\n    int e0 = 0, eq = 0, i = 0;\n    int res = 1;\n    while(n) {\n      res = bm.rem(1LL * res * fac[bm.rem(n)]);\n      res = bm.rem(1LL * res * finv[bm.rem(m)]);\n      res = bm.rem(1LL * res * finv[bm.rem(r)]);\n      n = bp.quo(n);\n      m = bp.quo(m);\n      r = bp.quo(r);\n      int eps = n - m - r;\n      e0 += eps;\n      if(e0 >= q) { return 0; }\n      if(++i >= q) { eq += eps; }\n    }\n    if(eq & 1) { res = bm.rem(1LL * res * delta); }\n    res = bm.rem(1LL * res * bm.pow(p, e0));\n    return res;\n  }\n};\n\n// constraints:\n// (M <= 1e7 and max(N) <= 1e18) or (M < 2^30 and max(N) <= 2e7)\nstruct ArbitraryModBinomial {\n  int mod;\n  vector<int> M;\n  vector<PrimePowerBinomial> cs;\n  ArbitraryModBinomial(ll md): mod(md) {\n    assert(1 <= md);\n    assert(md <= (1LL << 30) - 1);\n    for(int i = 2; i * i <= md; i++) {\n      if(md % i == 0) {\n        int j = 0, k = 1;\n        while(md % i == 0) {\n          md /= i;\n          j++;\n          k *= i;\n        }\n        M.push_back(k);\n        cs.emplace_back(i, j);\n        assert(M.back() == cs.back().M);\n      }\n    }\n    if(md != 1) {\n      M.push_back(md);\n      cs.emplace_back(md, 1);\n    }\n    assert(M.size() == cs.size());\n  }\n  ll C(ll n, ll m) {\n    if(mod == 1) { return 0; }\n    vector<ll> rem, d;\n    for(int i = 0; i < (int)cs.size(); i++) {\n      rem.push_back(cs[i].C(n, m));\n      d.push_back(M[i]);\n    }\n    return atcoder::crt(rem, d).first;\n  }\n  ll operator()(ll n, ll m) { return C(n, m); }\n};"
  // },
  // "MultiplicativeConvolution": {
  //   "prefix": "MultiplicativeConvolution",
  //   "body": "#include <atcoder/internal_math>\ntemplate<typename T> vector<mint> MultiplicativeConvolution(const vector<T> &a, const vector<T> &b, int P) {\n  int r = internal::primitive_root_constexpr(P);\n  vector<ll> p(P), ip(P);\n  p[0] = 1;\n  for(int i = 0; i < P - 1; i++) {\n    p[i + 1] = p[i] * r % P;\n    ip[p[i]] = i;\n  }\n  vector<mint> s(P - 1), t(P - 1);\n  for(int i = 0; i < P - 1; i++) {\n    s[i] = a[p[i]];\n    t[i] = b[p[i]];\n  }\n  auto u = convolution(s, t);\n  for(int i = P - 1; i < (int)u.size(); i++) { u[i % (P - 1)] += u[i]; }\n  vector<mint> ret(P);\n  mint sa = accumulate(a.begin(), a.end(), mint{}), sb = accumulate(b.begin(), b.end(), mint{});\n  ret[0] = sa * b[0] + sb * a[0] - a[0] * b[0];\n  for(int i = 1; i < P; i++) { ret[i] = u[ip[i]]; }\n  return ret;\n}"
  // },
  // "FunctionalGraph": {
  //   "prefix": "FunctionalGraph",
  //   "body": "struct FunctionalGraph {\n private:\n  const int V;\n  int id;\n  vector<int> nx;\n  void make_loop(const int s, int v, vector<int> &vec) {\n    while(nx[v] != s) {\n      vec.emplace_back(nx[v]);\n      vis[nx[v]] = id;\n      v = nx[v];\n    }\n  }\n  int dfs(int v, vector<int> &vec) {\n    vis[v] = -id;\n    ll nv = nx[v];\n    if(vis[nv] == -id) {\n      vec.emplace_back(v);\n      vec.emplace_back(nv);\n      vis[v] = vis[nv] = id;\n      make_loop(v, nv, vec);\n      id++;\n      return 0;\n    }\n    else if(!vis[nv]) {\n      const int res = dfs(nv, vec);\n      if(!res) { return 0; }\n      else { return vis[v] = res; }\n    }\n    return vis[v] = (vis[nv] > 0 ? -vis[nv] : vis[nv]);\n  }\n  void make_graph() {\n    graph.resize(V);\n    for(int i = 0; i < V; i++) {\n      if(vis[i] < 0) { graph[nx[i]].emplace_back(i); }\n    }\n  }\n\n public:\n  vector<int> vis;\n  vector<vector<int>> loop, graph;\n  FunctionalGraph(const int N): V(N), id(1), nx(N, 0), vis(N, 0) {}\n  template<typename T> FunctionalGraph(const vector<T> &v): V(v.size()), id(1), nx(V, 0), vis(V, 0) {\n    for(int i = 0; i < V; i++) { add_edge(i, v[i]); }\n    build();\n  }\n  void add_edge(int u, int v) {\n    nx[u] = v;\n    if(u == nx[u]) {\n      vis[u] = id++;\n      loop.push_back({u});\n    }\n  }\n  void build() {\n    for(int i = 0; i < V; i++) {\n      if(!vis[i]) {\n        vector<int> vec;\n        dfs(i, vec);\n        if(!vec.empty()) { loop.push_back(move(vec)); }\n      }\n    }\n    make_graph();\n  }\n};"
  // },
  "argsort": {
    "prefix": "argsort",
    "body": "ranges::sort(ord, [&](auto i, auto j) { return atan2(Y[i], X[i]) < atan2(Y[j], X[j]); });"
  },
  // "QueueAggregation": {
  //   "prefix": "QueueAggregation",
  //   "body": "template<typename T, auto op, auto e> struct QueueAggregation {\n private:\n  vector<T> a0, a1, r0, r1;\n  T f0, f1;\n  void push0(const T &x) {\n    a0.push_back(x);\n    r0.push_back(f0 = op(x, f0));\n  }\n  void push1(const T &x) {\n    a1.push_back(x);\n    r1.push_back(f1 = op(f1, x));\n  }\n  void transfer() {\n    while(!a1.empty()) {\n      push0(a1.back());\n      a1.pop_back();\n    }\n    while(!r1.empty()) { r1.pop_back(); }\n    f1 = e();\n  }\n\n public:\n  QueueAggregation(): f0(e()), f1(e()){};\n  void push(const T &x) {\n    if(a0.empty()) {\n      push0(x);\n      transfer();\n    }\n    else { push1(x); }\n  }\n  void pop() {\n    if(a0.empty()) { transfer(); }\n    a0.pop_back();\n    r0.pop_back();\n    f0 = (r0.empty() ? e() : r0.back());\n  }\n  T prod() { return op(f0, f1); }\n};"
  // },
  "queueaggregation": {
    "prefix": "queueaggregation",
    "body": "QueueAggregation<T,op,e> Q;"
  },
  // "WaveletMatrixRectangleSum": {
  //   "prefix": "WaveletMatrixRectangleSum",
  //   "body": "struct SuccinctIndexableDictionary {\n  unsigned len, blk;\n  vector<unsigned> bit, sum;\n  SuccinctIndexableDictionary() = default;\n  SuccinctIndexableDictionary(unsigned len): len(len), blk((len + 31) >> 5) {\n    bit.assign(blk, 0U);\n    sum.assign(blk, 0U);\n  }\n  void set(int k) { bit[k >> 5] |= 1U << (k & 31); }\n  void build() {\n    sum[0] = 0U;\n    for(unsigned i = 1; i < blk; i++) { sum[i] = sum[i - 1] + __builtin_popcount(bit[i - 1]); }\n  }\n  bool operator[](ll k) { return (bool((bit[k >> 5] >> (k & 31)) & 1)); }\n  int rank(int k) { return (sum[k >> 5] + __builtin_popcount(bit[k >> 5] & ((1U << (k & 31)) - 1))); }\n  int rank(bool val, int k) { return (val ? rank(k) : k - rank(k)); }\n};\n\ntemplate<typename T, int MAXLOG> struct WaveletMatrixRectangleSum {\n  int len;\n  SuccinctIndexableDictionary mat[MAXLOG];\n  vector<T> ws[MAXLOG];\n  int mid[MAXLOG];\n  WaveletMatrixRectangleSum() = default;\n  WaveletMatrixRectangleSum(const vector<T> &v, const vector<T> &w): len(v.size()) {\n    assert(v.size() == w.size());\n    vector<int> l(len), r(len), ord(len);\n    iota(ord.begin(), ord.end(), 0);\n    for(int lev = MAXLOG - 1; lev >= 0; lev--) {\n      mat[lev] = SuccinctIndexableDictionary(len + 1);\n      int left = 0, right = 0;\n      for(int i = 0; i < len; i++) {\n        if((v[ord[i]] >> lev) & 1) {\n          mat[lev].set(i);\n          r[right++] = ord[i];\n        }\n        else { l[left++] = ord[i]; }\n      }\n      mid[lev] = left;\n      mat[lev].build();\n      ord.swap(l);\n      for(int i = 0; i < right; i++) { ord[left + i] = r[i]; }\n      ws[lev].resize(len + 1);\n      ws[lev][0] = 0;\n      for(int i = 0; i < len; i++) { ws[lev][i + 1] = ws[lev][i] + w[ord[i]]; }\n    }\n  }\n  pair<int, int> succ(bool f, int l, int r, int lev) { return {mat[lev].rank(f, l) + mid[lev] * f, mat[lev].rank(f, r) + mid[lev] * f}; }\n  T sum(int l, int r, T upper) {\n    T ret = 0;\n    for(int lev = MAXLOG - 1; lev >= 0; lev--) {\n      bool f = (upper >> lev) & 1;\n      if(f) { ret += ws[lev][mat[lev].rank(false, r)] - ws[lev][mat[lev].rank(false, l)]; }\n      tie(l, r) = succ(f, l, r, lev);\n    }\n    return ret;\n  }\n  T sum(int l, int r, T lower, T upper) { return sum(l, r, upper) - sum(l, r, lower); }\n};\n\ntemplate<typename T = ll, int MAXLOG = 20> struct CompressedWaveletMatrixRectangleSum {\n  WaveletMatrixRectangleSum<T, MAXLOG> mat;\n  vector<T> ys;\n  CompressedWaveletMatrixRectangleSum(const vector<T> &v, const vector<T> &w): ys(v) {\n    ranges::sort(ys);\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    vector<T> t(v.size());\n    for(int i = 0; i < (int)v.size(); i++) { t[i] = get(v[i]); }\n    mat = WaveletMatrixRectangleSum<ll, MAXLOG>(t, w);\n  }\n  inline int get(const T &x) { return ranges::lower_bound(ys, x) - ys.begin(); }\n  T sum(int l, int r, T upper) { return mat.sum(l, r, get(upper)); }\n  T sum(int l, int r, T lower, T upper) { return mat.sum(l, r, get(lower), get(upper)); }\n};"
  // },
  "waveletmatrixrectanglesum": {
    "prefix": "waveletmatrixrectanglesum",
    "body": "CompressedWaveletMatrixRectangleSum<> W($0);"
  },
  // "WaveletMatrixPointAddRectangleSum": {
  //   "prefix": "WaveletMatrixPointAddRectangleSum",
  //   "body": "struct SuccinctIndexableDictionary {\n  unsigned len, blk;\n  vector<unsigned> bit, sum;\n  SuccinctIndexableDictionary() = default;\n  SuccinctIndexableDictionary(unsigned len): len(len), blk((len + 31) >> 5) {\n    bit.assign(blk, 0U);\n    sum.assign(blk, 0U);\n  }\n  void set(int k) { bit[k >> 5] |= 1U << (k & 31); }\n  void build() {\n    sum[0] = 0U;\n    for(unsigned i = 1; i < blk; i++) { sum[i] = sum[i - 1] + __builtin_popcount(bit[i - 1]); }\n  }\n  bool operator[](ll k) { return (bool((bit[k >> 5] >> (k & 31)) & 1)); }\n  int rank(int k) { return (sum[k >> 5] + __builtin_popcount(bit[k >> 5] & ((1U << (k & 31)) - 1))); }\n  int rank(bool val, int k) { return (val ? rank(k) : k - rank(k)); }\n};\n\ntemplate<typename T, int MAXLOG> struct WaveletMatrixPointAddRectangleSum {\n  int len;\n  SuccinctIndexableDictionary mat[MAXLOG];\n  fenwick_tree<T> ws[MAXLOG];\n  vector<T> v;\n  int mid[MAXLOG];\n  WaveletMatrixPointAddRectangleSum() = default;\n  WaveletMatrixPointAddRectangleSum(const vector<T> &v, const vector<T> &w): len(v.size()), v(v) {\n    assert(v.size() == w.size());\n    vector<int> l(len), r(len), ord(len);\n    iota(ord.begin(), ord.end(), 0);\n    vector<T> dd(len);\n    for(int lev = MAXLOG - 1; lev >= 0; lev--) {\n      mat[lev] = SuccinctIndexableDictionary(len + 1);\n      int left = 0, right = 0;\n      for(int i = 0; i < len; i++) {\n        if((v[ord[i]] >> lev) & 1) {\n          mat[lev].set(i);\n          r[right++] = ord[i];\n        }\n        else { l[left++] = ord[i]; }\n      }\n      mid[lev] = left;\n      mat[lev].build();\n      ord.swap(l);\n      for(int i = 0; i < right; i++) { ord[left + i] = r[i]; }\n      for(int i = 0; i < len; i++) { dd[i] = w[ord[i]]; }\n      ws[lev] = fenwick_tree<T>(dd);\n    }\n  }\n  pair<int, int> succ(bool f, int l, int r, int lev) { return {mat[lev].rank(f, l) + mid[lev] * f, mat[lev].rank(f, r) + mid[lev] * f}; }\n  void add(int k, const T &x) {\n    auto &y = v[k];\n    for(int lev = MAXLOG - 1; lev >= 0; lev--) {\n      bool f = (y >> lev) & 1;\n      k = mat[lev].rank(f, k) + mid[lev] * f;\n      ws[lev].apply(k, x);\n    }\n  }\n  T sum(int l, int r, T upper) {\n    T ret = 0;\n    for(int lev = MAXLOG - 1; lev >= 0; lev--) {\n      if((upper >> lev) & 1) {\n        auto nx = succ(false, l, r, lev);\n        ret += ws[lev].prod(nx.first, nx.second);\n        l = l - nx.first + mid[lev];\n        r = r - nx.second + mid[lev];\n      }\n      else { tie(l, r) = succ(false, l, r, lev); }\n    }\n    return ret;\n  }\n  T sum(int l, int r, T lower, T upper) { return sum(l, r, upper) - sum(l, r, lower); }\n};\n\ntemplate<typename T = ll, int MAXLOG = 20> struct CompressedWaveletMatrixPointAddRectangleSum {\n  WaveletMatrixPointAddRectangleSum<int, MAXLOG> mat;\n  vector<T> ys;\n  CompressedWaveletMatrixPointAddRectangleSum(const vector<T> &v, const vector<T> &w): ys(v) {\n    ranges::sort(ys);\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    vector<T> t(v.size());\n    for(int i = 0; i < (int)v.size(); i++) { t[i] = get(v[i]); }\n    mat = WaveletMatrixPointAddRectangleSum<T, MAXLOG>(t, w);\n  }\n  inline int get(const T &x) { return lower_bound(begin(ys), end(ys), x) - begin(ys); }\n  void add(int k, const T &x) { mat.add(k, x); }\n  T sum(int l, int r, T upper) { return mat.sum(l, r, get(upper)); }\n  T sum(int l, int r, T lower, T upper) { return mat.sum(l, r, get(lower), get(upper)); }\n};"
  // },
  "waveletmatrixpointaddrectanglesum": {
    "prefix": "waveletmatrixpointaddrectanglesum",
    "body": "CompressedWaveletMatrixPointAddRectangleSum<> W($0);"
  },
  "CumulativeSum": {
    "prefix": "CumulativeSum",
    "body": "template<typename T> struct CumulativeSum {\n  ll N;\n  vector<ll> S;\n  CumulativeSum(vector<T> &v): N(v.size()), S({0}) {\n    for(auto &i : v) { S.emplace_back(S.back() + i); }\n  }\n  T operator()(ll l, ll r) { return S[r] - S[l]; }\n};"
  },
  "cumulativesum": {
    "prefix": "cumulativesum",
    "body": "CumulativeSum $0"
  },
  "Grid": {
    "prefix": "Grid",
    "body": "constexpr int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconstexpr int DX[8] = {1, 1, 0, -1, -1, -1, 0, 1}, DY[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\ntemplate<typename T> struct Grid : vector<vector<T>> {\n  using vector<vector<T>>::vector;\n  using vector<vector<T>>::operator=;\n  Grid() {}\n  Grid(ll N) { *this = vector<vector<T>>(N, vector<T>(N)); }\n  Grid(ll H, ll W, T x = 0) { *this = vector<vector<T>>(H, vector<T>(W, x)); }\n  Grid(vector<vector<T>> v) { *this = v; }\n  ll operator()(ll i, ll j) const { return i * (*this)[0].size() + j; }\n  pair<ll, ll> operator()(ll i) const { return {i / (*this)[0].size(), i % (*this)[0].size()}; };\n  void rotate() {\n    const int H = this->size(), W = (*this)[0].size();\n    vector<vector<T>> r(W, vector<ll>(H));\n    for(ll i = 0; i < H; i++) {\n      for(ll j = 0; j < W; j++) { r[j][H - 1 - i] = (*this)[i][j]; }\n    }\n    this->swap(r);\n  }\n};"
  },
  "grid": {
    "prefix": "grid",
    "body": "Grid<ll> $0"
  },
  "grid4": {
    "prefix": "grid4",
    "body": "for(ll i=0;i<4;i++){\n  ll nx=x+dx[i],ny=y+dy[i];\n  if(nx<0||nx>=H||ny<0||ny>=W) {continue;}\n  if(v[nx][ny]=='#'){continue;}\n  $1\n}"
  },
  "DigitSetDP": {
    "prefix": "DigitSetDP",
    "body": "ll dp[20][1 << 10][2][2]{};\ndp[0][0][0][0] = 1;\n\nfor(ll i = 0; i < (ll)S.size(); i++) {\n  for(ll j = 0; j < 1 << 10; j++) {\n    for(ll k = 0; k < 10; k++) {\n      ll nj = j | (1 << k);\n      if(k < S[i] - '0') {\n        if(!k) {\n          dp[i + 1][j][1][0] += dp[i][j][0][0] + dp[i][j][1][0];\n          dp[i + 1][nj][1][1] += dp[i][j][0][1] + dp[i][j][1][1];\n        }\n        else { dp[i + 1][nj][1][1] += dp[i][j][0][0] + dp[i][j][0][1] + dp[i][j][1][0] + dp[i][j][1][1]; }\n      }\n      else if(k == S[i] - '0') {\n        if(!k) {\n          dp[i + 1][j][0][0] += dp[i][j][0][0];\n          dp[i + 1][j][1][0] += dp[i][j][1][0];\n          dp[i + 1][nj][0][1] += dp[i][j][0][1];\n          dp[i + 1][nj][1][1] += dp[i][j][1][1];\n        }\n        else {\n          dp[i + 1][nj][0][1] += dp[i][j][0][0] + dp[i][j][0][1];\n          dp[i + 1][nj][1][1] += dp[i][j][1][0] + dp[i][j][1][1];\n        }\n      }\n      else {\n        dp[i + 1][nj][1][1] += dp[i][j][1][0] + dp[i][j][1][1];\n      }\n    }\n  }\n}"
  },
  // "MaxSubsetXor": {
  //   "prefix": "MaxSubsetXor",
  //   "body": "ll MaxSubsetXor(vector<ll> v) {\n  ll N = v.size(), idx = 0;\n  for(ll i = 60; i >= 0; i--) {\n    ll midx = idx, mx = -1e18;\n    for(ll j = idx; j < N; j++) {\n      if(v[j] & (1LL << i) && v[j] > mx) {\n        mx = v[j];\n        midx = j;\n      }\n    }\n    if(mx == -1e18) { continue; }\n    swap(v[idx], v[midx]);\n    midx = idx;\n    for(ll j = 0; j < N; j++) {\n      if(j != midx && v[j] & (1LL << i)) { v[j] ^= v[midx]; }\n    }\n    idx++;\n  }\n  ll r = 0;\n  for(ll i = 0; i < N; i++) { r ^= v[i]; }\n  return r;\n}"
  // },
  "maxsubsetxor": {
    "prefix": "maxsubsetxor",
    "body": "MaxSubsetXor($0)"
  },
  // "PowerSum": {
  //   "prefix": "PowerSum",
  //   "body": "// 1^i + 2^i + ... + N^i  for  i∈[1,K]\nFPS PowerSum(ll N, ll K) {\n  FPS f{0, N + 1}, g{0, 1}, r(K + 1);\n  f = f.exp(K + 2), g = g.exp(K + 2);\n  f[0]--, g[0]--;\n  for(ll i = 0; i <= K; i++) { f[i] = f[i + 1]; }\n  for(ll i = 0; i <= K; i++) { g[i] = g[i + 1]; }\n  f.pop_back(), g.pop_back();\n  f /= g;\n  mint fac = 1;\n  for(ll i = 1; i <= K; fac *= (++i)) { r[i] = f[i] * fac; }\n  return r;\n}"
  // },
  // "PersistentSegmentTree": {
  //   "prefix": "PersistentSegmentTree",
  //   "body": "template<typename T, auto op, auto e> struct PersistentSegmentTree {\n  struct Node {\n    T d;\n    Node *l, *r;\n  };\n  using NP = Node *;\n\n private:\n  int N{};\n  NP merge(NP l, NP r) { return new Node{op(l->d, r->d), l, r}; }\n  NP build(int l, int r, const vector<T> &v) const {\n    if(l + 1 == r) { return new Node{v[l], nullptr, nullptr}; }\n    return merge(build(l, (l + r) >> 1, v), build((l + r) >> 1, r, v));\n  }\n  NP set(int a, const T &x, NP k, int l, int r) const {\n    if(r <= a || a + 1 <= l) { return k; }\n    else if(a <= l && r <= a + 1) { return new Node{x, nullptr, nullptr}; }\n    else { return merge(set(a, x, k->l, l, (l + r) >> 1), set(a, x, k->r, (l + r) >> 1, r)); }\n  }\n  NP apply(int a, const T &x, NP k, int l, int r) const {\n    if(r <= a || a + 1 <= l) { return k; }\n    else if(a <= l && r <= a + 1) { return new Node{op(k->d, x), nullptr, nullptr}; }\n    else { return merge(apply(a, x, k->l, l, (l + r) >> 1), apply(a, x, k->r, (l + r) >> 1, r)); }\n  }\n  T prod(int a, int b, NP k, int l, int r) const {\n    if(r <= a || b <= l) { return e(); }\n    else if(a <= l && r <= b) { return k->d; }\n    else { return op(prod(a, b, k->l, l, (l + r) >> 1), prod(a, b, k->r, (l + r) >> 1, r)); }\n  }\n\n public:\n  PersistentSegmentTree() = default;\n  PersistentSegmentTree(int N): N(N) {}\n  NP build(const vector<T> &v) const {\n    assert(N == (int)v.size());\n    return build(0, N, v);\n  }\n  NP set(NP t, int k, const T &x) const { return set(k, x, t, 0, N); }\n  T get(NP t, int k) const {\n    for(int l = 0, r = N; l + 1 < r;) {\n      int p = (l + r) >> 1;\n      if(k < p) {\n        t = t->l;\n        r = p;\n      }\n      else {\n        t = t->r;\n        l = p;\n      }\n    }\n    return t->d;\n  }\n  NP apply(NP t, int k, const T &x) { return apply(k, x, t, 0, N); }\n  T prod(NP t, int a, int b) const { return prod(a, b, t, 0, N); }\n  T all_prod(NP t) const { return t->d; }\n};"
  // },
  "persistentsegmenttree": {
    "prefix": "persistentsegmenttree",
    "body": "PersistentSegmentTree<T,op,e> S($0);"
  },
  // "RangeCountQuery": {
  //   "prefix": "RangeCountQuery",
  //   "body": "template<typename T> struct RangeCountQuery {\n  int N;\n  vector<vector<ll>> idx;\n  RangeCountQuery() {};\n  RangeCountQuery(const vector<T> &v): N(ranges::max(v) + 1), idx(N) {\n    for(int i = 0; i < (int)v.size(); i++) { idx[v[i]].emplace_back(i); }\n  }\n  int query(int l, int r, int x) {\n    if(l >= r || x < 0 || x > N) { return 0; }\n    return ranges::lower_bound(idx[x], r) - ranges::lower_bound(idx[x], l);\n  }\n};"
  // },
  // "CompressedRangeCountQuery": {
  //   "prefix": "CompressedRangeCountQuery",
  //   "body": "template<typename T> struct CompressedRangeCountQuery {\n  vector<T> v;\n  vector<vector<ll>> idx;\n  CompressedRangeCountQuery() {}\n  CompressedRangeCountQuery(const vector<T> &v_): v(v_) {\n    ranges::sort(v);\n    v.erase(unique(v.begin(), v.end()), v.end());\n    idx.resize(v.size());\n    for(int i = 0; i < (int)v_.size(); i++) { idx[ranges::lower_bound(v, v_[i]) - v.begin()].emplace_back(i); }\n  }\n  int query(int l, int r, T x) {\n    if(l>=r||!ranges::binary_search(v, x)) { return 0; }\n    x = ranges::lower_bound(v, x) - v.begin();\n    return ranges::lower_bound(idx[x], r) - ranges::lower_bound(idx[x], l);\n  }\n};"
  // },
  // "EnumCombination": {
  //   "prefix": "EnumCombination",
  //   "body": "vector<vector<ll>> EnumCombination(int n, int k) {\n  vector<vector<ll>> r;\n  vector<ll> v(k);\n  auto DFS = [&](auto &&DFS, int p, int s) -> void {\n    if(p == k) {\n      r.emplace_back(v);\n      return;\n    }\n    for(ll i = s + 1; i < n; i++) {\n      v[p] = i;\n      DFS(DFS, p + 1, i);\n    }\n  };\n  DFS(DFS, 0, -1);\n  return r;\n}"
  // },
  // "RangeMaximumSumQuery": {
  //   "prefix": "RangeMaximumSumQuery",
  //   "body": "constexpr ll INF = 1e18;\nstruct T {\n  ll sum, val, l, r;\n};\nT op(T l, T r) { return {l.sum + r.sum, max({l.val, r.val, l.r + r.l}), max(l.l, l.sum + r.l), max(l.r + r.sum, r.r)}; }\nT e() { return {0, -INF, -INF, -INF}; }\n\ntemplate<bool min = false> struct RangeMaximumSumQuery {\n  segtree<T, op, e> S;\n  RangeMaximumSumQuery(const vector<ll> &v): S(v.size()) {\n    for(int i = 0; i < (int)v.size(); i++) { set(i, v[i]); }\n  }\n  void set(ll i, ll x) {\n    if(min) { x = -x; }\n    S.set(i, {x, x, x, x});\n  }\n  ll prod(ll l, ll r) { return min ? -S.prod(l, r).val : S.prod(l, r).val; }\n  ll all_prod() { return min ? -S.all_prod().val : S.all_prod().val; }\n};"
  // },
  // "RangeMaximumDifferenceQuery": {
  //   "prefix": "RangeMaximuiDifferenceQuery",
  //   "body": "constexpr ll INF = 1e18;\nstruct T {\n  ll sum, val, l, r;\n};\nT op(T l, T r) { return {l.sum + r.sum, max({l.val, r.val, l.r + r.l}), max(l.l, l.sum + r.l), max(l.r + r.sum, r.r)}; }\nT e() { return {0, -INF, -INF, -INF}; }\n\ntemplate<bool min = false> struct RangeMaximumDifferenceQuery {\n  int N;\n  vector<ll> v;\n  segtree<T, op, e> S;\n  RangeMaximumDifferenceQuery(const vector<ll> &v_): N(v_.size()), v(v_), S(N - 1) {\n    for(ll i = 0; i < N - 1; i++) {\n      ll x = v[i + 1] - v[i];\n      if(min) { x = -x; }\n      S.set(i, {x, x, x, x});\n    }\n  }\n  void set(ll i, ll x) {\n    v[i] = x;\n    if(i) {\n      ll d = v[i] - v[i - 1];\n      if(min) { d = -d; }\n      S.set(i - 1, {d, d, d, d});\n    }\n    if(i != N - 1) {\n      ll d = v[i + 1] - v[i];\n      if(min) { d = -d; }\n      S.set(i, {d, d, d, d});\n    }\n  }\n  ll prod(ll l, ll r) {\n    return min ? -S.prod(l, r).val : S.prod(l, r).val;\n  }\n  ll all_prod() {\n    return min ? -S.all_prod().val : S.all_prod().val;\n  }\n};"
  // },
  // "RectangleUnionArea": {
  //   "prefix": "RectangleUnionArea",
  //   "body": "using T = pair<ll, ll>;\nusing F = ll;\nT op(T l, T r) {\n  if(l.first != r.first) { return min(l, r); }\n  return {l.first, l.second + r.second};\n}\nT e() { return {1e18, 0}; }\nT fx(F f, T x) { return {x.first + f, x.second}; }\nF fg(F f, F g) { return f + g; }\nF id() { return 0; }\n\nstruct RectangleUnionArea {\n  vector<array<ll, 4>> v;\n  RectangleUnionArea() {}\n  RectangleUnionArea(ll N) { v.reserve(N); }\n  void add(ll lx, ll rx, ll ly, ll ry) { v.push_back({lx, rx, ly, ry}); }\n  ll build() {\n    if(v.empty()) { return 0; }\n    ll N = v.size();\n    struct event {\n      ll x, ly, ry;\n      bool add;\n    };\n    vector<event> ev;\n    vector<T> y;\n    for(int i = 0; i < N; i++) {\n      auto [l, r, d, u] = v[i];\n      y.emplace_back(d, i);\n      y.emplace_back(u, i + N);\n    }\n    ranges::sort(y);\n    vector<T> dy;\n    ll uniy = 0, py = y[0].first;\n    for(int i = 0; i < 2 * N; i++) {\n      if(y[i].first != py) {\n        dy.emplace_back(0, y[i].first - py);\n        py = y[i].first;\n        uniy++;\n      }\n      if(y[i].second < N) { v[y[i].second][2] = uniy; }\n      else { v[y[i].second - N][3] = uniy; }\n    }\n    for(auto &[l, r, d, u] : v) {\n      ev.push_back(event{l, d, u, true});\n      ev.push_back(event{r, d, u, false});\n    }\n    sort(ev.begin(), ev.end(), [](auto &l, auto &r) { return l.x < r.x; });\n    ll Y = y.back().first - y[0].first;\n    lazy_segtree<T, op, e, F, fx, fg, id> S(dy);\n    ll ans = 0;\n    for(ll i = 0, cx = 0; i < 2 * N; i++) {\n      auto [x, ly, ry, add] = ev[i];\n      auto [m, cm] = S.all_prod();\n      ll dx = x - cx;\n      ans += m ? Y * dx : (Y - cm) * dx;\n      cx = x;\n      add ? S.apply(ly, ry, 1) : S.apply(ly, ry, -1);\n    }\n    return ans;\n  }\n};"
  // }
  "lib": {
    "prefix": "@",
    "body": "#include<lib$0"
  }
}

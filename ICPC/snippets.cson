# Your snippets
#
# Pulsar snippets allow you to enter a simple prefix in the editor and hit tab to
# expand the prefix into a larger code block with templated values.
#
# You can create a new snippet in this file by typing "snip" and then hitting
# tab.
#
# An example CoffeeScript snippet to expand log to console.log:
#
# '.source.coffee':
#   'Console log':
#     'prefix': 'log'
#     'body': 'console.log $1'
#
# Each scope (e.g. '.source.coffee' above) can only be declared once.
#
# This file uses CoffeeScript Object Notation (CSON).
# If you are unfamiliar with CSON, you can read more about it in the
# Pulsar Launch Manual:
# https://pulsar-edit.dev/docs/launch-manual/sections/using-pulsar/#configuring-with-cson

'.source.cpp':
  'ini':
    'prefix':'ini'
    'body':"""
    #include<bits/stdc++.h>
    using namespace std;
    using ll=long long;

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      $1
    }
    """

  'ini2':
    'prefix':'ini2'
    'body':"""
    #include<bits/stdc++.h>
    using namespace std;
    using ll=long long;

    void solve(){
      $1
    }

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      ll t;
      cin>>t;
      while(t--){ solve(); }
    }
    """

  'inib':
    'prefix':'inib'
    'body':"""
    #include<bits/stdc++.h>
    using namespace std;
    using ll=long long;

    bool solve(){
      $1
    }

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      ll t;
      cin>>t;
      while(t--){ cout << (solve() ? "Yes" : "No") << "\\\\n"; }
    }
    """

  'ini0':
    'prefix':'ini0'
    'body':"""
    #include<bits/stdc++.h>
    #include<atcoder/modint>
    using namespace std;
    using namespace atcoder;
    using ll=long long;
    using mint=modint1000000007;

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      $1
    }
    """

  'ini9':
    'prefix':'ini9'
    'body':"""
    #include<bits/stdc++.h>
    #include<atcoder/modint>
    using namespace std;
    using namespace atcoder;
    using ll=long long;
    using mint=modint998244353;

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      $1
    }
    """

  'ini_arbitrary':
    'prefix':'ini_arbitrary'
    'body':"""
    #include<bits/stdc++.h>
    #include<atcoder/modint>
    using namespace std;
    using namespace atcoder;
    using ll=long long;
    using mint=modint;

    int main(){
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      $1
      modint::set_mod();
    }
    """

  'atcoder':
    'prefix':'atcoder'
    'body':"""
    #include<atcoder/${1:all}>
    using namespace atcoder;
    """

  'main':
    'prefix':'main'
    'body':"""
    int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      $1
    }
    """

  ';':
    'prefix':'l'
    'body':';'

  'll':
    'prefix':'ll'
    'body':'ll $1'

  'double':
    'prefix':'db'
    'body':'long double $1'

  'string':
    'prefix':'string'
    'body':'string $1'

  'str':
    'prefix':'str'
    'body':'string $1'

  'char':
    'prefix':'char'
    'body':'char $1'

  'bool':
    'prefix':'bl'
    'body':'bool $1'

  'mint':
    'prefix':'mint'
    'body':'mint $1'

  'cin':
    'prefix':'cin'
    'body':'cin>>$1'

  'in1':
    'prefix':'in1'
    'body':"""
    ${1:ll} $2;
    cin>>$2;$3
    """

  'in2':
    'prefix':'in2'
    'body':"""
    ${1:ll} $2,$3;
    cin>>$2>>$3;$4
    """

  'in3':
    'prefix':'in3'
    'body':"""
    ${1:ll} $2,$3,$4;
    cin>>$2>>$3>>$4;$5
    """

  'in4':
    'prefix':'in4'
    'body':"""
    ${1:ll} $2,$3,$4,$5;
    cin>>$2>>$3>>$4>>$5;$6
    """

  'in5':
    'prefix':'in5'
    'body':"""
    ${1:ll} $2,$3,$4,$5,$6;
    cin>>$2>>$3>>$4>>$5>>$6;$7
    """

  'll1':
    'prefix':'ll1'
    'body':"""
    ll $1;
    cin>>$1;$2
    """

  'll2':
    'prefix':'ll2'
    'body':"""
    ll $1,$2;
    cin>>$1>>$2;$3
    """

  'll3':
    'prefix':'ll3'
    'body':"""
    ll $1,$2,$3;
    cin>>$1>>$2>>$3;$4
    """

  'll4':
    'prefix':'ll4'
    'body':"""
    ll $1,$2,$3,$4;
    cin>>$1>>$2>>$3>>$4;$5
    """

  'll5':
    'prefix':'ll5'
    'body':"""
    ll $1,$2,$3,$4,$5;
    cin>>$1>>$2>>$3>>$4>>$5;$6
    """

  'STR':
    'prefix':'STR'
    'body':'string ${1:s}; cin>>${1:s};$2'

  'ns':
    'prefix':'ns'
    'body':'ll n; string s; cin>>n>>s;'

  'vin':
    'prefix':'vin'
    'body':'for(auto &i:$1) {cin>>i;}$2'

  'vpin':
    'prefix':'vpin'
    'body':'for(auto &[x,y]:$1) {cin>>x>>y;}$2'

  'vvin':
    'prefix':'vvin'
    'body':'for(auto &i:$1){for(auto &j:i) {cin>>j;}}$2'

  'cout':
    'prefix':'c'
    'body':'cout<<${1:r}<<"\\\\n";$2'

  'cout_':
    'prefix':'cout'
    'body':'cout<<${1:r}<<"\\\\n";$2'

  'cout2':
    'prefix':'c2'
    'body':'cout<<$1<<" "<<$2<<"\\\\n";$3'

  'cout3':
    'prefix':'c3'
    'body':'cout<<$1<<" "<<$2<<" "<<$3<<"\\\\n";$4'

  'cout4':
    'prefix':'c4'
    'body':'cout<<$1<<" "<<$2<<" "<<$3<<" "<<$4<<"\\\\n";$5'

  'cout5':
    'prefix':'c5'
    'body':'cout<<$1<<" "<<$2<<" "<<$3<<" "<<$4<<" "<<$5<<"\\\\n";$6'

  'print':
    'prefix':'print'
    'body':'cout<<$1'

  'vout':
    'prefix':'vout'
    'body':'for(auto &${2:i}:$1) {cout<<${2:i}<<" ";}$3'

  'vpout':
    'prefix':'vpout'
    'body':'for(ll ${2:i}=0;${2:i}<${3:(ll)$1.size()};${2:i}++) {cout<<$1[${2:i}].first<<" "<<$1[${2:i}].second<<"${4:\\\\n}";}$5'

  'vvout':
    'prefix':'vvout'
    'body':'for(ll i=0;i<${2:(ll)$1.size()};i++){for(ll j=0;j<${3:(ll)$1[i].size()};j++) {cout<<$1[i][j]<<" ";}cout<<"\\\\n";}$4'

  'sout':
    'prefix':'sout'
    'body':'cout<<"$1\\\\n";$2'

  'iout':
    'prefix':'iout'
    'body':'cout<<($1==1e18?-1:$1)<<"\\\\n";$2'

  'debug':
    'prefix':'debug1'
    'body':'cerr<<"\\\\033[33m$1 : "<<$1<<"\\\\n\\\\033[m";$2'

  'debug2':
    'prefix':'debug2'
    'body':'cerr<<"\\\\033[33m($1, $2) : ("<<$1<<", "<<$2<<")\\\\n\\\\033[m";$3'

  'debug3':
    'prefix':'debug3'
    'body':'cerr<<"\\\\033[33m($1, $2, $3) : ("<<$1<<", "<<$2<<", "<<$3<<")\\\\n\\\\033[m";$4'

  'debug4':
    'prefix':'debug4'
    'body':'cerr<<"\\\\033[33m($1, $2, $3, $4) : ("<<$1<<", "<<$2<<", "<<$3<<", "<<$4<<")\\\\n\\\\033[m";$5'

  'debug5':
    'prefix':'debug5'
    'body':'cerr<<"\\\\033[33m($1, $2, $3, $4, $5) : ("<<$1<<", "<<$2<<", "<<$3<<", "<<$4<<", "<<$5<<")\\\\n\\\\033[m";$6'

  'debug_pair':
    'prefix':'debugp'
    'body':'cerr<<"\\\\033[33m$1 : ("<<$1.first<<", "<<$1.second<<")\\\\n\\\\033[m";$2'

  'debug_vector':
    'prefix':'debugv'
    'body':'for(ll I=0;I<ssize($1);I++) {cerr<<(I?"":"\\\\033[33m$1 : [")<<$1[I]<<(I==ssize($1)-1?"]\\\\n\\\\033[m":", ");}$2'

  'debug_vector_pair':
    'prefix':'debugvp'
    'body':'for(ll I=0;I<ssize($1);I++) {cerr<<(I?"(":"\\\\033[33m$1 : [(")<<$1[I].first<<", "<<$1[I].second<<(I==ssize($1)-1?")]\\\\n\\\\033[m":"), ");}$2'

  'debug_vector_2':
    'prefix':'debugvv'
    'body':"""
    for(ll I = 0; I < ssize($1); I++) {
      for(ll J = 0; J < ssize($1[I]); J++) {cerr << (J ? "" : "\\\\033[33m[") << $1[I][J] << (J == ssize($1[I]) - 1 ? "]\\\\n\\\\033[m" : ", ");}
    }$2
    """

  'debug_set':
    'prefix':'debugset'
    'body':'for(auto it = $1.begin(); it != $1.end(); it++) {cerr << (it == $1.begin() ? "\\\\033[33m$1 : {" : "") << *it << (it == prev($1.end()) ? "}\\\\n\\\\033[m" : ", ");}$2'

  'debug_map':
    'prefix':'debugmap'
    'body':'for(auto it = $1.begin(); it != $1.end(); it++) { cerr << (it == $1.begin() ? "\\\\033[33m$1 : [(" : "(") << it->first << ", " << it->second << (it == prev($1.end()) ? ")]\\\\n\\\\033[m" : "), "); }$2'

  'endl':
    'prefix':'en'
    'body':'cout<<"\\\\n";'

  'Yes':
    'prefix':'yes'
    'body':'cout<<"Yes\\\\n";'

  'No':
    'prefix':'no'
    'body':'cout<<"No\\\\n";'

  'yesno':
    'prefix':'yesno'
    'body':'cout<<(${1:flag}?"${2:Yes}\\\\n":"${3:No}\\\\n");$4'

  'first':
    'prefix':'fi'
    'body':'first'

  'second':
    'prefix':'sc'
    'body':'second'

  'make_pair':
    'prefix':'mp'
    'body':'make_pair($1)$2'

  'size':
    'prefix':'siz'
    'body':'size()'

  'ssize':
    'prefix':'ssiz'
    'body':'ssize($1)$2'

  'back':
    'prefix':'back'
    'body':'back()'

  'empty':
    'prefix':'empty'
    'body':'empty()'

  'while!empty':
    'prefix':'whileempty'
    'body':'while(!$1.empty()){$2}'

  'and':
    'prefix':'and'
    'body':'&&'

  'or':
    'prefix':'or'
    'body':'||'

  'not':
    'prefix':'not'
    'body':'!='

  'emplace_back':
    'prefix':'push_back'
    'body':'emplace_back($1);$2'

  'pop_back':
    'prefix':'pop_back'
    'body':'pop_back()'

  'emplace':
    'prefix':'emplace'
    'body':'emplace($1);$2'

  'insert':
    'prefix':'insert'
    'body':'insert($1);$2'

  'erase':
    'prefix':'erase'
    'body':'erase($1);$2'

  'break':
    'prefix':'bre'
    'body':'break;'

  'continue':
    'prefix':'continue'
    'body':'continue;'

  'exit':
    'prefix':'exit'
    'body':'return 0;'

  'return':
    'prefix':'return'
    'body':'return '

  'for':
    'prefix':'for'
    'body':'for(ll ${1:i}=0;${1:i}<${2:N};${1:i}++){$3}'

  'for_':
    'prefix':'for1'
    'body':'for(ll ${1:i}=1;${1:i}<=${2:N};${1:i}++){$3}'

  'lp':
    'prefix':'lp'
    'body':'for(ll ${1:i}=0;${1:i}<${2:N};${1:i}++){$3}'

  'lpi':
    'prefix':'lpi'
    'body':'for(int ${1:i}=0;${1:i}<${2:N};${1:i}++){$3}'

  'lp_':
    'prefix':'lp_'
    'body':'for(ll ${1:i}=1;${1:i}<=${2:N};${1:i}++){$3}'

  'lpv':
    'prefix':'lpv'
    'body':'for(ll ${1:i}=0;${1:i}<ssize($2);${1:i}++){$3}'

  'lpa':
    'prefix':'lpa'
    'body':'for(auto &${1:i}:$2){$3}'

  'lpa2':
    'prefix':'lpa2'
    'body':'for(auto &[${1:x},${2:y}]:$3){$4}'

  'forauto':
    'prefix':'fora'
    'body':'for(auto &${1:i}:$2){$3}'

  'pl':
    'prefix':'pl'
    'body':'for(ll ${1:i}=$2;${1:i}>=0;${1:i}--){$3}'

  'mint_ini1000000007':
    'prefix':'mint0'
    'body':'using mint=modint1000000007;'

  'mint_ini998244353':
    'prefix':'mint9'
    'body':'using mint=modint998244353;'

  'mint_ini_arbitrary':
    'prefix':'minta'
    'body':'using mint=modint;'

  'mod_option':
    'prefix':'mod_option'
    'body':"""
    istream &operator>>(istream &is,mint &m) {ll n;is>>n;m=n;return is;}
    ostream &operator<<(ostream &os,const mint &m) {return os<<m.val();}
    mint operator^(const mint &x,const ll &n) {return x.pow(n);}
    mint operator^=(mint &x,const ll &n) {return x=x.pow(n);}
    """

  'setmod':
    'prefix':'setmod'
    'body':'modint::set_mod($1);$2'

  'pair':
    'prefix':'pair'
    'body':'pair<${1:ll},${2:ll}> $3'

  'pi':
    'prefix':'pi'
    'body':'pair<ll,ll> $1'

  'pd':
    'prefix':'pd'
    'body':'pair<long double,long double> $1'

  'pm':
    'prefix':'pm'
    'body':'pair<mint,mint> $1'

  'vector':
    'prefix':'vector'
    'body':'vector<'

  'v':
    'prefix':'v'
    'body':'vector<ll> ${1:v}'

  'vi':
    'prefix':'vi'
    'body':'vector<ll> ${1:v}'

  'vvi':
    'prefix':'vvi'
    'body':'vector<vector<ll>> ${1:v}(${2:H},vector<ll>(${3:W}))$4'

  'vd':
    'prefix':'vd'
    'body':'vector<long double> ${1:v}'

  'vvd':
    'prefix':'vvd'
    'body':'vector<vector<long double>> ${1:v}(${2:h},vector<long double>(${3:w}))$4'

  'vc':
    'prefix':'vc'
    'body':'vector<char> ${1:v}'

  'vvc':
    'prefix':'vvc'
    'body':'vector<vector<char>> ${1:v}(${2:h},vector<char>(${3:w}))$4'

  'vs':
    'prefix':'vs'
    'body':'vector<string> ${1:v}'

  'vvs':
    'prefix':'vvs'
    'body':'vector<vector<string>> ${1:v}($2,vector<string>($3))$4'

  'vm':
    'prefix':'vm'
    'body':'vector<mint> ${1:v}'

  'vvm':
    'prefix':'vvm'
    'body':'vector<vector<mint>> ${1:v}(${2:H},vector<mint>(${3:W}))$4'

  'vp':
    'prefix':'vp'
    'body':'vector<pair<${1:ll},${2:ll}>> ${3:v}'

  'vv':
    'prefix':'vv'
    'body':'vector<vector<${1:ll}>> $2'

  'vvv':
    'prefix':'vvv'
    'body':'vector<vector<vector<${1:ll}>>> $2'

  'vvv_':
    'prefix':'vvv_'
    'body':'vector<vector<vector<${1:ll}>>> ${2:v}($3,vector<vector<${1:ll}>>($4,vector<${1:ll}>($5)));$6'

  'vvvv':
    'prefix':'vvvv'
    'body':'vector<vector<vector<vector<${1:ll}>>>> $2'

  'vvvv_':
    'prefix':'vvvv_'
    'body':'vector<vector<vector<vector<${1:ll}>>>> ${2:v}($3,vector<vector<vector<${1:ll}>>>($4,vector<vector<${1:ll}>>($5,vector<${1:ll}>($6))));$7'

  'V':
    'prefix':'V'
    'body':"""
    vector<${1:ll}> ${2:v}(${3:N});
    for(auto &i:${2:v}) {cin>>i;}$4
    """

  'VI':
    'prefix':'VI'
    'body':"""
    vector<ll> ${1:v}(${2:N});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VD':
    'prefix':'VD'
    'body':"""
    vector<long double> ${1:v}(${2:N});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VC':
    'prefix':'VC'
    'body':"""
    vector<char> ${1:v}(${2:N});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VM':
    'prefix':'VM'
    'body':"""
    vector<mint> ${1:v}(${2:N});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VS':
    'prefix':'VS'
    'body':"""
    vector<string> ${1:v}(${2:H});
    for(auto &i:${1:v}) {cin>>i;}$3
    """

  'VP':
    'prefix':'VP'
    'body':"""
    vector<pair<ll,ll>> ${1:v}(${2:N});
    for(auto &[x,y]:${1:v}) {cin>>x>>y;}$3
    """

  'VV':
    'prefix':'VV'
    'body':"""
    vector<vector<${1:ll}>> ${2:v}(${3:H},vector<${1:ll}>(${4:W}));
    for(auto &i:${2:v}){for(auto &j:i){cin>>j;}}$5
    """

  'VVI':
    'prefix':'VVI'
    'body':"""
    vector<vector<ll>> ${1:v}(${2:H},vector<ll>(${3:W}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'VVD':
    'prefix':'VVD'
    'body':"""
    vector<vector<long double>> ${1:v}(${2:H},vector<long double>(${3:W}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'VVC':
    'prefix':'VVC'
    'body':"""
    vector<vector<char>> ${1:v}(${2:H},vector<char>(${3:W}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'VVS':
    'prefix':'VVS'
    'body':"""
    vector<vector<string>> ${1:v}(${2:H},vector<string>(${3:W}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'VVM':
    'prefix':'VVM'
    'body':"""
    vector<vector<mint>> ${1:v}(${2:H},vector<mint>(${3:W}));
    for(auto &i:${1:v}){for(auto &j:i){cin>>j;}}$4
    """

  'lvi':
    'prefix':'lvi'
    'body':"""
    ll ${1:N}; cin>>${1:N};

    vector<ll> ${2:A}(${1:N});
    for(auto &i:${2:A}) {cin>>i;}
    $3
    """

  'lvp':
    'prefix':'lvp'
    'body':"""
    ll ${1:N}; cin>>${1:N};
    vector<pair<ll,ll>> ${2:v}(${1:N});
    for(auto &[x,y]:${2:v}) {cin>>x>>y;}
    $3
    """

  'set':
    'prefix':'set'
    'body':'set<${1:ll}> ${2:s};$3'

  'multiset':
    'prefix':'mset'
    'body':'multiset<${1:ll}> ${2:s};$3'

  'map':
    'prefix':'map'
    'body':'map<${1:ll},${2:ll}> ${3:m};$4'

  'unordered_map':
    'prefix':'umap'
    'body':'unordered_map<${1:ll},${2:ll}> ${3:m};$4'

  'queue':
    'prefix':'queue'
    'body':'queue<${1:ll}> ${2:q};$3'

  'priority_queue_greater':
    'prefix':'PQ'
    'body':'priority_queue<${1:ll},vector<${1:ll}>,greater<${1:ll}>> ${2:q};$3'

  'priority_queue':
    'prefix':'QP'
    'body':'priority_queue<${1:ll}> ${2:q};$3'

  'stack':
    'prefix':'stack'
    'body':'stack<${1:ll}> ${2:s};$3'

  'all':
    'prefix':'all'
    'body':'$1.begin(),$1.end()$2'

  'begin':
    'prefix':'begin'
    'body':'begin()'

  'end':
    'prefix':'end'
    'body':'end()'

  'sort':
    'prefix':'sort'
    'body':'ranges::sort($1);$2'

  'reverse':
    'prefix':'reverse'
    'body':'ranges::reverse($1);$2'

  'resort':
    'prefix':'resort'
    'body':'ranges::sort($1,ranges::greater());$2'

  'sum':
    'prefix':'sum'
    'body':'accumulate($1.begin(),$1.end(),${2:ll}(0))$3'

  'MAX':
    'prefix':'MAX'
    'body':'ranges::max($1)$2'

  'MIN':
    'prefix':'MIN'
    'body':'ranges::min($1)$2'

  'binary_search':
    'prefix':'BS'
    'body':'ranges::binary_search($1,$2)$3'

  'all_of':
    'prefix':'all_of'
    'body':'ranges::all_of($1,[](auto x){return $2;})$3'

  'any_of':
    'prefix':'any_of'
    'body':'ranges::any_of($1,[](auto x){return $2;})$3'

  'none_of':
    'prefix':'none_of'
    'body':'ranges::none_of($1,[](auto x){return $2;})$3'

  'AP':
    'prefix':'AP'
    'body':'for(ll ${3:i}=0;${3:i}<(ll)$1.size()) {$1[${3:i}]+=$2;}$4'

  'lower_bound':
    'prefix':'lb'
    'body':'ranges::lower_bound($1,$2)$3'

  'upper_bound':
    'prefix':'ub'
    'body':'ranges::upper_bound($1,$2)$3'

  'unique':
    'prefix':'unique'
    'body':'ranges::sort($1); $1.erase(unique($1.begin(),$1.end()),$1.end());$2'

  'Compress':
    'prefix':'Compress'
    'body':"""
    template<typename T> vector<T> Compress(vector<T> &v) {
      vector<T> r = v;
      ranges::sort(r);
      r.erase(unique(r.begin(), r.end()), r.end());
      for(auto &i : v) {i = ranges::lower_bound(r, i) - r.begin();}
      return r;
    }
    """

  'compress':
    'prefix':'compress'
    'body':'Compress($1)'

  'RLE_vec':
    'prefix':'RLE_vec'
    'body':"""
    template<typename T> vector<pair<T, ll>> RLE(const vector<T> &v) {
      int p = -1, n = v.size();
      vector<pair<T, ll>> r;
      for(int i = 0; i < n - 1; i++) {
        if(v[i] != v[i + 1]) {
          r.emplace_back(v[i], i - p);
          p = i;
        }
      }
      r.emplace_back(v.back(), n - 1 - p);
      return r;
    }
    """

  'RLE_str':
    'prefix':'RLE_str'
    'body':"""
    vector<pair<char, ll>> RLE(const string &s) {
      int p = -1, n = s.size();
      vector<pair<char, ll>> r;
      for(int i = 0; i < n - 1; i++) {
        if(s[i] != s[i + 1]) {
          r.emplace_back(s[i], i - p);
          p = i;
        }
      }
      r.emplace_back(s.back(), n - 1 - p);
      return r;
    }
    """

  'ACSUM':
    'prefix':'ACSUM'
    'body':"""
    vector<ll> s${1:v}(${2:${1:v}.size()}+1,0);
    for(ll i=0;i<${2:${1:v}.size()};i++) {s${1:v}[i+1]=s${1:v}[i]+${1:v}[i];}$3
    """

  'next_permutation':
    'prefix':'next_permutation'
    'body':"""
    do{
      $2
    }while(next_permutation($1.begin(),$1.end()));
    """

  'next_combination':
    'prefix':'next_combination'
    'body':"""
    vector<bool> o(n, false);
    fill(o.end() - n + k, o.end(), true);
    do {
      vector<ll> r;
      for(int i = 0; i < n; i++) {
        if(!o[i]) { r.push_back(i); }
      }
    } while(next_permutation(o.begin(), o.end()));
    """

  'ExtGCD':
    'prefix':'ExtGCD'
    'body':"""
    // return : gcd(a,b), {x,y} -> soltion of ax + by = gcd(a,b)
    template<typename T> T extGCD(T a, T b, T &x, T &y) {
      T g = a;
      if(b != 0) {
        g = extGCD(b, a % b, y, x);
        y -= (a / b) * x;
      }
      else {x = 1, y = 0;}
      return g;
    }
    """

  'extGCD':
    'prefix':'extGCD'
    'body':'extGCD($1,$2,$3,$4);$5'

  'Combinatorics':
    'prefix':'Combinatorics'
    'body':"""
    struct Combinatorics {
     private:
      void extend(int m) {
        int n = fac.size();
        m = min(m, mint::mod() - 1);
        if(n > m) { return; }
        fac.resize(m + 1);
        finv.resize(m + 1);
        inv.resize(m + 1);
        for(int i = n; i <= m; i++) { fac[i] = fac[i - 1] * i; }
        finv[m] = fac[m].inv();
        for(int i = m - 1; i >= n; i--) { finv[i] = finv[i + 1] * (i + 1); }
        for(int i = n; i <= m; i++) { inv[i] = finv[i] * fac[i - 1]; }
      }

     public:
      vector<mint> fac, finv, inv;
      Combinatorics(int n = 0): fac(1, 1), finv(1, 1), inv(1, 1) { extend(n); }
      mint operator()(int n) {
        extend(abs(n));
        return n >= 0 ? fac[n] : finv[-n];
      }
      mint operator[](int n) {
        extend(abs(n));
        return n >= 0 ? inv[n] : -inv[-n];
      }
      mint C(int n, int k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        extend(n);
        return fac[n] * finv[n - k] * finv[k];
      }
      inline mint operator()(int n, int k) { return C(n, k); }
      mint C_(ll n, ll k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        k = min(k, n - k);
        extend(k);
        mint r = 1;
        for(ll i = 0; i < k; i++) { r *= n - i; }
        return r * finv[k];
      }
      mint P(int n, int k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        extend(n);
        return fac[n] * finv[n - k];
      }
      mint P_(ll n, ll k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        k = min(k, n - k);
        mint r = 1;
        for(ll i = 0; i < k; i++) { r *= n - i; }
        return r;
      }
      mint H(int n, int k) {
        if(n < 0 || k < 0) { return 0; }
        if(n == 0 && k == 0) { return 1; }
        return C(n + k - 1, k);
      }
      mint multi(const vector<ll> &v) {
        int n = 0;
        for(auto &i : v) {
          if(i < 0) { return 0; }
          n += i;
        }
        extend(n);
        mint r = fac[n];
        for(auto &i : v) { r *= finv[i]; }
        return r;
      }
      mint operator()(const vector<ll> &v) { return multi(v); }
      mint Catalan(int n) {
        if(n < 0) { return 0; }
        extend(n * 2);
        return fac[n * 2] * finv[n] * finv[n + 1];
      }
      mint Bell(int n, int k) {
        if(n < 0 || k < 0) { return 0; }
        if(n == 0) { return 1; }
        k = min(n, k);
        extend(k);
        mint r = 0;
        vector<mint> v(k + 1);
        v[0] = 1;
        for(ll i = 1; i <= k; i++) { v[i] = v[i - 1] + (i & 1 ? -finv[i] : finv[i]); }
        for(ll i = 1; i <= k; i++) { r += (mint(i).pow(n)) * finv[i] * v[k - i]; }
        return r;
      }
      mint Stirling(ll n, ll k) {
        if(n < 0 || k < 0 || n < k) { return 0; }
        mint r = 0;
        for(ll i = 0; i <= k; i++) {
          mint t = C(k, i) * (mint(i).pow(n));
          r += (k - i) & 1 ? -t : t;
        }
        return r * finv[k];
      }
    } C;  ${1:// 任意modの場合，main関数内に書くこと}
    """

  'combinatrics':
    'prefix':'combinatrics'
    'body':'Combinatorics C($1);'

  'COMTable':
    'prefix':'COMTable'
    'body':"""
    template<typename T> vector<vector<T>> COMTable(int n) {  // If n is small
      vector<vector<T>> r(n + 1, vector<T>(n + 1, 0));
      for(int i = 0; i <= n; i++) {
        for(int j = 0; j <= i; j++) {
          if(j == 0 || j == i) { r[i][j] = 1; }
          else { r[i][j] = r[i - 1][j - 1] + r[i - 1][j]; }
        }
      }
      return r;
    }
    """

  'comtable':
    'prefix':'comtable'
    'body':'auto C=COMTable($1);$2'

  'Stirling_number_2_Table':
    'prefix':'Stirling_number_2_Table'
    'body':"""
    template<typename T> vector<vector<T>> StirlingTable(int n) {
      vector<vector<T>> r(n + 1, vector<T>(n + 1, 0));
      r[0][0] = 1;
      for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= i; j++) {
          r[i][j] = r[i - 1][j - 1] + r[i - 1][j] * j;
        }
      }
      return r;
    }
    """

  'Partition_number':
    'prefix':'Partition_number'
    'body':"""
    template<typename T> vector<vector<T>> Partition(int n) {
      vector<vector<T>> r(n + 1, vector<T>(n + 1, 0));
      for(int i = 0; i <= n; i++) { r[0][i] = 1; }
      for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
          r[i][j] = r[i][j - 1] + (i - j >= 0 ? r[i - j][j] : 0);
        }
      }
      return r;
    }
    """

  'Base':
    'prefix':'Base'
    'body':"""
    vector<ll> Base(ll x, ll n, bool re = false) {
      vector<ll> r;
      while(x) {
        r.emplace_back(x % n);
        x /= n;
      }
      if(re) {ranges::reverse(r);}
      return r;
    }
    """

  'base':
    'prefix':'base'
    'body':'=Base($1,$2)'

  'Prime':
    'prefix':'Prime'
    'body':"""
    vector<pair<ll, ll>> Prime(ll n) {
      vector<pair<ll, ll>> r;
      for(ll i = 2; i*i <= n; i++) {
        if(n % i != 0) {continue;}
        ll e = 0;
        while(n % i == 0) {e++, n /= i;}
        r.emplace_back(i, e);
      }
      if(n != 1) {r.emplace_back(n, 1);}
      return r;
    }
    """

  'prime':
    'prefix':'prime'
    'body':'Prime($1)'

  'PriMap':
    'prefix':'PriMap'
    'body':"""
    map<ll, ll> PriMap(ll n) {
      map<ll, ll> r;
      for(ll i = 2; i*i <= n; i++) {
        while(n % i == 0) {r[i]++, n /= i;}
      }
      if(n != 1){r[n] = 1;}
      return r;
    }
    """

  'primap':
    'prefix':'primap'
    'body':'PriMap($1)'

  'Divisor':
    'prefix':'Div'
    'body':"""
    vector<ll> Divisor(ll n) {
      vector<ll> r;
      for(ll i = 1; i *i<= n; i++) {
        if(n % i == 0) {
          r.emplace_back(i);
          if(i * i != n) {r.emplace_back(n / i);}
        }
      }
      ranges::sort(r);
      return r;
    }
    """

  'divisor':
    'prefix':'div'
    'body':'Divisor($1)'

  'Divcnt':
    'prefix':'Divcnt'
    'body':"""
    ll Divcnt(ll n, ll d) {
      ll r = 0;
      while(n % d == 0) {n /= d, r++;}
      return r;
    }
    """

  'divcnt':
    'prefix':'divcnt'
    'body':'Divcnt($1,$2)'

  'DigSum':
    'prefix':'DigSum'
    'body':"""
    ll DigSum(ll n){
      ll r=0;
      while(n){
        r+=n%10;
        n/=10;
      }
      return r;
    }
    """

  'digsum':
    'prefix':'digsum'
    'body':'Digsum($1)'

  'Enum_floor':
    'prefix':'Enum_floor'
    'body':"""
    vector<tuple<ll, ll, ll>> Enum_floor(ll n) {
      vector<tuple<ll, ll, ll>> ret;
      ll l = 1;
      while(l <= n) {
        ll q = n / l, r = n / q + 1;
        ret.push_back({l, r, q});
        l = r;
      }
      return ret;
    }
    """

  'enum_floor':
    'prefix':'enum_floor'
    'body':'Enum_floor($1)'

  'Enum_ceil':
    'prefix':'Enum_ceil'
    'body':"""
    vector<tuple<ll, ll, ll>> Enum_ceil(ll n) {
      vector<tuple<ll, ll, ll>> ret;
      ll l = 1;
      while(l <= n) {
        ll q = (n + l - 1) / l, r = n + 1;
        if(q != 1) { r = (n - 1) / (q - 1) + 1; }
        ret.push_back({l, r, q});
        l = r;
      }
      return ret;
    }
    """

  'enum_ceil':
    'prefix':'enum_ceil'
    'body':'Enum_ceil($1)'

  'PSUM':
    'prefix':'_PSUM'
    'body':"""
    mint PSUM(const vector<ll> &v, ll s) {
      ll n = v.size();
      vector<vector<mint>> dp(n + 3, vector<mint>(s + 3, 0));
      dp[0][0] = 1;
      for(ll i = 0; i < n; i++) {
        for(ll j = 1; j <= s; j++) {
          dp[i + 1][j] += dp[i][j];
          if(j >= v[i]) dp[i + 1][j] += dp[i][j - v[i]];
        }
      }
      return dp[n][s];
    }
    """

  'INF':
    'prefix':'inf'
    'body':'1e18'

  'FNI':
    'prefix':'fni'
    'body':'-1e18'

  'LIS':
    'prefix':'LIS'
    'body':"""
    template<typename T> vector<T> LIS(const vector<T> &v, bool strict = 1) {
      vector<T> lis;
      for(auto &i : v) {
        auto it = (strict ? ranges::lower_bound(lis, i) : ranges::upper_bound(lis, i));
        it == lis.end() ? lis.emplace_back(i) : *it = i;
      }
      return lis;
    }
    """

  'DXDY4':
    'prefix':'DXDY4'
    'body':'constexpr int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};'

  'DXDY8':
    'prefix':'DXDY8'
    'body':'constexpr int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1}, dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};'

  'chmin_func':
    'prefix':'chmin_func'
    'body':'auto chmin = [&](auto &a, const auto &b) { return a > b ? (a = b, true) : false; };'

  'chmax_func':
    'prefix':'chmax_func'
    'body':'auto chmax = [&](auto &a, const auto &b) { return a < b ? (a = b, true) : false; };'

  'YN':
    'prefix':'YN'
    'body':'cout << (${1:f} ? "${2:Yes}" : "${3:No}") << "\\\\n";$4'

  'bitset':
    'prefix':'bit'
    'body':'bitset<70> $1($2);$3'

  'floor_sum':
    'prefix':'floor_sum'
    'body':'floor_sum(,,,); // (n,m,a,b) -> Σ i=0~n-1 floor((a*i+b)/m)'

  'lambda':
    'prefix':'lambda'
    'body':"""
    auto ${1:f}=[&]($2){
      $3
    };
    """

  'lambda_':
    'prefix':'Lambda'
    'body':"""
    auto ${1:f}=[&](auto &&${1:f},$2)->$3{
      $4
    };
    """

  'binmax':
    'prefix':'binmax'
    'body':"""
    for(ll L = $1,R = $2;;) {
      if(R - L <= 1) {
        cout << L << "\\\\n";
        break;
      }
      ll M = (L + R)/2;
      bool flag = [&]() -> bool {
        $3
      }();
      flag ? L = M : R = M;
    }
    """

  'binmax_func':
    'prefix':'binmax_func'
    'body':"""
    function<void(ll, ll)> f = [&](ll L, ll R) {
      if(R - L <= 1) cout << L << "\\\\n";
      else {
        ll M = (L + R)/2;
        bool flag = 0;
        $1
        flag ? f(M, R) : f(L, M);
      }
    };
    """

  'binmin':
    'prefix':'binmin'
    'body':"""
    for(ll L = $1, R = $2;;) {
      if(R - L <= 1) {
        cout << R << "\\\\n";
        break;
      }
      ll M = (L + R)/2;
      bool flag = [&]() -> bool {
        $3
      }();
      flag ? R = M : L = M;
    }
    """

  'binmin_func':
    'prefix':'binmin_func'
    'body':"""
    function<void(ll, ll)> f = [&](ll L, ll R) {
      if(R - L <= 1) cout << R << "\\\\n";
      else {
        ll M = (L + R) /2;
        bool flag = 0;
        $1
        flag ? f(L, M) : f(M, R);
      }
    };
    """

  'graph':
    'prefix':'graph'
    'body':"""
    vector<vector<ll>> g(${1:N});
    for(ll i=0,u,v;i<${2:M};i++){
      cin>>u>>v;
      u--,v--;
      g[u].emplace_back(v);
      g[v].emplace_back(u);
    }$3
    """

  'lgraph':
    'prefix':'lgraph'
    'body':"""
    ll ${1:N},${2:M};
    cin>>${1:N}>>${2:M};
    vector<vector<ll>> g(${1:N});
    for(ll i=0,u,v;i<${2:M};i++){
      cin>>u>>v;
      u--,v--;
      g[u].emplace_back(v);
      g[v].emplace_back(u);
    }$3
    """

  'tree':
    'prefix':'tree'
    'body':"""
    vector<vector<ll>> g(${1:N});
    for(ll i=0,u,v;i<${1:N}-1;i++){
      cin>>u>>v;
      u--,v--;
      g[u].emplace_back(v);
      g[v].emplace_back(u);
    }$2
    """

  'ltree':
    'prefix':'ltree'
    'body':"""
    ll ${1:N};
    cin>>${1:N};
    vector<vector<ll>> g(${1:N});
    for(ll i=0,u,v;i<${1:N}-1;i++){
      cin>>u>>v;
      u--,v--;
      g[u].emplace_back(v);
      g[v].emplace_back(u);
    }$2
    """

  'treeparent':
    'prefix':'treeparent'
    'body':"""
    vector<vector<ll>> g(${1:N});
    for(ll i = 1, p; i < ${1:N}; i++) {
      cin >> p;
      p--;
      g[p].emplace_back(i);
      g[i].emplace_back(p);
    }$2
    """

  'ltreeparent':
    'prefix':'ltreeparent'
    'body':"""
    ll ${1:N};
    cin>>${1:N};
    vector<vector<ll>> g(${1:N});
    for(ll i = 1, p; i < ${1:N}; i++) {
      cin >> p;
      p--;
      g[p].emplace_back(i);
      g[i].emplace_back(p);
    }$2
    """

  'wgraph':
    'prefix':'wgraph'
    'body':"""
    vector<vector<pair<ll,ll>>> g(${1:N});
    for(ll i=0,u,v,w;i<${2:m};i++){
      cin>>u>>v>>w;
      u--,v--;
      g[u].emplace_back(v,w);
      g[v].emplace_back(u,w);
    }$3
    """

  'lwgraph':
    'prefix':'lwgraph'
    'body':"""
    ll ${1:N},${2:m};
    cin>>${1:N}>>${2:m};
    vector<vector<pair<ll,ll>>> g(${1:N});
    for(ll i=0,u,v,w;i<${2:m};i++){
      cin>>u>>v>>w;
      u--,v--;
      g[u].emplace_back(v,w);
      g[v].emplace_back(u,w);
    }$3
    """

  'wtree':
    'prefix':'wtree'
    'body':"""
    vector<vector<pair<ll,ll>>> g(${1:N});
    for(ll i=0,u,v,w;i<${1:N}-1;i++){
      cin>>u>>v>>w;
      u--,v--;
      g[u].emplace_back(v,w);
      g[v].emplace_back(u,w);
    }$2
    """

  'lwtree':
    'prefix':'lwtree'
    'body':"""
    ll ${1:N};
    cin>>${1:N};
    vector<vector<pair<ll,ll>>> g(${1:N});
    for(ll i=0,u,v,w;i<${1:N}-1;i++){
      cin>>u>>v>>w;
      u--,v--;
      g[u].emplace_back(v,w);
      g[v].emplace_back(u,w);
    }$2
    """

  'DFS':
    'prefix':'DFS'
    'body':"""
    auto DFS = [&](auto &&DFS, ll v, ll p) -> void {
      for(auto &nv : g[v]) {
        if(nv != p) {DFS(DFS, nv, v);}
      }
    };
    """

  'DFS_tree':
    'prefix':'DFS_tree'
    'body':"""
    vector<ll> depth(n, -1);
    auto DFS = [&](auto &&DFS, ll v, ll p, ll d) -> void {
      depth[v] = d;
      for(auto &nv : g[v]) {
        if(nv == p) {continue;}
        DFS(DFS, nv, v, d + 1);
      }
    };
    """

  'DFS_tree_size':
    'prefix':'DFS_tree_size'
    'body':"""
    vector<ll> depth(n,-1),par(n,-1), order, tsiz(n);
    function<void(ll, ll, ll)> DFS = [&](ll v, ll p, ll d) {
      depth[v] = d;
      par[v]=p;
      order.emplace_back(v);
      for(auto &nv : g[v]) {
        if(nv != p) {DFS(nv, v, d + 1);}
      }
      tsiz[v] = 1;
      for(auto &nv : g[v]) {
        if(nv != p) {tsiz[v] += tsiz[nv];}
      }
    };
    """

  'BFS_func':
    'prefix':'BFS_func'
    'body':"""
    auto BFS = [&](ll s) {
      vector<ll> d(n, -1);
      d[s] = 0;
      queue<ll> q;
      q.emplace(s);
      while(!q.empty()) {
        ll v = q.front();
        q.pop();
        for(auto &nv : g[v]) {
          if(d[nv] == -1) {
            d[nv] = d[v] + 1;
            q.emplace(nv);
          }
        }
      }
      return d;
    };
    """

  'BFS':
    'prefix':'BFS'
    'body':"""
    vector<ll> d(n, -1);
    d[0] = 0;
    queue<ll> q;
    q.emplace(0);
    while(!q.empty()) {
      ll v = q.front();
      q.pop();
      for(auto &nv : g[v]) {
        if(d[nv] == -1) {
          d[nv] = d[v] + 1;
          q.emplace(nv);
        }
      }
    }
    """

  'BFS_re_func':
    'prefix':'BFS_re_func'
    'body':"""
    auto BFS = [&](ll s, ll t) -> pair<vector<ll>, vector<ll>> {
      vector<ll> d(n, -1), pre(n), path;
      d[s] = 0;
      queue<ll> q;
      q.emplace(s);
      while(!q.empty()) {
        ll v = q.front();
        q.pop();
        for(auto &nv : g[v]) {
          if(d[nv] == -1) {
            d[nv] = d[v] + 1;
            q.emplace(nv);
            pre[nv] = v;
          }
        }
      }
      if(d[t] != -1) {
        for(ll p = t; p != s; p = pre[p]) { path.emplace_back(p); }
        path.emplace_back(s);
        ranges::reverse(path);
      }
      return {d, path};
    };
    """

  'BFS_re':
    'prefix':'BFS_re'
    'body':"""
    vector<ll> d(n, -1), pre(n), path;
    d[s] = 0;
    queue<ll> q;
    q.emplace(s);
    while(!q.empty()) {
      ll v = q.front();
      q.pop();
      for(auto &nv : g[v]) {
        if(d[nv] == -1) {
          d[nv] = d[v] + 1;
          q.emplace(nv);
          pre[nv] = v;
        }
      }
    }
    if(d[t] != -1) {
      for(ll p = t; p != s; p = pre[p]) {path.emplace_back(p);}
      path.emplace_back(s);
      ranges::reverse(path);
    }
    """

  'BFS_grid':
    'prefix':'BFS_grid'
    'body':"""
    constexpr ll DX[8]={0,0,1,-1,1,1,-1,-1},DY[8]={1,-1,0,0,1,-1,1,-1};

    template<typename T> void BFS(vector<vector<T>> &g, vector<vector<ll>> &d, pair<ll, ll> s, T w, bool ini = 1) {
      ll limx = g.size(), limy = g[0].size();
      if(ini) d.assign(limx, vector<ll>(limy, 1e18));
      d[s.first][s.second] = 0;
      queue<pair<ll, ll>> q;
      q.push(s);
      while(!q.empty()) {
        auto [x,y]=q.front();
        q.pop();
        for(ll i = 0; i < 4; i++) {
          ll nx = x + DX[i], ny = y + DY[i];
          if(nx < 0 || ny < 0 || nx >= limx || ny >= limy) {continue;}
          if(g[nx][ny] == w) {continue;}
          if(chmin(d[nx][ny], d[x][y] + 1)) {q.push({nx, ny});}
        }
      }
    }
    """

  '01BFS_grid':
    'prefix':'01BFS_grid'
    'body':"""
    constexpr ll DX[8]={0,0,1,-1,1,1,-1,-1},DY[8]={1,-1,0,0,1,-1,1,-1};

    template<typename T> void BFS(vector<vector<T>> &g, vector<vector<ll>> &d, pair<ll, ll> s, T w, bool ini = 1) {
      ll limx = g.size(), limy = g[0].size();
      if(ini) {d.assign(limx, vector<ll>(limy, 1e18));}
      d[s.first][s.second] = 0;
      deque<pair<ll, ll>> q;
      q.push_back(s);
      while(!q.empty()) {
        auto [x,y]=q.front();
        q.pop_front();
        for(ll i = 0; i < 4; i++) {
          ll nx = x + DX[i], ny = y + DY[i];
          if(nx < 0 || ny < 0 || nx >= limx || ny >= limy) {continue;}
          if(g[nx][ny] == w) {
            if(chmin(d[nx][ny], d[x][y] + 1)) {q.push_back({nx, ny});}
          }
          else if(chmin(d[nx][ny], d[x][y])) {q.push_front({nx, ny});}
        }
      }
    }
    """

  'Dijkstra':
    'prefix':'Dijkstra'
    'body':"""
    vector<ll> d(N, 1e18);
    d[${1:0}] = 0;
    auto chmin = [&](auto &a, const auto &b) { return a > b ? (a = b, true) : false; };
    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;
    q.emplace(0, ${1:0});
    while(!q.empty()) {
      auto [tmp, v] = q.top();
      q.pop();
      if(tmp > d[v]) {continue;}
      for(auto &[nv, c] : g[v]) {
        if(chmin(d[nv], d[v] + c)) {q.emplace(d[nv], nv);}
      }
    }$2
    """

  'Dijkstra_func':
    'prefix':'Dijkstra_func'
    'body':"""
    auto Dijkstra = [&](ll s) {
      auto chmin = [&](auto &a, const auto &b) { return a > b ? (a = b, true) : false; };
      vector<ll> d(N, 1e18);
      d[s] = 0;
      priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;
      q.emplace(0, s);
      while(!q.empty()) {
        auto [tmp, v] = q.top();
        q.pop();
        if(tmp > d[v]) { continue; }
        for(auto &[nv, c] : g[v]) {
          if(chmin(d[nv], d[v] + c)) { q.emplace(d[nv], nv); }
        }
      }
      return d;
    };
    """

  'Dijkstra_re':
    'prefix':'Dijkstra_re'
    'body':"""
    template<typename T> vector<ll> Dijkstra_re(vector<vector<pair<ll,T>>> &g, vector<T> &d, ll s, ll t, bool ini = 1) {  // O(E log V)
      vector<ll> pre(g.size()), re;
      if(ini) {d.assign(g.size(), 1e18);}
      d[s] = 0;
      priority_queue<pair<T, ll>, vector<pair<T, ll>>, greater<pair<T, ll>>> q;
      q.push({T(0), s});
      while(!q.empty()) {
        pair<T, ll> p = q.top();
        q.pop();
        ll v = p.second;
        if(p.first > d[v]) {continue;}
        for(auto &[nv,c] : g[v]) {
          if(chmin(d[nv], d[v] + c)) {
            q.push({d[nv], nv});
            pre[nv] = v;
          }
        }
      }
      if(d[t] != 1e18) {
        for(ll p = t; p != s; p = pre[p]) {re.emplace_back(p);}
        re.emplace_back(s);
        ranges::reverse(re);
      }
      return re;
    }
    """

  'BellmanFord':
    'prefix':'BellmanFord'
    'body':"""
    template<typename T> bool BellmanFord(vector<vector<pair<ll,T>>> &g, vector<T> &d, ll s = 0, bool ini = 1) {  // O(VE)
      bool nega_cycle = false;
      ll n = g.size();
      if(ini) {d.assign(n, 1e18);}
      d[s] = 0;
      for(ll i = 0; i < n; i++) {
        bool update = 0;
        for(ll v = 0; v < n; v++) {
          if(d[v] == 1e18) {continue;}
          for(auto &[nv,c] : g[v]) {
            if(chmin(d[nv], d[v] + c)) {update = 1;}
          }
        }
        if(!update) {break;}
        if(i == n - 1) {nega_cycle = true;}
      }
      return nega_cycle;
    }
    """

  'bellmanford':
    'prefix':'bellmanford'
    'body':'BellmanFord(g,d);'

  'WarshallFroyd':
    'prefix':'WarshallFroyd'
    'body':"""
    template<typename T> vector<vector<T>> WarshallFroyd(vector<vector<pair<ll,T>>> &g) {  // O(V^3)
      ll n = g.size();
      vector<vector<T>> w(n, vector<T>(n, 1e18));
      for(ll i = 0; i < n; i++) {w[i][i] = 0;}
      for(ll i = 0; i < n; i++) {
        for(auto &[j,c] : g[i]) {w[i][j] = c;}
      }
      for(ll via = 0; via < n; via++) {
        for(ll i = 0; i < n; i++) {
          for(ll j = 0; j < n; j++) {w[i][j]=min(w[i][j], w[i][via] + w[via][j]);}
        }
      }
      return w;
    }
    """

  'warshallfroyd':
    'prefix':'warshallfroyd'
    'body':'WarshallFroyd(g)'

  'WarshallFroyd_re':
    'prefix':'WarshallFroyd_re'
    'body':"""
    template<typename T> vector<vector<T>> WarshallFroyd(vector<vector<pair<ll,T>>> &g, vector<vector<ll>> &pre) {
      ll n = g.size();
      vector<vector<T>> w(n, vector<T>(n, 1e18));
      for(ll i = 0; i < n; i++) {
        vector<ll> p(n, i);
        pre.emplace_back(p);
      }
      for(ll i = 0; i < n; i++) {w[i][i] = 0;}
      for(ll i = 0; i < n; i++) {
        for(auto &[j,c] : g[i]) {w[i][j] = c;}
      }
      for(ll via = 0; via < n; via++) {
        for(ll i = 0; i < n; i++) {
          for(ll j = 0; j < n; j++) {
            if(chmin(w[i][j], w[i][via] + w[via][j])) {pre[i][j] = pre[via][j];}
          }
        }
      }
      return w;
    }
    vector<ll> WarshallFroyd_re(vector<vector<ll>> &pre, ll s, ll t) {
      vector<ll> r;
      for(ll p = t; p != s; p = pre[s][p]) {r.emplace_back(p);}
      r.emplace_back(s);
      ranges::reverse(r);
      return r;
    }
    """

  'warshallfroyd_re':
    'prefix':'warshallfroyd_re'
    'body':'WarshallFroyd_re(pre,$1,$2)'

  'Topological_sort':
    'prefix':'Topological_sort'
    'body':"""
    vector<ll> sort(vector<vector<ll>> &g) {
      ll n = g.size();
      vector<ll> r, e(n);
      priority_queue<ll, vector<ll>, greater<ll>> q;
      for(ll i = 0; i < n; i++) {
        for(auto &v : g[i]) {e[v]++;}
      }
      for(ll i = 0; i < n; i++) {
        if(e[i] == 0) {q.emplace(i);}
      }
      while(!q.empty()) {
        ll v = q.top();
        q.pop();
        r.emplace_back(v);
        for(auto &nv : g[v]) {
          e[nv]--;
          if(e[nv] == 0) {q.emplace(nv);}
        }
      }
      return r;
    }
    """

  'Topological_sort_w':
    'prefix':'Topological_sort_w'
    'body':"""
    template<typename T> vector<ll> sort(vector<vector<pair<ll,T>>> &g) {
      ll n = g.size();
      vector<ll> r, e(n);
      priority_queue<ll, vector<ll>, greater<ll>> q;
      for(ll i = 0; i < n; i++) {
        for(auto &v : g[i]) {e[v.second]++;}
      }
      for(ll i = 0; i < n; i++) {
        if(e[i] == 0) {q.emplace(i);}
      }
      while(!q.empty()) {
        ll v = q.top();
        q.pop();
        r.emplace_back(v);
        for(auto &[nv,c] : g[v]) {
          e[nv]--;
          if(e[nv] == 0) {q.emplace(nv);}
        }
      }
      return r;
    }
    """

  'TreeDiameter':
    'prefix':'_TreeDiameter'
    'body':"""
    ll TreeDiameter(vector<vector<ll>> &g) {
      vector<ll> D(g.size(), -1);
      function<void(ll, ll)> DFS = [&](ll v, ll d) {
        D[v] = d;
        for(auto &nv : g[v]) {
          if(D[nv] < 0) {DFS(nv, d + 1);}
        }
      };
      DFS(0, 0);
      ll v = ranges::max_element(D) - D.begin();
      D.assign(g.size(), -1);
      DFS(v, 0);
      return ranges::max(D);
    }
    """

  'TreeDiameter_w':
    'prefix':'_TreeDiameter_w'
    'body':"""
    pair<pair<ll, ll>, ll> TreeDiameter(vector<vector<pair<ll, ll>>> &g) {
      vector<ll> D(g.size(), -1);
      function<void(ll, ll)> DFS = [&](ll v, ll d) {
        D[v] = d;
        for(auto &[nv, c] : g[v]) {
          if(D[nv] < 0) {DFS(nv, d + c);}
        }
      };
      DFS(0, 0);
      ll v = ranges::max_element(D) - D.begin();
      D.assign(g.size(), -1);
      DFS(v, 0);
      ll u = ranges::max_element(D) - D.begin();
      ll w = ranges::max(D);
      return {{u, v}, w};
    }
    """

  'Bipartite':
    'prefix':'Bipartite'
    'body':"""
    vector<ll> Bipartite(vector<vector<ll>>& g) {
      ll n = g.size();
      vector<ll> color(n, -1);
      function<bool(ll, ll)> DFS = [&](ll v, ll c) {
        color[v] = c;
        for(auto &nv : g[v]) {
          if(color[nv] != -1) {
            if(color[nv] == c) {return false;}
            continue;
          }
          if(!DFS(nv, 1 - c)) {return false;}
        }
        return true;
      };
      for(ll i = 0; i < n; i++) {
        if(color[i] == -1) {
          if(!DFS(i, 0)) {return {};}
        }
      }
      return color;
    }
    """

  'bipartite':
    'prefix':'bipartite'
    'body':'Bipartite(g);'

  'LagrangePolynomial':
    'prefix':'Lagrange'
    'body':"""
    template<typename T> mint LagrangePolynomial(vector<T> &v, ll x) {
      ll N = v.size() - 1;
      mint r = 0;
      if(x <= N) { return v[x]; }
      vector<mint> dp(N + 1, 1), pd(N + 1, 1);
      for(ll i = 0; i < N; i++) { dp[i + 1] = dp[i] * (x - i); }
      for(ll i = N; i >= 1; i--) { pd[i - 1] = pd[i] * (x - i); }
      for(ll i = 0; i <= N; i++) {
        mint t = dp[i] * pd[i] * C(-i) * C(i - N) * v[i];
        r += (N - i) & 1 ? -t : t;
      }
      return r;
    }
    // depends on : Combinatorics
    """

  'lagrangepolynomial':
    'prefix':'lagrange'
    'body':'LagrangePolynomial($1,$2)'

  'Fibo':
    'prefix':'Fibo'
    'body':"""
    template<typename T = mint> T Fibo(ll n) {
      vector<vector<T>> v = {{1, 1}, {1, 0}};
      Matrix<T> M(v);
      M ^= (n - 1);
      return M[0][0];
    }
    // depends on : Matrix
    """

  'fibo':
    'prefix':'fibo'
    'body':'Fibo($1);'

  'mypq':
    'prefix':'mypq'
    'body':"""
    auto compare=[](auto x,auto y){return $2;}; // condition to put y near top
    priority_queue<$1,vector<$1>,decltype(compare)> q(compare);
    """

  'RNG':
    'prefix':'RNG'
    'body':"""
    struct RNG{
      mt19937 mt;
      RNG():mt(chrono::steady_clock::now().time_since_epoch().count()){}
      int operator()(int a,int b){uniform_int_distribution<int>dist(a,b);return dist(mt);}
      int operator()(int b){return(*this)(0,b);}
    }rng;
    """

  'RPG':
    'prefix':'RPG'
    'body':"""
    #include <atcoder/internal_math>
    int RPG(int l, int r = 2e9) {
      int p = rng(l, r);
      if(atcoder::internal::is_prime_constexpr(p)) { return p; }
      return RPG(l, r);
    }
    """

  'Inversion':
    'prefix':'Inversion'
    'body':"""
    ll Inversion(vector<ll> &v) {
      ll r = 0, n = v.size();
      // Compress(v);
      fenwick_tree<ll> b(n + 1);
      for(ll i = 0; i < n; i++) {
        r += b.sum(v[i]+1, n + 1);
        b.add(v[i], 1);
      }
      return r;
    }
    """

  'inversion':
    'prefix':'inversion'
    'body':'Inversion($1)'

  'Unionfind':
    'prefix':'Unionfind'
    'body':"""
    struct Unionfind {
      vector<ll> par;
      ll e = 0, v;
      Unionfind(ll n): par(n, -1), v(n) {}
      Unionfind(vector<vector<ll>> g): par(g.size(), -1), v(g.size()) {
        for(ll i = 0; i < v; i++) {
          for(auto &j : g[i]) {
            if(i < j) {unite(i, j);}
          }
        }
      }
      ll root(ll x) {
        if(par[x] < 0) {return x;}
        return par[x] = root(par[x]);
      }
      void unite(ll x, ll y) {
        x = root(x), y = root(y);
        if(x == y) {return;}
        if(par[x] > par[y]) {swap(x, y);}
        par[x] += par[y];
        par[y] = x;
        e++;
      }
      void unite(pair<ll, ll> x) { unite(x.first, x.second); }
      bool same(ll x, ll y) { return root(x) == root(y); }
      bool same(pair<ll, ll> x) { return same(x.first, x.second); }
      ll size(ll x) { return -par[root(x)]; }
      vector<vector<ll>> group() {
        vector<vector<ll>> r(v);
        for(ll i = 0; i < v; i++) {r[root(i)].emplace_back(i);}
        r.erase(remove_if(begin(r), end(r), [&](vector<ll> &r_) { return r_.empty(); }));
        return r;
      }
      ll operator[](ll i) { return root(i); }
      void operator()(ll x, ll y) { unite(x, y); }
      void operator()(pair<ll, ll> x) { unite(x); }
      ll operator()() { return v - e; }
    };
    """

  'unionfind':
    'prefix':'unionfind'
    'body':'Unionfind u(n);'

  'CycleCheck':
    'prefix':'cycle'
    'body':"""
    bool CycleCheck(graph &g) {
      Unionfind u(g.size());
      for(ll i = 0; i < g.size(); i++) {
        for(auto &j : g[i]) {
          if(i < j && u.same(i, j)) {return true;}
          u(i, j);
        }
      }
      return false;
    }
    // depends on : graph , Unionfind
    """

  'Rollback_Unionfind':
    'prefix':'Rollback_Unionfind'
    'body':"""
    template<typename S, auto op, auto e> struct RollbackUnionfind {
     private:
      vector<int> par;
      vector<S> val;
      stack<tuple<int, int, S, int>> history;
      int snap, cnt;

     public:
      RollbackUnionfind() = default;
      RollbackUnionfind(int n): RollbackUnionfind(vector<S>(n, e())) {}
      RollbackUnionfind(const vector<S> &v): par(v.size(), -1), val(v), snap(0), cnt(v.size()) {}
      int root(int v) const {
        if(par[v] < 0) { return v; }
        return root(par[v]);
      }
      void unite(int u, int v) {
        u = root(u), v = root(v);
        history.emplace(-1, 0, e(), cnt);
        history.emplace(u, par[u], val[u], cnt);
        history.emplace(v, par[v], val[v], cnt);
        if(u == v) { return; }
        if(par[u] > par[v]) { swap(u, v); }
        par[u] += par[v];
        par[v] = u;
        val[u] = op(val[u], val[v]);
        cnt--;
      }
      void undo() {
        assert(!history.empty());
        while(true) {
          auto [v, p, x, c] = history.top();
          history.pop();
          if(v == -1) { break; }
          par[v] = p;
          val[v] = x;
          cnt = c;
        }
      }
      bool same(int u, int v) const { return root(u) == root(v); }
      int size(int v) const { return -par[root(v)]; }
      int count() const { return cnt; }
      S prod(int v) const { return val[root(v)]; }
      void update(int v, const S &x) {
        v = root(v);
        history.emplace(-1, 0, e(), cnt);
        history.emplace(v, par[v], val[v], cnt);
        val[v] = op(val[x], x);
      }
      int state() const { return history.size(); }
      void snapshot() { snap = history.size(); }
      void rollback(int p = -1) {
        if(p == -1) { p = snap; }
        while(p < (int)history.size()) { undo(); }
      }
    };
    """

  'rollback_unionfind':
    'prefix':'rollback_unionfind'
    'body':'RollbackUnionfind<S,op,e> u(N);'

  'WeightedUnionfind':
    'prefix':'WeightedUnionfind'
    'body':"""
    template<typename T> struct WeightedUnionfind {
      vector<ll> par, rank;
      vector<T> diff_;
      WeightedUnionfind(ll n): par(n), rank(n), diff_(n) {
        for(ll i = 0; i < n; i++) {par[i] = i, rank[i] = diff_[i] = 0;}
      }
      ll root(ll x) {
        if(par[x] == x) {return x;}
        else {
          ll r = root(par[x]);
          diff_[x] += diff_[par[x]];
          return par[x] = r;
        }
      }
      T weight(ll x) {
        root(x);
        return diff_[x];
      }
      void unite(ll x, ll y, T w) {
        w += weight(x) - weight(y);
        x = root(x), y = root(y);
        if(x == y) {return;}
        if(rank[x] < rank[y]) {swap(x, y), w = -w;}
        if(rank[x] == rank[y]) {rank[x]++;}
        par[y] = x;
        diff_[y] = w;
      }
      void unite(pair<ll, ll> x, T w) { unite(x.first, x.second, w); }
      bool same(ll x, ll y) { return root(x) == root(y); }
      bool same(pair<ll, ll> x) { return same(x.first, x.second); }
      T diff(ll x, ll y) { return weight(y) - weight(x); }
    };
    """

  'weightedunionfind':
    'prefix':'weightedunionfind'
    'body':'WeightedUnionfind<ll> u(n);'

  'LCA':
    'prefix':'LCA'
    'body':"""
    struct LCA {
      vector<vector<ll>> par;
      vector<ll> di, order, tsiz;
      LCA(graph &g, ll r = 0) { ini(g, r); }
      void ini(graph &g, ll r = 0) {
        ll s = g.size(), h = 1;
        while((1LL << h) < s) {h++;}
        par.assign(h, vector<ll>(s, -1));
        di.assign(s, -1);
        tsiz.resize(s);
        dfs(g, r, -1, 0);
        for(ll i = 0; i < h - 1; i++) {
          for(ll j = 0; j < s; j++) {
            if(par[i][j] < 0) {par[i + 1][j] = -1;}
            else {par[i + 1][j] = par[i][par[i][j]];}
          }
        }
      }
      void dfs(graph &g, ll v, ll p, ll d) {
        par[0][v] = p;
        di[v] = d;
        order.emplace_back(v);
        for(auto &nv : g[v]) {
          if(nv != p) {dfs(g, nv, v, d + 1);}
        }
        // tsiz[v] = 1; for(auto &nv : g[v]) {if(nv != p) {tsiz[v] += tsiz[nv];}}
      }
      ll lca(ll x, ll y) {
        if(di[x] < di[y]) swap(x, y);
        ll k = par.size();
        for(ll i = 0; i < k; i++) {
          if((di[x] - di[y]) >> i & 1) {x = par[i][x];}
        }
        if(x == y) return x;
        for(ll i = k - 1; i >= 0; i--) {
          if(par[i][x] != par[i][y]) {x = par[i][x], y = par[i][y];}
        }
        return par[0][x];
      }
      ll dis(ll x, ll y) { return di[x] + di[y] - 2 * di[lca(x, y)]; }
      bool onpath(ll x, ll y, ll p) { return dis(x, p) + dis(p, y) == dis(x, y); }
      ll operator()(ll x, ll y) { return dis(x, y); }
      bool operator()(ll x, ll y, ll p) { return onpath(x, y, p); }
    };
    // depends on : graph
    """

  'LCA_w':
    'prefix':'LCA_w'
    'body':"""
    template<typename T> struct LCA {
      vector<vector<ll>> par;
      vector<ll> di, order, tsiz;
      vector<T> DI;
      LCA(vector<vector<pair<ll,T>>> &g, ll r = 0) { ini(g, r); }
      void ini(vector<vector<pair<ll,T>>> &g, ll r = 0) {
        ll s = g.size(), h = 1;
        while((1LL << h) < s) {h++;}
        par.assign(h, vector<ll>(s, -1));
        di.assign(s, -1);
        DI.assign(s, -1);
        tsiz.resize(s);
        dfs(g, r, -1, 0, 0);
        for(ll i = 0; i < h - 1; i++) {
          for(ll j = 0; j < s; j++) {
            if(par[i][j] < 0) {par[i + 1][j] = -1;}
            else {par[i + 1][j] = par[i][par[i][j]];}
          }
        }
      }
      void dfs(vector<vector<pair<ll,T>>> &g, ll v, ll p, ll d, T D) {
        par[0][v] = p;
        di[v] = d;
        DI[v] = D;
        order.emplace_back(v);
        for(auto &nv : g[v]) {
          if(nv.first != p) {dfs(g, nv.first, v, d + 1, D + nv.second);}
        }
        // tsiz[v]=1; for(auto &nv:g[v]) {if(nv.first!=p){ tsiz[v]+=tsiz[nv.first];}}
      }
      ll lca(ll x, ll y) {
        if(di[x] < di[y]) {swap(x, y);}
        ll k = par.size();
        for(ll i = 0; i < k; i++) {
          if((di[x] - di[y]) >> i & 1) {x = par[i][x];}
        }
        if(x == y) {return x;}
        for(ll i = k - 1; i >= 0; i--) {
          if(par[i][x] != par[i][y]){ x = par[i][x], y = par[i][y];}
        }
        return par[0][x];
      }
      T dis(ll x, ll y) { return DI[x] + DI[y] - 2 * DI[lca(x, y)]; }
      bool onpath(ll x, ll y, ll p) { return dis(x, p) + dis(p, y) == dis(x, y); }
      T operator()(ll x, ll y) { return dis(x, y); }
      bool operator()(ll x, ll y, ll p) { return onpath(x, y, p); }
    };
    // depends on : weighted_graph

    """

  'RectangleSum':
    'prefix':'RectangleSum'
    'body':"""
    template<typename T> struct RectangleSum {
      int H, W;
      vector<vector<T>> v;
      RectangleSum(int h, int w): H(h), W(w), v(H + 3, vector<T>(W + 3, 0)) {}
      RectangleSum(vector<vector<T>> &ini): H(ini.size()), W(ini[0].size()), v(H + 3, vector<T>(W + 3, 0)) {
        for(int i = 0; i < H; i++) {
          for(int j = 0; j < W; j++) { v[i + 1][j + 1] += ini[i][j]; }
        }
        build();
      }
      void add(int x, int y, T a = 1) { v[x + 1][y + 1] += a; }
      void imos_add(int lx, int rx, int ly, int ry, T a = 1) { add(lx, ly, a), add(lx, ry, -a), add(rx, ly, -a), add(rx, ry, a); }
      void build() {
        for(int i = 1; i < (int)v.size(); i++) {
          for(int j = 1; j < (int)v[i].size(); j++) { v[i][j] += v[i][j - 1] + v[i - 1][j] - v[i - 1][j - 1]; }
        }
      }
      T sum(int lx, int rx, int ly, int ry) const { return v[rx][ry] - v[lx][ry] - v[rx][ly] + v[lx][ly]; }
      T operator()(int lx, int rx, int ly, int ry) const { return v[rx][ry] - v[lx][ry] - v[rx][ly] + v[lx][ly]; }
      T imos_get(int x, int y) { return v[x + 1][y + 1]; }
      vector<vector<T>> imos() const { return v; }
    };
    // 0-indexed, 半開区間
    // add / imos_add -> build -> sum / get , 併用不可
    """

  'rectanglesum':
    'prefix':'rectanglesum'
    'body':'RectangleSum<ll> S($1);'

  'BIT':
    'prefix':'BIT'
    'body':"""
    template<typename T> struct BIT {
      vector<T> v;
      ll n;
      bool imos;
      BIT(ll n_, bool imos_ = 0): v(n_ + 1, 0), n(n_ + 1), imos(imos_) {}
      BIT(vector<T> &a, bool imos_ = 0): v(a.size() + 1, 0), n(v.size()), imos(imos_) {
        if(!imos) {
          for(ll i = 0; i < a.size(); i++) {add(i, a[i]);}
        }
        else {
          for(ll i = 0; i < a.size(); i++) {imos_add(i, a[i]);}
        }
      }
      void add(ll i, T x) {
        for(i++; i < n; i += (i & -i)) {v[i] += x;}
      }
      void imos_add(ll l, ll r, T x) {
        imos = true;
        add(l, x), add(r + 1, -x);
      }
      void imos_add(ll i, T x) { imos_add(i, i, x); }
      T sum(ll r) {  // sum[0,r] imos:v[r]
        T re = T();
        for(r++; r > 0; r -= (r & -r)) {re += v[r];}
        return re;
      }
      T sum(ll l, ll r) { return sum(r) - sum(l - 1); }  // sum[l,r]
      T operator()(ll r) { return sum(r); }
      T operator()(ll l, ll r) { return sum(l, r); }
      T operator[](ll i) { return imos ? sum(i) : sum(i) - sum(i - 1); }
      ll LB(T x) {  // sum[0,i]<xとなるiの個数 / sum[0,i]>=xとなる最小のi
        ll i = 0;
        for(ll k = 1 << (__lg(n - 1) + 1); k > 0; k >>= 1) {
          if(i + k < n && v[i + k] < x) {
            x -= v[i + k];
            i += k;
          }
        }
        return i;
      }
      ll UB(T x) {  // sum[0,i]<=xとなるiの個数 / sum[0,i]>xとなる最小のi
        ll i = 0;
        for(ll k = 1 << (__lg(n - 1) + 1); k > 0; k >>= 1) {
          if(i + k < n && v[i + k] <= x) {
            x -= v[i + k];
            i += k;
          }
        }
        return i;
      }
    };
    """

  'BIT_':
    'prefix':'bit'
    'body':'BIT<ll> b(n);'

  'BIT2D':
    'prefix':'BIT2D'
    'body':"""
    template<typename T> struct BIT2D {
      int H, W;
      vector<vector<T>> bit;
      BIT2D(int h, int w): H(h + 1), W(w + 1) { bit.resize(H + 3, vector<T>(W + 3, T(0))); };
      BIT2D(vector<vector<T>> v): H(v.size()), W(v[0].size()) {
        bit.resize(H + 3, vector<T>(W + 3, T(0)));
        for(int i = 0; i < H; i++) {
          for(int j = 0; j < W; j++) { add(i, j, v[i][j]); }
        }
      };
      void add(int x, int y, T w) {
        if(x < 0 || y < 0 || x >= H || y >= W) { return; }
        for(int a = (++y, ++x); a <= H; a += a & -a) {
          for(int b = y; b <= W; b += b & -b) { bit[a][b] += w; }
        }
      }
      void imos_add(int lx, int rx, int ly, int ry, T w) { add(lx, ly, w), add(lx, ry, -w), add(rx, ly, -w), add(rx, ry, w); }
      void imos_add(int x, int y, T w) { imos_add(x, y, x, y, w); }
      T sum(int x, int y) {
        x--, y--;
        T r = 0;
        for(int a = (++y, ++x); a > 0; a -= a & -a) {
          for(int b = y; b > 0; b -= b & -b) { r += bit[a][b]; }
        }
        return r;
      }
      T sum(int lx, int rx, int ly, int ry) { return sum(rx, ry) - sum(rx, ly) - sum(lx, ry) + sum(lx, ly); }
      T imos_get(int x, int y) { return sum(++x, ++y); }
    };
    """

  'bit2d':
    'prefix':'bit2d'
    'body':'BIT2D<ll> B(h,w);'

  'Segtree':
    'prefix':'Segtree'
    'body':"""
    using S = ll;
    // struct S{};
    S op(S l, S r) { return $1; }
    S e() { return $2; }
    S tar;
    bool F(S x) { return $3; }

    /*
    void seg.set(i,x);   -> a[i] = x;
    T    seg.get(i);     -> return a[i];
    T    seg.prod(l,r)   -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()  -> return op(a[0], ... , a[n - 1]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */
    """

  'segtree':
    'prefix':'segtree'
    'body':'segtree<S,op,e> seg($1);'

  'Lazy_add_min':
    'prefix':'Lazy_add_min'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return min(l,r);}
    S e(){return 1e18;}
    S fx(F f,S x){return f+x;}
    F fg(F f,F g){return f+g;}
    F id(){return 0;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_add_max':
    'prefix':'Lazy_add_max'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return max(l,r);}
    S e(){return -1e18;}
    S fx(F f,S x){return f+x;}
    F fg(F f,F g){return f+g;}
    F id(){return 0;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_add_sum':
    'prefix':'Lazy_add_sum'
    'body':"""
    struct S{ll val,siz;};
    using F = ll;
    S op(S l,S r){return {l.val+r.val,l.siz+r.siz};}
    S e(){return {0,0};}
    S fx(F f,S x){return {x.val+f*x.siz,x.siz};}
    F fg(F f,F g){return f+g;}
    F id(){return 0;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    // V<S> a(n,{0,1});

    """

  'Lazy_update_min':
    'prefix':'Lazy_update_min'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return min(l,r);}
    S e(){return 1e18;}
    S fx(F f,S x){return (f==1e18?x:f);}
    F fg(F f,F g){return (f==1e18?g:f);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_update_max':
    'prefix':'Lazy_update_max'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return max(l,r);}
    S e(){return -1e18;}
    S fx(F f,S x){return (f==1e18?x:f);}
    F fg(F f,F g){return (f==1e18?g:f);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_update_sum':
    'prefix':'Lazy_update_sum'
    'body':"""
    struct S{ll val,siz;};
    using F = ll;
    S op(S l,S r){return {l.val+r.val,l.siz+r.siz};}
    S e(){return {0,0};}
    S fx(F f,S x){if(f!=1e18) x.val=f*x.siz; return x;}
    F fg(F f,F g){return (f==1e18?g:f);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    // V<S> a(n,{0,1});

    """

  'Lazy_chmax_min':
    'prefix':'Lazy_chmax_min'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return min(l,r);}
    S e(){return 1e18;}
    S fx(F f,S x){return max(f,x);}
    F fg(F f,F g){return max(f,g);}
    F id(){return -1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_chmax_max':
    'prefix':'Lazy_chmax_max'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return max(l,r);}
    S e(){return -1e18;}
    S fx(F f,S x){return max(f,x);}
    F fg(F f,F g){return max(f,g);}
    F id(){return -1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_chmin_min':
    'prefix':'Lazy_chmin_min'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return min(l,r);}
    S e(){return 1e18;}
    S fx(F f,S x){return min(f,x);}
    F fg(F f,F g){return min(f,g);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_chmin_max':
    'prefix':'Lazy_chmin_max'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return max(l,r);}
    S e(){return -1e18;}
    S fx(F f,S x){return min(f,x);}
    F fg(F f,F g){return min(f,g);}
    F id(){return 1e18;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_affine_max':
    'prefix':'Lazy_affine_max'
    'body':"""
    using S = ll;
    using F = pair<ll, ll>;
    S op(S l, S r) { return max(l, r); }
    S e() { return -1e18; }
    S fx(F f, S x) { return f.first * x + f.second; }
    F fg(F f, F g) { return {f.first * g.first, f.first * g.second + f.second}; }
    F id() { return {1, 0}; }

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_affine_min':
    'prefix':'Lazy_affine_min'
    'body':"""
    using S = ll;
    using F = pair<ll, ll>;
    S op(S l, S r) { return min(l, r); }
    S e() { return 1e18; }
    S fx(F f, S x) { return f.first * x + f.second; }
    F fg(F f, F g) { return {f.first * g.first, f.first * g.second + f.second}; }
    F id() { return {1, 0}; }

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'Lazy_affine_sum':
    'prefix':'Lazy_affine_sum'
    'body':"""
    struct S {
      ll val, siz;
    };
    using F = pair<ll, ll>;
    S op(S l, S r) { return {l.val + r.val, l.siz + r.siz}; }
    S e() { return {0, 0}; }
    S fx(F f, S x) { return {f.first * x.val + f.second * x.siz, x.siz}; }
    F fg(F f, F g) { return {f.first * g.first, f.first * g.second + f.second}; }
    F id() { return {1, 0}; }

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """


  'Lazy_void':
    'prefix':'Lazy_void'
    'body':"""
    using S = ll;
    using F = ll;
    S op(S l,S r){return ;}
    S e(){return ;}
    S fx(F f,S x){return ;}
    F fg(F f,F g){return ;}
    F id(){return ;}

    /*
    void seg.set(i,x);    -> a[i] = x;
    T    seg.get(i);      -> return a[i];
    T    seg.prod(l,r)    -> return op(a[l], ... , a[r - 1]);
    T    seg.all_prod()   -> return op(a[0], ... , a[n - 1]);
    void seg.apply(i,f)   -> a[i] = f(a[i]);
    void seg.apply(l,r,f) -> l <= i < r について a[i] = f(a[i]);
    ll   seg.max_right<F>(l) -> F(op(a[l], ... , a[r - 1])) = true となる最大の r
    ll   seg.min_left<F>(r)  -> F(op(a[l], ... , a[r - 1])) = true となる最小の l
    */

    """

  'lazy_segtree':
    'prefix':'lazy_segtree'
    'body':'lazy_segtree<S,op,e,F,fx,fg,id> seg($1);'

  'Mo':
    'prefix':'Mo'
    'body':"""
    struct Mo {
      ll W;
      vector<ll> L, R, O;
      Mo(ll N, ll Q): O(Q) {
        W = max<ll>(1LL, 1.0 * N / max<long double>(1.0, sqrt(Q * 2.0 / 3.0)));
        iota(O.begin(), O.end(), 0);
      }
      void operator()(ll l, ll r) {  // [l,r)
        L.emplace_back(l);
        R.emplace_back(r);
      }
      template<typename AL, typename AR, typename DL, typename DR, typename REM>
      void solve(const AL &add_l, const AR &add_r, const DL &del_l, const DR &del_r, const REM &rem) {
        sort(O.begin(), O.end(), [&](ll a, ll b) {
          ll A = L[a] / W, B = L[b] / W;
          if(A != B) {return A < B;}
          if(A & 1) {return R[a] < R[b];}
          return R[a] > R[b];
        });
        ll nl = 0, nr = 0;
        for(auto i : O) {
          while(nl > L[i]) {add_l(--nl);}
          while(nr < R[i]) {add_r(nr++);}
          while(nl < L[i]) {del_l(nl++);}
          while(nr > R[i]) {del_r(--nr);}
          rem(i);
        }
      }
      template<typename AL, typename AR, typename DL, typename DR, typename REM>
      void operator()(const AL &add_l, const AR &add_r, const DL &del_l, const DR &del_r, const REM &rem) { solve(add_l, add_r, del_l, del_r, rem); }
      template<typename A, typename D, typename REM>
      void operator()(const A &add, const D &del, const REM &rem) { solve(add, add, del, del, rem); }
    };

    auto add = [&](ll i) {};
    auto del = [&](ll i) {};
    auto rem = [&](ll i) {};
    // main の中に入れる
    """

  'Geometry':
    'prefix':'Geometry'
    'body':"""
    using Real = long double;
    constexpr Real EPS = 1e-10, PI = 3.141592653589793238462643383279L;
    bool eq(Real a, Real b = 0) { return fabs(b - a) < EPS; }
    int sign(Real a) { return !eq(a) ? a > 0 ? 1 : -1 : 0; }
    Real rtod(Real r) { return r * 180.0 / PI; }
    Real dtor(Real d) { return d * PI / 180.0; }

    struct Point {
      Real x, y;
      Point(): x(0), y(0) {}
      Point(Real x, Real y): x(x), y(y) {}
      template<typename T, typename U> Point(const pair<T, U> &p): x(p.first), y(p.second) {}
      Point operator+(const Point &p) const { return {x + p.x, y + p.y}; }
      Point operator-(const Point &p) const { return {x - p.x, y - p.y}; }
      Point operator*(Real r) const { return {x * r, y * r}; }
      Point operator/(Real r) const { return {x / r, y / r}; }
      Point &operator+=(const Point &p) { return (*this) = (*this) + p; }
      Point &operator-=(const Point &p) { return (*this) = (*this) - p; }
      Point &operator*=(Real r) { return (*this) = (*this) * r; }
      Point &operator/=(Real r) { return (*this) = (*this) / r; }
      bool operator<(const Point &p) const { return x != p.x ? x < p.x : y < p.y; }
      bool operator==(const Point &p) const { return x == p.x && y == p.y; }
      bool operator!=(const Point &p) const { return !((*this) == p); }
      Point rotate(Real t) const { return {x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)}; }
      Real real() const { return x; }
      Real imag() const { return y; }
      friend Real real(const Point &p) { return p.x; }
      friend Real imag(const Point &p) { return p.y; }
      friend Real dot(const Point &l, const Point &r) { return l.x * r.x + l.y * r.y; }
      friend Real cross(const Point &l, const Point &r) { return l.x * r.y - l.y * r.x; }
      friend Real abs(const Point &p) { return sqrt(p.x * p.x + p.y * p.y); }
      friend Real norm(const Point &p) { return p.x * p.x + p.y * p.y; }
      friend Real distance(const Point &l, const Point &r) { return abs(l - r); }
      friend Real arg(const Point &p) { return atan2(p.y, p.x); }
      friend istream &operator>>(istream &is, Point &p) {
        Real a, b;
        is >> a >> b;
        p = Point{a, b};
        return is;
      }
      friend ostream &operator<<(ostream &os, const Point &p) { return os << p.x << " " << p.y; }
    };
    using Points = vector<Point>;

    Real angle(const Point &a, const Point &b, const Point &c) {  // ∠ABC (acute)
      const Point v = a - b, w = c - b;
      Real t1 = arg(v), t2 = arg(w);
      if(t1 > t2) { swap(t1, t2); }
      Real t = t2 - t1;
      return min(t, 2 * PI - t);
    }

    int ccw(const Point &a, const Point &b, const Point &c) {
      const Point x = b - a, y = c - a;
      if(cross(x, y) > EPS) { return +1; }  // a,b,c counterclockwise
      if(cross(x, y) < -EPS) { return -1; }  // a,b,c clockwise
      if(min(norm(x), norm(y)) < EPS * EPS) { return 0; }  // c=a or c=b
      if(dot(x, y) < EPS) { return +2; }  // c-a-b
      if(norm(x) < norm(y)) { return -2; }  // a-b-c
      return 0;  // a-c-b
    }

    using Polygon = vector<Point>;
    using Polygons = vector<Polygon>;

    int Contains(const Polygon &P, const Point &p) {  // 0:out, 1:on, 2:in
      bool in = false;
      const int N = P.size();
      for(int i = 0; i < N; i++) {
        Point a = P[i] - p, b = P[(i + 1) % N] - p;
        if(a.y > b.y) { swap(a, b); }
        if(a.y < EPS && b.y > EPS && cross(a, b) < -EPS) { in = !in; }
        if(eq(cross(a, b)) && dot(a, b) < EPS) { return 1; }
      }
      return in ? 2 : 0;
    }

    int ConvexContains(const Polygon &C, const Point &p) {  // 0:out, 1:on, 2:in
      const int N = C.size();
      if(N == 0) { return 0; }
      if(N == 1) { return C[0] == p; }
      Real b1 = cross(C[1] - C[0], p - C[0]), b2 = cross(C[N - 1] - C[0], p - C[0]);
      if(b1 < -EPS || b2 > EPS) { return 0; }
      int L = 1, R = N - 1;
      while(R - L > 1) {
        int M = (L + R) >> 1;
        (cross(p - C[0], C[M] - C[0]) >= 0 ? R : L) = M;
      }
      Real v = cross(C[L] - p, C[R] - p);
      if(eq(v)) { return 1; }
      else if(v > 0) { return eq(b1) || eq(b2) ? 1 : 2; }
      else { return 0; }
    }

    bool isConvex(const Polygon &P) {
      const int N = P.size();
      for(int i = 0; i < N; i++) {
        if(ccw(P[(i + N - 1) % N], P[i], P[(i + 1) % N]) == -1) { return false; }
      }
      return true;
    }

    template<bool boundary = false> Polygon ConvexHull(Polygon P, bool sorted = false) {
      const int N = P.size();
      int k = 0;
      if(N <= 2) { return P; }
      if(!sorted) { sort(P.begin(), P.end()); }
      Polygon C(2 * N);
      Real e = boundary ? -EPS : EPS;
      for(int i = 0; i < N; C[k++] = P[i++]) {
        while(k >= 2 && cross(C[k - 1] - C[k - 2], P[i] - C[k - 1]) < e) { k--; }
      }
      for(int i = N - 2, t = k + 1; i >= 0; C[k++] = P[i--]) {
        while(k >= t && cross(C[k - 1] - C[k - 2], P[i] - C[k - 1]) < e) { k--; }
      }
      C.resize(k - 1);
      return C;
    }

    Real Area(const Polygon &P) {
      const int N = P.size();
      Real A = 0;
      for(int i = 0; i < N; i++) { A += cross(P[i], P[(i + 1) % N]); }
      return A * 0.5;
    }

    pair<int, int> ConvexDiameter(const Polygon &P) {
      const int N = P.size();
      int is = 0, js = 0;
      for(int i = 1; i < N; i++) {
        if(P[i].y > P[is].y) { is = i; }
        if(P[i].y < P[js].y) { js = i; }
      }
      Real maxdis = norm(P[is] - P[js]);
      int maxi = is, maxj = js, i = is, j = js;
      do {
        if(cross(P[(i + 1) % N] - P[i], P[(j + 1) % N] - P[j]) >= 0) { j = (j + 1) % N; }
        else { i = (i + 1) % N; }
        if(norm(P[i] - P[j]) > maxdis) {
          maxdis = norm(P[i] - P[j]);
          maxi = i, maxj = j;
        }
      } while(i != is || j != js);
      return minmax(maxi, maxj);
    }

    pair<Point, Point> ClosestPair(Points P) {
      const int N = P.size();
      assert(N >= 2);
      sort(P.begin(), P.end());
      Real d = 9e18;
      Point a, b;
      auto f = [&](auto &&f, int l, int r) -> void {
        const int m = (l + r) >> 1;
        if(r - l <= 1) { return; }
        const Real x = P[m].x;
        f(f, l, m);
        f(f, m, r);
        inplace_merge(P.begin() + l, P.begin() + m, P.begin() + r, [](const auto &a, const auto &b) { return a.y < b.y; });
        vector<int> B;
        for(int i = l; i < r; i++) {
          if(sign(abs(P[i].x - x) - d) > 0) { continue; }
          for(int j = (int)B.size() - 1; j >= 0; j--) {
            if(sign(P[i].y - P[B[j]].y - d) > 0) { break; }
            if(sign(d - distance(P[i], P[B[j]])) > 0) {
              d = distance(P[i], P[B[j]]);
              a = P[i], b = P[B[j]];
            }
          }
          B.emplace_back(i);
        }
      };
      f(f, 0, N);
      return {a, b};
    }
    """

  'Geometry_Line':
    'prefix':'Geometry_Line'
    'body':"""
    struct Line {
      Point a, b;
      Line() = default;
      Line(const Point &a, const Point &b): a(a), b(b) {}
      Line(const Real &A, const Real &B, const Real &C) {  // Ax + By = C
        if(eq(A)) {
          assert(!eq(B));
          a = Point(0, C / B), b = Point(1, C / B);
        }
        else if(eq(B)) { a = Point(C / A, 0), b = Point(C / A, 1); }
        else { a = Point(0, C / B), b = Point(C / A, 0); }
      }
      friend istream &operator>>(istream &is, Line &l) { return is >> l.a >> l.b; }
      friend ostream &operator<<(ostream &os, const Line &l) { return os << l.a << " to " << l.b; }
    };
    using Lines = vector<Line>;

    bool parallel(const Line &l, const Line &r) { return eq(cross(l.b - l.a, r.b - r.a)); }
    bool orthogonal(const Line &l, const Line &r) { return eq(dot(l.a - l.b, r.a - r.b)); }
    Point projection(const Line &l, const Point &p) { return l.a + (l.a - l.b) * (dot(p - l.a, l.a - l.b) / norm(l.a - l.b)); }
    Point reflection(const Line &l, const Point &p) { return projection(l, p) * 2 - p; }
    bool intersect(const Line &l, const Point &p) { return abs(ccw(l.a, l.b, p)) != 1; }
    int intersect(const Line &l, const Line &r) { return parallel(l, r) ? intersect(l, r.a) ? 2 : 0 : 1; }  // 0:parallel, 1:intersect 2:l=r
    Real distance(const Line &l, const Point &p) { return distance(p, projection(l, p)); }
    Real distance(const Line &l, const Line &r) { return intersect(l, r) ? 0 : distance(l, r.a); }
    Point crosspoint(const Line &l, const Line &r) {
      Real A = cross(l.b - l.a, r.b - r.a), B = cross(l.b - l.a, l.b - r.a);
      return eq(A) && eq(B) ? r.a : r.a + (r.b - r.a) * B / A;
    }

    Polygon ConvexCut(const Polygon &P, const Line &l) {
      const int N = P.size();
      Polygon r;
      for(int i = 0; i < N; i++) {
        const Point &now = P[i], &nxt = P[(i + 1) % N];
        Real cf = cross(l.a - now, l.b - now), cs = cross(l.a - nxt, l.b - nxt);
        if(sign(cf) >= 0) { r.emplace_back(now); }
        if(sign(cf) * sign(cs) < 0) { r.emplace_back(crosspoint(Line(now, nxt), l)); }
      }
      return r;
    }
    """

  'Geometry_Segment':
    'prefix':'Geometry_Segment'
    'body':"""
    struct Segment : Line {
      Segment() = default;
      using Line::Line;
    };
    using Segments = vector<Segment>;

    bool intersect(const Segment &s, const Point &p) { return ccw(s.a, s.b, p) == 0; }
    bool intersect(const Line &l, const Segment &s) { return sign(cross(l.b - l.a, s.a - l.a)) * sign(cross(l.b - l.a, s.b - l.a)) <= 0; }
    bool intersect(const Segment &l, const Segment &r) { return ccw(l.a, l.b, r.a) * ccw(l.a, l.b, r.b) <= 0 && ccw(r.a, r.b, l.a) * ccw(r.a, r.b, l.b) <= 0; }
    Real distance(const Segment &s, const Point &p) { return intersect(s, projection(s, p)) ? distance(p, projection(s, p)) : min(distance(s.a, p), distance(s.b, p)); }
    Real distance(const Line &l, const Segment &s) { return intersect(l, s) ? 0 : min(distance(l, s.a), distance(l, s.b)); }
    Real distance(const Segment &l, const Segment &r) { return intersect(l, r) ? 0 : min({distance(l, r.a), distance(l, r.b), distance(r, l.a), distance(r, l.b)}); }

    void MergeSegments(Segments &S) {
      auto merge_if_able = [](Segment &s1, const Segment &s2) {
        if(sign(cross(s1.b - s1.a, s2.b - s2.a)) == 1) { return 0; }
        if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) { return 0; }
        if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) { return 0; }
        s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));
        return 1;
      };
      for(int i = 0; i < (int)S.size(); i++) {
        if(S[i].b < S[i].a) { swap(S[i].a, S[i].b); }
      }
      for(int i = 0; i < (int)S.size(); i++) {
        for(int j = i + 1; j < (int)S.size(); j++) {
          if(merge_if_able(S[i], S[j])) {
            S[j--] = S.back();
            S.pop_back();
          }
        }
      }
    }

    vector<vector<int>> SegmentArrangement(Segments &S, Points &P) {
      vector<vector<int>> g;
      const int N = S.size();
      for(int i = 0; i < N; i++) {
        P.push_back(S[i].a);
        P.push_back(S[i].b);
        for(int j = i + 1; j < N; j++) {
          const Point p1 = S[i].b - S[i].a, p2 = S[j].b - S[j].a;
          if(eq(cross(p1, p2))) { continue; }
          if(intersect(S[i], S[j])) { P.push_back(crosspoint(S[i], S[j])); }
        }
      }
      sort(P.begin(), P.end());
      P.erase(unique(P.begin(), P.end()), P.end());
      const int M = P.size();
      g.resize(M);
      for(int i = 0; i < N; i++) {
        vector<int> v;
        for(int j = 0; j < M; j++) {
          if(intersect(S[i], P[j])) { v.push_back(j); }
        }
        for(int j = 1; j < (int)v.size(); j++) {
          g[v[j - 1]].push_back(v[j]);
          g[v[j]].push_back(v[j - 1]);
        }
      }
      return g;
    }
    """

  'Geometry_Circle':
    'prefix':'Geometry_Circle'
    'body':"""
    struct Circle {
      Point p;
      Real r{};
      Circle() = default;
      Circle(const Point &p, const Real &r): p(p), r(r) {}
      friend istream &operator>>(istream &is, Circle &c) { return is >> c.p >> c.r; }
      friend ostream &operator<<(ostream &os, Circle &c) { return os << c.p << " ," << c.r; }
    };
    using Circles = vector<Circle>;

    int contains(const Circle &c, const Point &p) { return sign(c.r - distance(c.p, p)) + 1; }  // 0:out, 1:on, 2:in
    bool intersect(const Circle &c, const Point &p) { return eq(c.r, distance(c.p, p)); }
    int intersect(const Circle &c, const Line &l) { return contains(c, projection(l, c.p)); }
    int intersect(const Circle &c, const Segment &s) {
      int r = intersect(c, Line(s)), f = ccw(s.a, s.b, projection(s, c.p));
      if(r == 0) { return 0; }
      if(r == 1) { return f == 0 ? 1 : 0; }
      int f1 = sign(abs(c.p - s.a) - c.r), f2 = sign(abs(c.p - s.b) - c.r);
      if(f1 < 0 && f2 < 0) { return 0; }
      if(f1 < 0 || f2 < 0) { return 1; }
      if(f1 == 0 && f2 == 0) { return 2; }
      if(f1 == 0 || f2 == 0) { return f == 0 ? 2 : 1; }
      return f == 0 ? 2 : 0;
    }
    int intersect(const Circle &a, const Circle &b) {  // +2:外部 -2:内部 +1:外接 -1:内接 0:2点で交わる
      Real d = distance(a.p, b.p), R = a.r + b.r, r = fabs(a.r - b.r);
      if(sign(d - R) > 0) { return +2; }
      if(sign(d - r) < 0) { return -2; }
      if(eq(d, R)) { return +1; }
      if(eq(d, r)) { return -1; }
      return 0;
    }
    Points crosspoint(const Circle &c, const Line &l) {
      Point h = projection(l, c.p);
      if(intersect(c, l) == 0) { return {}; }
      if(intersect(c, l) == 1) { return {h}; }
      Point e = (l.b - l.a) / distance(l.a, l.b) * sqrt(norm(c.r) - norm(h - c.p));
      return {h + e, h - e};
    }
    Points crosspoint(const Circle &c, const Segment &s) {
      if(intersect(c, s) == 0) { return {}; }
      Points r = crosspoint(c, Line(s));
      if(intersect(c, s) == 2) { return r; }
      if(dot(s.a - r[0], s.b - r[0]) > 0) { swap(r[0], r[1]); }
      return {r[0]};
    }
    Points crosspoint(const Circle &l, const Circle &r) {
      const int i = intersect(l, r);
      if(abs(i) == 2) { return {}; }
      Real d = distance(l.p, r.p), t = acos((l.r * l.r - r.r * r.r + d * d) / (2 * l.r * d)), s = arg(r.p - l.p);
      Point e(l.r, 0), p = l.p + e.rotate(s + t), q = l.p + e.rotate(s - t);
      if(abs(i) == 1) { return {p}; }
      return {p, q};
    }
    Points tangent(const Circle &c, const Point &p) {
      const int i = contains(c, p);
      if(i == 2) { return {}; }
      if(i == 1) { return {p}; }
      return crosspoint(c, Circle(p, sqrt(norm(p - c.p) - c.r * c.r)));
    }
    Lines tangent(Circle &l, Circle &r) {
      Lines ret;
      if(sign(l.r - r.r) < 0) { swap(l, r); }
      Real g = norm(l.p - r.p);
      if(eq(g)) { return ret; }
      Point u = (r.p - l.p) / sqrt(g), v = u.rotate(PI * 0.5);
      for(int s : {-1, 1}) {
        Real h = (l.r + s * r.r) / sqrt(g);
        if(eq(1 - h * h)) { ret.emplace_back(Line(l.p + u * l.r, l.p + (u + v) * l.r)); }
        else if(sign(1 - h * h) > 0) {
          Point uu = u * h, vv = v * sqrt(1 - h * h);
          ret.emplace_back(Line(l.p + (uu + vv) * l.r, r.p - (uu + vv) * r.r * s));
          ret.emplace_back(Line(l.p + (uu - vv) * l.r, r.p - (uu - vv) * r.r * s));
        }
      }
      return ret;
    }

    Real Area(const Circle &c, const Polygon &P) {
      auto calc = [&](auto &&calc, const Point &a, const Point &b) -> Real {
        auto va = c.p - a, vb = c.p - b;
        Real f = cross(va, vb), ret = 0;
        if(eq(f)) { return ret; }
        if(max(abs(va), abs(vb)) < c.r + EPS) { return f; }
        if(distance(Segment(a, b), c.p) > c.r - EPS) {
          Point t(va.x * vb.x + va.y * vb.y, va.x * vb.y - va.y * vb.x);
          return norm(c.r) * arg(t);
        }
        auto u = crosspoint(c, Segment(a, b));
        if((int)u.size() == 1) { u.emplace_back(u[0]); }
        vector<Point> tot = {a, u[0], u[1], b};
        for(int i = 0; i < 3; i++) { ret += calc(calc, tot[i], tot[i + 1]); }
        return ret;
      };
      const int N = P.size();
      if(N < 3) { return 0; }
      Real A = 0;
      for(int i = 0; i < N; i++) { A += calc(calc, P[i], P[(i + 1) % N]); }
      return A * 0.5;
    }
    """

  'Eratosthenes':
    'prefix':'Eratosthenes'
    'body':"""
    vector<bool> Eratosthenes(int n) {
      vector<bool> prime(n + 1, true);
      if(n >= 0) { prime[0] = false; }
      if(n >= 1) { prime[1] = false; }
      for(int i = 2; i * i <= n; i++) {
        if(!prime[i]) { continue; }
        for(int j = i + i; j <= n; j += i) { prime[j] = false; }
      }
      return prime;
    }
    """

  'Eratosthenes_':
    'prefix':'Eratosthenes_'
    'body':"""
    //  is_p[i].empty() -> i は素数
    // !is_p[i].empty() -> is_p[i] は i の素因数を格納
    // 素数判定の必要なし，素因数だけ欲しいときは j=i*2 を j=i に変更
    // p : n以下の素数列

    pair<vector<vector<ll>>, vector<ll>> Eratosthenes(ll n) {
      vector<vector<ll>> is_p(n + 1);
      vector<ll> p;
      for(ll i = 2; i <= n; i++) {
        if(!is_p[i].empty()) {continue;}
        p.push_back(i);
        for(ll j = i ; j <= n; j += i) {is_p[j].emplace_back(i);}
      }
      return {is_p, p};
    }
    """

  'eratosthenes':
    'prefix':'eratosthenes'
    'body':'Eratosthenes($1);'

  'prime_super':
    'prefix':'Prime_super'
    'body':"""
    bool is_prime(ll x) {
      if(x == 2 || x == 3 || x == 5 || x == 7) { return true; }
      if(x % 2 == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) { return false; }
      if(x < 121) { return x > 1; }
      ll d = (x - 1) >> __builtin_ctzll(x - 1);
      ll p = 1, m = x - 1;
      auto internal_pow = [](ll x, ll n, ll mod) {
        __uint128_t r;
        x %= mod;
        if(n == 0) {
          r = 1;
          return r;
        }
        r = 1;
        __uint128_t c = x;
        for(; n; n >>= 1, c = (c * c) % mod) {
          if(n & 1) { r = r * c % mod; }
        }
        return r;
      };
      auto ok = [&](ll a) {
        auto y = internal_pow(a, d, x);
        ll t = d;
        while(y != p && y != m && t != x - 1) {
          y = y * y % x;
          t <<= 1;
        }
        if(y != m && t % 2 == 0) { return false; }
        return true;
      };
      if(x < (1ll << 32)) {
        for(ll a : {2, 7, 61}) {
          if(!ok(a)) { return false; }
        }
      }
      else {
        for(ll a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {
          if(x <= a) { return true; }
          if(!ok(a)) { return false; }
        }
      }
      return true;
    }
    ll Rho(ll n) {
      if(n % 2 == 0) {return 2;}
      if(is_prime(n)) {return n;}
      auto f = [&](ll x) -> ll { return (__int128_t(x) * x + 1) % n; };
      ll step = 0;
      while(1) {
        ++step;
        ll x = step, y = f(x);
        while(true) {
          ll p = gcd(y - x + n, n);
          if(p == 0 || p == n) {break;}
          if(p != 1) {return p;}
          x = f(x);
          y = f(f(y));
        }
      }
    }
    vector<ll> PrimeFactorize(ll n) {
      if(n == 1) {return {};}
      ll p = Rho(n);
      if(p == n) {return {p};}
      vector<ll> left = PrimeFactorize(p), right = PrimeFactorize(n / p);
      left.insert(left.end(), right.begin(), right.end());
      ranges::sort(left);
      return left;
    }
    """

  'WaveletMatrix':
    'prefix':'WaveletMatrix'
    'body':"""
    struct SuccinctIndexableDictionary {
      ll len;
      ll blk;
      vector<ll> bit, sum;
      SuccinctIndexableDictionary() = default;
      SuccinctIndexableDictionary(ll len): len(len), blk((len + 31) >> 5) {
        bit.assign(blk, 0LL);
        sum.assign(blk, 0LL);
      }
      void set(ll k) { bit[k >> 5] |= 1LL << (k & 31); }
      void build() {
        sum[0] = 0LL;
        for(ll i = 1; i < blk; i++) {sum[i] = sum[i - 1] + __builtin_popcountll(bit[i - 1]);}
      }
      bool operator[](ll k) { return (bool((bit[k >> 5] >> (k & 31)) & 1)); }
      ll rank(ll k) { return (sum[k >> 5] + __builtin_popcountll(bit[k >> 5] & ((1LL << (k & 31)) - 1))); }
      ll rank(bool val, ll k) { return (val ? rank(k) : k - rank(k)); }
    };

    template<typename T, ll MAXLOG> struct WaveletMatrix {
      ll len;
      SuccinctIndexableDictionary mat[MAXLOG];
      ll mid[MAXLOG];
      WaveletMatrix() = default;
      WaveletMatrix(vector<T> v): len(v.size()) {
        vector<T> l(len), r(len);
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {
          mat[lev] = SuccinctIndexableDictionary(len + 1);
          ll left = 0, right = 0;
          for(ll i = 0; i < len; i++) {
            if(((v[i] >> lev) & 1)) {
              mat[lev].set(i);
              r[right++] = v[i];
            }
            else {l[left++] = v[i];}
          }
          mid[lev] = left;
          mat[lev].build();
          v.swap(l);
          for(ll i = 0; i < right; i++) {v[left + i] = r[i];}
        }
      }
      pair<ll, ll> succ(bool f, ll l, ll r, ll lev) { return {mat[lev].rank(f, l) + mid[lev] * f, mat[lev].rank(f, r) + mid[lev] * f}; }
      T access(ll k) {
        T ret = 0;
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {
          bool f = mat[lev][k];
          if(f) {ret |= T(1) << lev;}
          k = mat[lev].rank(f, k) + mid[lev] * f;
        }
        return ret;
      }
      T operator[](const ll &k) { return access(k); }
      ll rank(const T &x, ll r) {
        ll l = 0;
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {tie(l, r) = succ((x >> lev) & 1, l, r, lev);}
        return r - l;
      }
      T kth_smallest(ll l, ll r, ll k) {
        assert(0 <= k && k < r - l);
        T ret = 0;
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {
          ll cnt = mat[lev].rank(false, r) - mat[lev].rank(false, l);
          bool f = cnt <= k;
          if(f) {
            ret |= T(1) << lev;
            k -= cnt;
          }
          tie(l, r) = succ(f, l, r, lev);
        }
        return ret;
      }
      T kth_largest(ll l, ll r, ll k) { return kth_smallest(l, r, r - l - k - 1); }
      ll range_freq(ll l, ll r, T upper) {
        ll ret = 0;
        for(ll lev = MAXLOG - 1; lev >= 0; lev--) {
          bool f = ((upper >> lev) & 1);
          if(f) {ret += mat[lev].rank(false, r) - mat[lev].rank(false, l);}
          tie(l, r) = succ(f, l, r, lev);
        }
        return ret;
      }
      ll range_freq(ll l, ll r, T lower, T upper) { return range_freq(l, r, upper) - range_freq(l, r, lower); }
      T prev_value(ll l, ll r, T upper) {
        ll cnt = range_freq(l, r, upper);
        return cnt == 0 ? T(-1) : kth_smallest(l, r, cnt - 1);
      }
      T next_value(ll l, ll r, T lower) {
        ll cnt = range_freq(l, r, lower);
        return cnt == r - l ? T(-1) : kth_smallest(l, r, cnt);
      }
    };

    template<typename T = ll, ll MAXLOG = 20> struct CompressedWaveletMatrix {
      WaveletMatrix<ll, MAXLOG> mat;
      vector<T> ys;
      CompressedWaveletMatrix(){}
      CompressedWaveletMatrix(const vector<T> &v): ys(v) {
        ranges::sort(ys);
        ys.erase(unique(ys.begin(), ys.end()), ys.end());
        vector<ll> t(v.size());
        for(ll i = 0; i < (ll)v.size(); i++) {t[i] = get(v[i]);}
        mat = WaveletMatrix<ll, MAXLOG>(t);
      }
      inline ll get(const T &x) { return ranges::lower_bound(ys, x) - ys.begin(); }
      T access(ll k) { return ys[mat.access(k)]; }
      T operator[](const ll &k) { return access(k); }
      ll rank(const T &x, ll r) {  // count i s.t. (0<=i<r)&&v[i]==x
        auto pos = get(x);
        if(pos == (ll)ys.size() || ys[pos] != x) {return 0;}
        return mat.rank(pos, r);
      }
      ll count(ll l, ll r, T x) {  // count i s.t. (l<=i<r)&&v[i]==x
        if(l >= r) { return 0; }
        return rank(x, r) - rank(x, l);
      }
      T kth_smallest(ll l, ll r, ll k) { return ys[mat.kth_smallest(l, r, k)]; }  // k-th(0-indexed) smallest number in v[l,r)
      T kth_largest(ll l, ll r, ll k) { return ys[mat.kth_largest(l, r, k)]; }  // k-th(0-indexed) largest number in v[l,r)
      ll range_freq(ll l, ll r, T upper) {  // count i s.t. (l<=i<r)&&(v[i]<upper)
        if(l >= r) { return 0; }
        return mat.range_freq(l, r, get(upper));
      }
      ll range_freq(ll l, ll r, T lower, T upper) {  // count i s.t. (l<=i<r)&&(lower<=v[i]<upper)
        if(l >= r || lower >= upper) { return 0; }
        return mat.range_freq(l, r, get(lower), get(upper));
      }
      T prev_value(ll l, ll r, T upper) {  // max v[i] s.t. (l<=i<r)&&(v[i]<upper)
        auto ret = mat.prev_value(l, r, get(upper));
        return ret == -1 ? T(-1) : ys[ret];
      }
      T next_value(ll l, ll r, T lower) {  // min v[i] s.t. (l<=i<r)&&(lower<=v[i])
        auto ret = mat.next_value(l, r, get(lower));
        return ret == -1 ? T(-1) : ys[ret];
      }
    };
    """

  'waveletmatrix':
    'prefix':'waveletmatrix'
    'body':'CompressedWaveletMatrix<> W($1);'

  'PrioritySum':
    'prefix':'PrioritySum'
    'body':"""
    template<typename T, typename Compare = less<T>, typename RCompare = greater<T>> struct PrioritySum {
     private:
      ll k;
      T sum;
      priority_queue<T, vector<T>, Compare> in, d_in;
      priority_queue<T, vector<T>, RCompare> out, d_out;
      void modify() {
        while(in.size() - d_in.size() < k && !out.empty()) {
          auto p = out.top();
          out.pop();
          if(!d_out.empty() && p == d_out.top()) { d_out.pop(); }
          else {
            sum += p;
            in.emplace(p);
          }
        }
        while(in.size() - d_in.size() > k) {
          auto p = in.top();
          in.pop();
          if(!d_in.empty() && p == d_in.top()) { d_in.pop(); }
          else {
            sum -= p;
            out.emplace(p);
          }
        }
        while(!d_in.empty() && in.top() == d_in.top()) {
          in.pop();
          d_in.pop();
        }
      }

     public:
      PrioritySum(int k): k(k), sum(0) {}
      void insert(T x) {
        in.emplace(x);
        sum += x;
        modify();
      }
      void erase(T x) {
        assert(size());
        if(!in.empty() && in.top() == x) {
          sum -= x;
          in.pop();
        }
        else if(!in.empty() && RCompare()(in.top(), x)) {
          sum -= x;
          d_in.emplace(x);
        }
        else { d_out.emplace(x); }
        modify();
      }
      T query() const { return sum; }
      void set(ll kk) {
        k = kk;
        modify();
      }
      ll get() const { return k; }
      ll size() const { return in.size() + out.size() - d_in.size() - d_out.size(); }
      T operator()() { return query(); }
    };
    """

  'MaxSum':
    'prefix':'MaxSum'
    'body':'PrioritySum<ll, greater<ll>, less<ll>> $1'

  'MinSum':
    'prefix':'MinSum'
    'body':'PrioritySum<ll, less<ll>, greater<ll>> $1'

  'Matrix':
    'prefix':'Matrix'
    'body':"""
    template<typename T> struct Matrix : vector<vector<T>> {
      using vector<vector<T>>::vector;
      using vector<vector<T>>::operator=;
      Matrix() {}
      Matrix(ll n) {
        this->assign(n, vector<T>(n, 0));
        for(ll i = 0; i < n; i++) { (*this)[i][i] = 1; }
      }
      Matrix(ll n, ll m, T x = 0) {
        for(ll i = 0; i < n; i++) { this->push_back(vector<T>(m, x)); }
      }
      Matrix(vector<vector<T>> v) { *this = v; }
      Matrix operator+(const Matrix &m) const { return Matrix(*this) += m; }
      Matrix operator-(const Matrix &m) const { return Matrix(*this) -= m; }
      Matrix operator*(const Matrix &m) const { return Matrix(*this) *= m; }
      Matrix operator*(const T &x) const { return Matrix(*this) *= x; }
      Matrix operator^(ll n) const { return Matrix(*this) ^= n; }
      Matrix operator+=(const Matrix &m) const {
        ll h = this->size(), w = (*this)[0].size();
        assert(h == m.size() && w == m[0].size());
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < w; j++) { *this[i][j] += m[i][j]; }
        }
        return *this;
      }
      Matrix operator-=(const Matrix &m) {
        ll h = this->size(), w = (*this)[0].size();
        assert(h == m.size() && w == m[0].size());
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < w; j++) { *this[i][j] -= m[i][j]; }
        }
        return *this;
      }
      Matrix operator*=(const Matrix &m) {
        ll h = this->size(), w = (*this)[0].size();
        assert(w == (ll)m.size());
        vector<vector<T>> r(h, vector<T>(m[0].size(), T(0)));
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < (ll)m[0].size(); j++) {
            for(ll k = 0; k < w; k++) { r[i][j] += (*this)[i][k] * m[k][j]; }
          }
        }
        this->swap(r);
        return *this;
      }
      Matrix operator*=(const T &x) {
        ll h = this->size(), w = (*this)[0].size();
        for(ll i = 0; i < h; i++) {
          for(ll j = 0; j < w; j++) { *this[i][j] *= x; }
        }
        return *this;
      }
      Matrix operator^=(ll n) {
        ll h = this->size();
        Matrix m(h);
        while(n) {
          if(n & 1) { m *= *this; }
          *this *= *this;
          n >>= 1LL;
        }
        this->swap(m);
        return *this;
      }
    };
    """

  'Matrix_linear':
    'prefix':'Matrix_linear'
    'body':"""
    Matrix<long double> rotate(const long double &theta) {
      Matrix<long double> r = {{cos(theta), -sin(theta)}, {sin(theta), cos(theta)}};
      return r;
    }
    Matrix<ll> rotate_left() {
      Matrix<ll> r = {{0, -1}, {1, 0}};
      return r;
    }
    Matrix<ll> rotate_right() {
      Matrix<ll> r = {{0, 1}, {-1, 0}};
      return r;
    }
    Matrix<ll> flip_x() {
      Matrix<ll> r = {{1, 0}, {0, -1}};
      return r;
    }
    Matrix<ll> flip_y() {
      Matrix<ll> r = {{-1, 0}, {0, 1}};
      return r;
    }
    Matrix<ll> flip_O() {
      Matrix<ll> r = {{-1, 0}, {0, -1}};
      return r;
    }
    Matrix<long double> flip_line(long double &theta) {
      theta *= 2;
      Matrix<long double> r = {{cos(theta), sin(theta)}, {sin(theta), -cos(theta)}};
      return r;
    }
    """

  'Matrix_affine':
    'prefix':'Matrix_affine'
    'body':"""
    template<typename T> Matrix<T> translation(const T &x, const T &y) {
      Matrix<T> r = {{1, 0, x}, {0, 1, y}, {0, 0, 1}};
      return r;
    }
    Matrix<long double> rotate(const long double &theta) {
      Matrix<long double> r = {{cos(theta), -sin(theta), 0}, {sin(theta), cos(theta), 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> rotate_left() {
      Matrix<ll> r = {{0, -1, 0}, {1, 0, 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> rotate_right() {
      Matrix<ll> r = {{0, 1, 0}, {-1, 0, 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> flip_x() {
      Matrix<ll> r = {{1, 0, 0}, {0, -1, 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> flip_y() {
      Matrix<ll> r = {{-1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
      return r;
    }
    Matrix<ll> flip_O() {
      Matrix<ll> r = {{-1, 0, 0}, {0, -1, 0}, {0, 0, 1}};
      return r;
    }
    """

  'matrix':
    'prefix':'matrix'
    'body':'Matrix<${1:mint}> $2;'

  'FormalPowerSeries':
    'prefix':'FPS'
    'body':"""
    #define FAST
    template<ll MOD = 998244353, typename T = mint> struct FPS : vector<T> {
      using vector<T>::vector;
      using vector<T>::operator=;
      FPS pre(int deg) const { return FPS(begin(*this), begin(*this) + min((int)this->size(), deg)); }
      FPS rev(int deg = -1) const {
        FPS r(*this);
        if(deg != -1) { r.resize(deg, T(0)); }
        ranges::reverse(r);
        return r;
      }
      void shrink() {
        while(this->size() && this->back() == T(0)) { this->pop_back(); }
      }
      FPS operator+(const FPS &f) const { return FPS(*this) += f; }
      FPS operator+(const T &x) const { return FPS(*this) += x; }
      FPS operator-(const FPS &f) const { return FPS(*this) -= f; }
      FPS operator-(const T &x) const { return FPS(*this) -= x; }
      FPS operator*(const FPS &f) const { return FPS(*this) *= f; }
      template<typename I> FPS operator*(const vector<pair<I, T>> &f) const { return FPS(*this) *= f; }
      template<typename I> FPS operator*(const pair<I, T> &f) const { return FPS(*this) *= f; }
      FPS operator*(const T &x) const { return FPS(*this) *= x; }
      FPS operator/(const FPS &f) const { return FPS(*this) /= f; }
      template<typename I> FPS operator/(vector<pair<I, T>> &f) const { return FPS(*this) /= f; }
      template<typename I> FPS operator/(const pair<I, T> &f) const { return FPS(*this) /= f; }
      FPS operator/(const T &x) const { return FPS(*this) /= x; }
      FPS operator%(const FPS &f) const { return FPS(*this) %= f; }
      FPS &operator+=(const FPS &f) {
        if(f.size() > this->size()) { this->resize(f.size()); }
        for(int i = 0; i < (int)f.size(); i++) { (*this)[i] += f[i]; }
        return *this;
      }
      FPS &operator-=(const FPS &f) {
        if(f.size() > this->size()) { this->resize(f.size()); }
        for(int i = 0; i < (int)f.size(); i++) { (*this)[i] -= f[i]; }
        return *this;
      }
      FPS &operator*=(const FPS &f) {
    #ifdef FAST
        *this = convolution(*this, f);
    #else
        const int n = this->size(), m = f.size();
        vector<ll> a(n), b(m);
        static constexpr ll MOD1 = 754974721, MOD2 = 167772161, MOD3 = 469762049;
        static constexpr ll M1_M2 = internal::inv_gcd(MOD1, MOD2).second, M12_M3 = internal::inv_gcd(MOD1 * MOD2, MOD3).second, M12 = (MOD1 * MOD2) % MOD;
        for(int i = 0; i < n; i++) { a[i] = (*this)[i].val(); }
        for(int i = 0; i < m; i++) { b[i] = f[i].val(); }
        vector<ll> x = convolution<MOD1>(a, b), y = convolution<MOD2>(a, b), z = convolution<MOD3>(a, b);
        vector<T> c(n + m - 1);
        for(int i = 0; i < n + m - 1; i++) {
          ll v1 = (y[i] - x[i]) * M1_M2 % MOD2;
          if(v1 < 0) { v1 += MOD2; }
          ll v2 = (z[i] - (x[i] + MOD1 * v1) % MOD3) * M12_M3 % MOD3;
          if(v2 < 0) { v2 += MOD3; }
          c[i] = x[i] + MOD1 * v1 + M12 * v2;
        }
        *this = c;
    #endif
        return *this;
      }
      template<typename I> FPS &operator*=(const vector<pair<I, T>> &f) {
        const int n = this->size() - 1, m = f.back().first;
        FPS r(n + m + 1, 0);
        for(int i = 0; i <= n; i++) {
          for(auto &[j, c] : f) { r[i + j] += (*this)[i] * c; }
        }
        return *this = r;
      }
      template<typename I> FPS &operator*=(const pair<I, T> &f) {  // *(cx^d + 1)
        const int n = this->size();
        auto [d, c] = f;
        for(int i = n - d - 1; i >= 0; i--) { (*this)[i + d] += (*this)[i] * c; }
        return *this;
      }
      FPS &operator/=(const FPS &f) {
        if(this->size() < f.size()) {
          this->clear();
          return *this;
        }
        return *this *= f.inv();
      }
      template<typename I> FPS &operator/=(vector<pair<I, T>> &f) {
        ranges::sort(f, [&](auto x, auto y) { return x.first > y.first; });
        const ll n = this->size() - 1, m = f[0].first;
        FPS r(n - m + 1, 0);
        for(int i = n - m; i >= 0; i--) {
          r[i] = (*this)[i + m] / f[0].second;
          for(auto &[j, c] : f) { (*this)[i + j] -= r[i] * c; }
        }
        return *this = r;
      }
      template<typename I> FPS &operator/=(const pair<I, T> &f) {  // /(cx^d + 1)
        const int n = this->size();
        auto [d, c] = f;
        for(int i = 0; i < n - d; i++) { (*this)[i + d] -= (*this)[i] * c; }
        return *this;
      }
      FPS &operator%=(const FPS &f) { return *this -= *this / f * f; }
      pair<FPS, FPS> div_mod(const FPS &f) {
        FPS g = *this / f;
        return {g, *this - g * f};
      }
      FPS operator-() {
        FPS r(this->size());
        for(int i = 0; i < (this->size()); i++) { r[i] = -(*this)[i]; }
        return r;
      }
      FPS &operator+=(const T &x) {
        if(this->empty()) { this->resize(1); }
        (*this)[0] += x;
        return *this;
      }
      FPS &operator-=(const T &x) {
        if(this->empty()) { this->resize(1); }
        (*this)[0] -= x;
        return *this;
      }
      FPS &operator*=(const T &x) {
        for(int i = 0; i < (int)this->size(); i++) { (*this)[i] *= x; }
        return *this;
      }
      FPS &operator/=(const T &x) {
        for(int i = 0; i < (int)this->size(); i++) { (*this)[i] /= x; }
        return *this;
      }
      FPS operator>>(ll sz) {
        if((int)this->size() <= sz) { return {}; }
        FPS r(*this);
        r.erase(r.begin(), r.begin() + sz);
        return r;
      }
      FPS operator<<(ll sz) {
        FPS r(*this);
        r.insert(r.begin(), sz, T(0));
        return r;
      }
      FPS dot(const FPS &f) const {
        FPS r(min(this->size(), f.size()));
        for(int i = 0; i < r.size(); i++) { r[i] = (*this)[i] * f[i]; }
        return r;
      }
      T operator()(T x) const {
        T r = 0, w = 1;
        for(auto &i : (*this)) {
          r += w * i;
          w *= x;
        }
        return r;
      }
      FPS diff() const {
        const int n = this->size();
        FPS r(n);
        for(int i = 1; i < n; i++) { r[i - 1] = (*this)[i] * T(i); }
        r[n - 1] = 0;
        return r;
      }
      FPS integral() const {
        const int n = this->size();
        vector<T> inv(n);
        inv[1] = 1;
        for(int i = 2; i < n; i++) { inv[i] = -inv[MOD % i] * (MOD / i); }
        FPS r(n);
        for(int i = n - 2; i >= 0; i--) { r[i + 1] = (*this)[i] * inv[i + 1]; }
        r[0] = 0;
        return r;
      }
      FPS inv(ll deg = -1) const {
        const int n = this->size();
        if(deg == -1) { deg = n; }
        assert(n && (*this)[0] != T(0));
        FPS res{(*this)[0].inv()};
    #ifdef FAST
        while((int)res.size() < deg) {
          int d = res.size();
          FPS f(this->begin(), this->begin() + min(n, d * 2)), g(res);
          f.resize(d * 2);
          g.resize(d * 2);
          internal::butterfly(f);
          internal::butterfly(g);
          for(int i = 0; i < d * 2; i++) { f[i] *= g[i]; }
          internal::butterfly_inv(f);
          f.erase(f.begin(), f.begin() + d);
          f.resize(d * 2);
          internal::butterfly(f);
          for(int i = 0; i < d * 2; i++) { f[i] *= g[i]; }
          internal::butterfly_inv(f);
          T iz = T(d * 2).inv();
          iz *= -iz;
          for(int i = 0; i < d; i++) { f[i] *= iz; }
          res.insert(res.end(), f.begin(), f.begin() + d);
        }
    #else
        for(int i = 1; i < deg; i <<= 1) { res = (res + res - res * res * pre(i << 1)).pre(i << 1); }
    #endif
        return res.pre(deg);
      }
      FPS log(ll deg = -1) const {
        assert((*this)[0] == T(1));
        if(deg == -1) { deg = this->size(); }
        return (this->diff() * this->inv(deg)).pre(deg).integral();
      }
      FPS sqrt(ll deg = -1) {
        const int n = this->size();
        if(deg == -1) { deg = n; }
        if((*this)[0] == T(0)) {
          for(int i = 1; i < n; i++) {
            if((*this)[i] != T(0)) {
              if(i & 1) { return {}; }
              if(deg - i / 2 <= 0) { break; }
              auto r = (*this >> i).sqrt(deg - i / 2);
              if(r.empty()) { return {}; }
              r = r << (i / 2);
              if((int)r.size() < deg) { r.resize(deg, T(0)); }
              return r;
            }
          }
          return FPS(deg, 0);
        }
        auto mod_sqrt = [&](const ll &a) -> ll {
          ll m = MOD - 1, e = 0;
          if(!a) { return 0; }
          if(MOD == 2) { return a; }
          if(mint(a).pow(m >> 1) != 1) { return -1; }
          mint b = 1;
          while(b.pow(m >> 1) == 1) { b++; }
          while(~m & 1) {
            m >>= 1;
            e++;
          }
          mint x = mint(a).pow((m - 1) >> 1), y = mint(a) * x * x, z = mint(b).pow(m);
          x *= a;
          while(y != 1) {
            ll j = 0;
            mint t = y;
            while(t != 1) {
              j++;
              t *= t;
            }
            z = z.pow(1LL << (e - j - 1));
            x *= z;
            z *= z;
            y *= z;
            e = j;
          }
          return x.val();
        };
        auto sq = T(mod_sqrt((*this)[0].val()));
        if(sq * sq != (*this)[0]) { return {}; }
        FPS r{sq};
        T inv2 = T(1) / T(2);
        for(int i = 1; i < deg; i <<= 1) { r = (r + pre(i << 1) * r.inv(i << 1)) * inv2; }
        return r.pre(deg);
      }
      FPS sqrt(const function<T(T)> &get_sqrt, ll deg = -1) { return sqrt(deg, get_sqrt); }
      FPS exp(ll deg = -1) const {
        const int n = this->size();
        assert((*this)[0] == T(0));
        if(deg == -1) { deg = n; }
    #ifdef FAST
        FPS inv;
        inv.reserve(deg);
        inv.emplace_back(T(0));
        inv.emplace_back(T(1));
        auto internal_integral = [&](FPS &f) {
          const int n = f.size();
          while((int)inv.size() <= n) {
            int i = inv.size();
            inv.emplace_back((-inv[MOD % i]) * (MOD / i));
          }
          f.insert(f.begin(), T(0));
          for(int i = 1; i <= n; i++) { f[i] *= inv[i]; }
        };
        auto internal_diff = [](FPS &f) {
          if(f.empty()) { return; }
          f.erase(f.begin());
          T c = 1;
          for(int i = 0; i < (int)f.size(); i++, c++) { f[i] *= c; }
        };
        FPS b{1, 1 < (int)this->size() ? (*this)[1] : 0}, c{1}, z1, z2{1, 1};
        for(int m = 2; m <= deg; m <<= 1) {
          auto y = b;
          y.resize(m * 2);
          internal::butterfly(y);
          z1 = z2;
          FPS z(m);
          for(int i = 0; i < m; i++) { z[i] = y[i] * z1[i]; }
          internal::butterfly_inv(z);
          T si = T(m).inv();
          for(int i = 0; i < m; i++) { z[i] *= si; }
          fill(z.begin(), z.begin() + m / 2, T(0));
          internal::butterfly(z);
          for(int i = 0; i < m; i++) { z[i] *= -z1[i]; }
          internal::butterfly_inv(z);
          for(int i = 0; i < m; i++) { z[i] *= si; }
          c.insert(c.end(), z.begin() + m / 2, z.end());
          z2 = c;
          z2.resize(m * 2);
          internal::butterfly(z2);
          FPS x(this->begin(), this->begin() + min((int)this->size(), m));
          x.resize(m);
          internal_diff(x);
          x.emplace_back(T(0));
          internal::butterfly(x);
          for(int i = 0; i < m; i++) { x[i] *= y[i]; }
          internal::butterfly_inv(x);
          for(int i = 0; i < m; i++) { x[i] *= si; }
          x -= b.diff();
          x.resize(m * 2);
          for(int i = 0; i < m - 1; i++) {
            x[m + i] = x[i];
            x[i] = T(0);
          }
          internal::butterfly(x);
          for(int i = 0; i < m * 2; i++) { x[i] *= z2[i]; }
          internal::butterfly_inv(x);
          T si2 = T(m << 1).inv();
          for(int i = 0; i < m * 2; i++) { x[i] *= si2; }
          x.pop_back();
          internal_integral(x);
          for(int i = m; i < min((int)this->size(), m * 2); i++) { x[i] += (*this)[i]; }
          fill(x.begin(), x.begin() + m, T(0));
          internal::butterfly(x);
          for(int i = 0; i < m * 2; i++) { x[i] *= y[i]; }
          internal::butterfly_inv(x);
          for(int i = 0; i < m * 2; i++) { x[i] *= si2; }
          b.insert(b.end(), x.begin() + m, x.end());
        }
        return b.pre(deg);
    #else
        FPS r({T(1)});
        for(int i = 1; i < deg; i <<= 1) { r = (r * (pre(i << 1) + T(1) - r.log(i << 1))).pre(i << 1); }
        return r.pre(deg);
    #endif
      }
      FPS pow(ll k) {
        const int n = this->size();
        assert(k >= 0);
        if(k == 0) {
          FPS r(n, T(0));
          r[0] = T(1);
          return r;
        }
        for(int i = 0; i < n; i++) {
          if(i * k > n) { return FPS(n, T(0)); }
          if((*this)[i] != T(0)) {
            T rev = (*this)[i].inv();
            FPS r = (((*this * rev) >> i).log() * k).exp() * ((*this)[i].pow(k));
            r = (r << (i * k)).pre(n);
            if((int)r.size() < n) { r.resize(n, T(0)); }
            return r;
          }
        }
        return *this;
      }
      FPS mod_pow(ll k, FPS f) const {
        FPS modinv = f.rev().inv();
        auto get_div = [&](FPS base) {
          if(base.size() < f.size()) {
            base.clear();
            return base;
          }
          ll n = base.size() - f.size() + 1;
          return (base.rev().pre(n) * modinv.pre(n)).pre(n).rev(n);
        };
        FPS x(*this), r{1};
        while(k > 0) {
          if(k & 1) {
            r *= x;
            r -= get_div(r) * f;
            r.shrink();
          }
          x *= x;
          x -= get_div(x) * f;
          x.shrink();
          k >>= 1;
        }
        return r;
      }
      FPS taylor_shift(T c) const {  // g(x) s.t. g(x)=f(x+c)
        const int n = this->size();
        vector<T> fact(n), rfact(n);
        fact[0] = rfact[0] = T(1);
        for(int i = 1; i < n; i++) { fact[i] = fact[i - 1] * T(i); }
        rfact[n - 1] = T(1) / fact[n - 1];
        for(int i = n - 1; i >= 2; i--) { rfact[i - 1] = rfact[i] * T(i); }
        FPS r(*this);
        for(int i = 0; i < n; i++) { r[i] *= fact[i]; }
        r = r.rev();
        FPS bs(n, T(1));
        for(int i = 1; i < n; i++) { bs[i] = bs[i - 1] * c * rfact[i] * fact[i - 1]; }
        r = (r * bs).pre(n);
        r = r.rev();
        for(int i = 0; i < n; i++) { r[i] *= rfact[i]; }
        return r;
      }
    };
    """

  'PrimeCount':
    'prefix':'PrimeCount'
    'body':"""
    uint64_t Root(uint64_t a, int k = 2) {
      if(a <= 1 || k == 1) { return a; }
      if(k >= 64) { return 1; }
      auto check = [&](__uint128_t n) {
        __uint128_t x = 1, m = n;
        for(ll p = k; p; p >>= 1, m *= m) {
          if(p & 1) { x *= m; }
        }
        return x <= a;
      };
      uint64_t n = powl(a, (long double)(1.0) / k);
      while(!check(n)) { --n; }
      while(check(n + 1)) { ++n; }
      return n;
    }

    vector<bool> Eratosthenes(int n) {
      vector<bool> prime(n + 1, true);
      if(n >= 0) { prime[0] = false; }
      if(n >= 1) { prime[1] = false; }
      for(int i = 2; i * i <= n; i++) {
        if(!prime[i]) { continue; }
        for(int j = i + i; j <= n; j += i) { prime[j] = false; }
      }
      return prime;
    }

    struct PrimeCount {
     private:
      ll p2(ll x, ll y) {
        if(x < 4) { return 0; }
        ll a = cnt(y), b = cnt(Root(x));
        if(a >= b) { return 0; }
        ll sum = (a - 2) * (a + 1) / 2 - (b - 2) * (b + 1) / 2;
        for(ll i = a; i < b; i++) { sum += cnt(x / primes[i]); }
        return sum;
      }
      ll phi(ll m, ll n) {
        if(m < 1) { return 0; }
        if(n > m) { return 1; }
        if(n < 1) { return m; }
        if(m <= primes[n - 1] * primes[n - 1]) { return cnt(m) - n + 1; }
        if(m <= primes[n - 1] * primes[n - 1] * primes[n - 1] && m <= sq) {
          ll sx = cnt(Root(m)), ans = cnt(m) - (sx + n - 2) * (sx - n + 1) / 2;
          for(ll i = n; i < sx; i++) { ans += cnt(m / primes[i]); }
          return ans;
        }
        return phi(m, n - 1) - phi(m / primes[n - 1], n - 1);
      }

     public:
      ll sq;
      vector<bool> prime;
      vector<ll> prime_sum, primes;
      PrimeCount(ll n): sq(Root(n)), prime_sum(sq + 1) {
        prime = Eratosthenes(sq);
        for(int i = 1; i <= sq; i++) { prime_sum[i] = prime_sum[i - 1] + prime[i]; }
        primes.reserve(prime_sum[sq]);
        for(int i = 1; i <= sq; i++) {
          if(prime[i]) { primes.emplace_back(i); }
        }
      }
      ll cnt(ll n) {
        if(n <= sq) { return prime_sum[n]; }
        ll m = Root(n, 3), a = cnt(m);
        return phi(n, a) + a - 1 - p2(n, m);
      }
      inline ll operator()(ll n) { return cnt(n); }
    } P(1e11);
    """

  'primecount':
    'prefix':'primecount'
    'body':'PrimeCount($1);'

  'mysort':
    'prefix':'mysort'
    'body':"""
    ranges::sort($1,[&](auto x,auto y){return $2;});$3 // condition to put x front
    """

  'sortidx':
    'prefix':'sortidx'
    'body':"""
    vector<ll> idx(N);
    iota(idx.begin(), idx.end(), 0);
    ranges::sort(idx, [&](auto i, auto j) { return $1[i] < $1[j]; });
    """

  'scc':
    'prefix':'scc'
    'body':'scc_graph g(N);'

  'suffix_array':
    'prefix':'suffix_array'
    'body':'suffix_array($1)'

  'lcp_array':
    'prefix':'lcp_array'
    'body':'lcp_array($1,sa)'

  'z_algorithm':
    'prefix':'z_algorithm'
    'body':'z_algorithm($1)'

  'fenwick_tree':
    'prefix':'fenwick_tree'
    'body':"""
    fenwick_tree<ll> $1(N);
    // f.add(i,x) f[i]+=x;
    // f.sum(l,r) sum[l,r)
    """

  'ShortestRepetition_str':
    'prefix':'ShortestRepetition_str'
    'body':"""
    int ShortestRepetition(const string &s) {
      vector<int> z = z_algorithm(s);
      int sz = s.size();
      for(int i = 1; i < sz; i++) {
        if(z[i] == sz - i && sz % i == 0) { return i; }
      }
      return sz;
    }
    """

  'ShortestRepetition_vec':
    'prefix':'ShortestRepetition_vec'
    'body':"""
    template<typename T> int ShortestRepetition(const vector<T> &v) {
      vector<int> z = z_algorithm(v);
      int sz = v.size();
      for(int i = 1; i < sz; i++) {
        if(z[i] == sz - i && sz % i == 0) { return i; }
      }
      return sz;
    }
    """

  'testcase':
    'prefix':'testcase'
    'body':"""
    ll ${1:q}; cin>>${1:q};
    while(${1:q}--){
      $2
    }
    """

  'iota':
    'prefix':'iota'
    'body':'iota(${1:v}.begin(),${1:v}.end(),0);$2'

  'fixed':
    'prefix':'fixed'
    'body':'cout << fixed << setprecision(12);'

  'MaxFlow':
    'prefix':'maxflow'
    'body':'mf_graph<ll> g(N); ${1://https://atcoder.github.io/ac-library/document_ja/maxflow.html}'

  'add_edge':
    'prefix':'add_edge'
    'body':'add_edge($1);$2'

  'BipartiteMatching':
    'prefix':'BipartiteMatching'
    'body':"""
    int BipartiteMatching(vector<vector<ll>> &g) {
      const int N = g.size();
      vector<int> color(N, -1);
      auto DFS = [&](auto DFS, int v, int c) -> bool {
        color[v] = c;
        for(auto &nv : g[v]) {
          if(color[nv] != -1) {
            if(color[nv] == c) { return false; }
            continue;
          }
          if(!DFS(DFS, nv, 1 - c)) { return false; }
        }
        return true;
      };
      for(int i = 0; i < N; i++) {
        if(color[i] == -1) {
          if(!DFS(DFS, i, 0)) { return -1; }
        }
      }
      mf_graph<ll> f(N + 2);
      for(int i = 0; i < N; i++) {
        !color[i] ? f.add_edge(N, i, 1) : f.add_edge(i, N + 1, 1);
        for(auto &j : g[i]) {
          if(i >= j) { continue; }
          !color[i] ? f.add_edge(i, j, 1) : f.add_edge(j, i, 1);
        }
      }
      return f.flow(N, N + 1);
    }
    """

  'bipartitematching':
    'prefix':'bipartitematching'
    'body':'BipartiteMatching(g);'

  'Rational':
    'prefix':'Rational'
    'body':"""
    template<typename T> struct Rational {
      T num, den;
      Rational() {}
      Rational(T num_): num(num_), den(1) {}
      Rational(T num_, T den_): num(num_), den(den_) {
        if(den < 0) num = -num, den = -den;
      }
      static Rational make(const T& x, const T& y) {
        Rational m;
        return m.num = x, m.den = y, m;
      }
      friend ostream& operator<<(ostream& os, const Rational& r) {
        return (os << r.num << " / " << r.den);
      }
      Rational& operator=(T val) { return *this = Rational(val); }
      bool operator<(const Rational& val) const { return num * val.den < den * val.num; }
      bool operator<(const T val) const { return *this < Rational(val); }
      friend bool operator<(const T val1, const Rational& val2) { return Rational(val1) < val2; }
      bool operator>(const Rational& val) const { return val < *this; }
      bool operator>(const T val) const { return *this > Rational(val); }
      friend bool operator>(const T val1, const Rational& val2) { return Rational(val1) > val2; }
      bool operator<=(const Rational& val) const { return !(*this > val); }
      bool operator<=(const T val) const { return *this <= Rational(val); }
      friend bool operator<=(const T val1, const Rational& val2) { return Rational(val1) <= val2; }
      bool operator>=(const Rational& val) const { return !(*this < val); }
      bool operator>=(const T val) const { return *this >= Rational(val); }
      friend bool operator>=(const T val1, const Rational& val2) { return Rational(val1) >= val2; }
      bool operator==(const Rational& val) const { return num * val.den == den * val.num; }
      bool operator==(const T val) const { return *this == Rational(val); }
      friend bool operator==(const T val1, const Rational& val2) { return Rational(val1) == val2; }
      bool operator!=(const Rational& val) const { return !(*this == val); }
      bool operator!=(const T val) const { return *this != Rational(val); }
      friend bool operator!=(const T val1, const Rational& val2) { return Rational(val1) != val2; }
      explicit operator bool() const noexcept { return num; }
      bool operator!() const noexcept { return !static_cast<bool>(*this); }
      Rational operator+() const { return *this; }
      Rational operator-() const { return make(-num, den); }
      friend Rational abs(const Rational& val) { return make(abs(val.num), val.den); }
      Rational operator+(const Rational& val) const { return make(num * val.den + val.num * den, den * val.den); }
      Rational operator+(T val) const { return *this + Rational(val); }
      friend Rational operator+(T a, const Rational& b) { return b + a; }
      Rational& operator+=(const Rational& val) { return *this = *this + val; }
      Rational& operator+=(const T& val) { return *this = *this + val; }
      Rational& operator++() { return *this += 1; }
      Rational operator++(int) { return make(num + den, den); }
      Rational operator-(const Rational& val) const { return make(num * val.den - val.num * den, den * val.den); }
      Rational operator-(T val) const { return *this - Rational(val); }
      friend Rational operator-(T a, const Rational& b) { return Rational(a) - b; }
      Rational& operator-=(const Rational& val) { return *this = *this - val; }
      Rational& operator-=(const T& val) { return *this = *this - val; }
      Rational& operator--() { return *this -= 1; }
      Rational operator--(int) { return make(num - den, den); }
      Rational operator*(const Rational& val) const { return make(num * val.num, den * val.den); }
      Rational operator*(T val) const { return *this * Rational(val); }
      friend Rational operator*(T a, const Rational& b) { return b * a; }
      Rational& operator*=(const Rational& val) { return *this = *this * val; }
      Rational& operator*=(const T& val) { return *this = *this * val; }
      Rational operator/(const Rational& val) const { return make(num * val.den, den * val.num); }
      Rational operator/(T val) const { return *this / Rational(val); }
      friend Rational operator/(T a, const Rational& b) { return Rational(a) / b; }
      Rational& operator/=(const Rational& val) { return *this / val; }
      Rational& operator/=(const T& val) { return *this = *this / val; }
    };
    """

  'ConvexHullTrick':
    'prefix':'ConvexHullTrick'
    'body':"""
    template<typename T, bool isMin> struct ConvexHullTrick {
     private:
      deque<pair<T, T>> H;
      inline int sgn(T x) { return x == 0 ? 0 : (x < 0 ? -1 : 1); }
      inline bool check(const pair<T, T> &a, const pair<T, T> &b, const pair<T, T> &c) {
        if(b.second == a.second || c.second == b.second) { return sgn(b.first - a.first) * sgn(c.second - b.second) >= sgn(c.first - b.first) * sgn(b.second - a.second); }
        if(is_integral<T>::value) { return (b.second - a.second) / (a.first - b.first) >= (c.second - b.second) / (b.first - c.first); }
        else { return (b.first - a.first) * sgn(c.second - b.second) / abs(b.second - a.second) >= (c.first - b.first) * sgn(b.second - a.second) / abs(c.second - b.second); }
      }
      inline T get_y(const pair<T, T> &a, const T &x) { return a.first * x + a.second; }

     public:
      ConvexHullTrick() = default;
      bool empty() const { return H.empty(); }
      void clear() { H.clear(); }
      void add(T a, T b) {  // a は広義単調増加または広義単調減少, O(n) in total
        if(!isMin) { a *= -1, b *= -1; }
        pair<T, T> line(a, b);
        if(empty()) {
          H.emplace_front(line);
          return;
        }
        if(H.front().first <= a) {
          if(H.front().first == a) {
            if(H.front().second <= b) { return; }
            H.pop_front();
          }
          while(H.size() >= 2 && check(line, H.front(), H[1])) { H.pop_front(); }
          H.emplace_front(line);
        }
        else {
          assert(a <= H.back().first);
          if(H.back().first == a) {
            if(H.back().second <= b) { return; }
            H.pop_back();
          }
          while(H.size() >= 2 && check(H[H.size() - 2], H.back(), line)) { H.pop_back(); }
          H.emplace_back(line);
        }
      }
      T query(T x) {  // O(log n)
        assert(!empty());
        int l = -1, r = H.size() - 1;
        while(l + 1 < r) {
          int m = (l + r) >> 1;
          get_y(H[m], x) >= get_y(H[m + 1], x) ? l = m : r = m;
        }
        return isMin ? get_y(H[r], x) : -get_y(H[r], x);
      }
      T query_inc(T x) {  // query の x が広義単調増加の場合，全体で O(n+q)
        assert(!empty());
        while(H.size() >= 2 && get_y(H.front(), x) >= get_y(H[1], x)) { H.pop_front(); }
        return isMin ? get_y(H.front(), x) : -get_y(H.front(), x);
      }
      T query_dec(T x) {  // query の x が広義単調減少の場合，全体で O(n+q)
        assert(!empty());
        while(H.size() >= 2 && get_y(H.back(), x) >= get_y(H[H.size() - 2], x)) { H.pop_back(); }
        return isMin ? get_y(H.back(), x) : -get_y(H.back(), x);
      }
    };
    """

  'ConvexHullTrick_min':
    'prefix':'ConvexHullTrick_min'
    'body':'ConvexHullTrick<ll,true> c;'

  'ConvexHullTrick_max':
    'prefix':'ConvexHullTrick_max'
    'body':'ConvexHullTrick<ll,false> c;'

  'Partition':
    'prefix':'Partition'
    'body':"""
    vector<vector<ll>> Partition(int n, int Maxlen = -1, int Maxval = -1) {
      vector<vector<ll>> r;
      auto DFS = [&](auto &&DFS, vector<ll> &v, int sum) -> void {
        if(sum == n) {
          r.emplace_back(v);
          return;
        }
        if(Maxlen != -1 && ssize(v) == Maxlen) { return; }
        int nx = (ssize(v) ? v.back() : n);
        if(Maxval != -1) { nx = min(nx, Maxval); }
        nx = min(nx, n - sum);
        v.emplace_back(0);
        for(ll i = nx; i >= 1; i--) {
          v.back() = i;
          DFS(DFS, v, sum + i);
        }
        v.pop_back();
      };
      vector<ll> v;
      DFS(DFS, v, 0);
      return r;
    }
    """

  'partition':
    'prefix':'partition'
    'body':'Partition'

  'teleporter':
    'prefix':'teleporter'
    'body':"""
    struct Namori {
      ll path_len;
      vector<ll> path, loop;
      Namori(const vector<ll> &g, ll s = 0) {
        vector<ll> vis(g.size(), -1);
        for(ll i = 0, p = s;; i++, p = g[p]) {
          if(vis[p] != -1) {
            path_len = vis[p];
            break;
          }
          loop.emplace_back(p);
          vis[p] = i;
        }
        for(ll i = 0; i < path_len; i++) { path.emplace_back(loop[i]); }
        loop.erase(loop.begin(), loop.begin() + path_len);
      }
      inline ll operator()(ll k) const { return k < path_len ? path[k] : loop[(k - path_len) % loop.size()]; }
    };
    """

  'LiChaoTree':
    'prefix':'LiChaoTree'
    'body':"""
    template<typename T, T x_low, T x_high, T id> struct DynamicLiChaoTree {
     private:
      struct Line {
        T a, b;
        Line(T a, T b): a(a), b(b) {}
        inline T get(T x) const { return a * x + b; }
      };
      struct Node {
        Line x;
        Node *l, *r;
        Node(const Line &x): x{x}, l{nullptr}, r{nullptr} {}
      };
      Node *root;
      Node *add_line(Node *t, Line &x, const T &l, const T &r, const T &x_l, const T &x_r) {
        if(!t) return new Node(x);
        T t_l = t->x.get(l), t_r = t->x.get(r);
        if(t_l <= x_l && t_r <= x_r) { return t; }
        else if(t_l >= x_l && t_r >= x_r) {
          t->x = x;
          return t;
        }
        else {
          T m = (l + r) / 2;
          if(m == r) { --m; }
          T t_m = t->x.get(m), x_m = x.get(m);
          if(t_m > x_m) {
            swap(t->x, x);
            if(x_l >= t_l) { t->l = add_line(t->l, x, l, m, t_l, t_m); }
            else { t->r = add_line(t->r, x, m + 1, r, t_m + x.a, t_r); }
          }
          else {
            if(t_l >= x_l) { t->l = add_line(t->l, x, l, m, x_l, x_m); }
            else { t->r = add_line(t->r, x, m + 1, r, x_m + x.a, x_r); }
          }
          return t;
        }
      }
      Node *add_segment(Node *t, Line &x, const T &a, const T &b, const T &l, const T &r, const T &x_l, const T &x_r) {
        if(r < a || b < l) { return t; }
        if(a <= l && r <= b) {
          Line y{x};
          return add_line(t, y, l, r, x_l, x_r);
        }
        if(t) {
          T t_l = t->x.get(l), t_r = t->x.get(r);
          if(t_l <= x_l && t_r <= x_r) { return t; }
        }
        else { t = new Node(Line(0, id)); }
        T m = (l + r) / 2;
        if(m == r) { --m; }
        T x_m = x.get(m);
        t->l = add_segment(t->l, x, a, b, l, m, x_l, x_m);
        t->r = add_segment(t->r, x, a, b, m + 1, r, x_m + x.a, x_r);
        return t;
      }
      T query(const Node *t, const T &l, const T &r, const T &x) const {
        if(!t) { return id; }
        if(l == r) { return t->x.get(x); }
        T m = (l + r) / 2;
        if(m == r) { --m; }
        if(x <= m) { return min(t->x.get(x), query(t->l, l, m, x)); }
        else { return min(t->x.get(x), query(t->r, m + 1, r, x)); }
      }

     public:
      DynamicLiChaoTree(): root{nullptr} {}
      void add_line(const T &a, const T &b) {
        Line x(a, b);
        root = add_line(root, x, x_low, x_high, x.get(x_low), x.get(x_high));
      }
      void add_segment(const T &l, const T &r, const T &a, const T &b) {
        Line x(a, b);
        root = add_segment(root, x, l, r - 1, x_low, x_high, x.get(x_low), x.get(x_high));
      }
      T query(const T &x) const { return query(root, x_low, x_high, x); }
    };
    // https://ei1333.github.io/library/structure/convex-hull-trick/dynamic-li-chao-tree.hpp
    """

  'modpow':
    'prefix':'modpow'
    'body':"""
    mint modpow(mint x, auto n) {
      mint r = 1;
      while(n) {
        if(n & 1) {r = r * x;}
        x = x * x;
        n >>= 1;
      }
      return r;
    }
    """

  'Rerooting':
    'prefix':'Rerooting'
    'body':"""
    template<typename Cost> struct Edge {
      int src, to;
      Cost cost;
      Edge(int s, int t, Cost c = 1): src(s), to(t), cost(c) {}
      operator int() const { return to; }
    };

    template<typename Cost> struct Graph : vector<vector<Edge<Cost>>> {
      Graph(int n): vector<vector<Edge<Cost>>>(n) {}
      void add_edge(int s, int t, Cost c = 1) { (*this)[s].emplace_back(s, t, c); }
    };

    template<typename Cost, typename Data, Data (*merge)(Data, Data), Data (*e)(), Data (*apply)(Data, int, int, Cost)>
    struct Rerooting : Graph<Cost> {
      vector<Data> dp, memo;
      Rerooting(int n): Graph<Cost>::Graph(n) {}
      vector<Data> build() {
        memo.resize(this->size(), e());
        dp.resize(this->size());
        dfs1(0, -1);
        dfs2(0, -1, e());
        return dp;
      }
      void dfs1(int c, int p) {
        bool upd = false;
        for(Edge<Cost> &d : (*this)[c]) {
          if(d == p) {continue;}
          dfs1(d, c);
          upd = true;
          memo[c] = merge(memo[c], apply(memo[d], d, c, d.cost));
        }
        if(!upd) { memo[c] = e(); }
      }
      void dfs2(int c, int p, const Data &val) {
        vector<Data> ds{val};
        for(Edge<Cost> &d : (*this)[c]) {
          if(d == p) { continue; }
          ds.push_back(apply(memo[d], d, c, d.cost));
        }
        int n = ds.size(), idx = 1;
        vector<Data> head(n + 1, e()), tail(n + 1, e());
        for(int i = 0; i++ < n;) { head[i] = merge(head[i - 1], ds[i - 1]); }
        for(int i = n; i-- > 0;) { tail[i] = merge(tail[i + 1], ds[i]); }
        dp[c] = head[n];
        for(Edge<Cost> &d : (*this)[c]) {
          if(d == p) { continue; }
          Data sub = merge(head[idx], tail[idx + 1]);
          dfs2(d, c, apply(sub, c, d, d.cost));
          idx++;
        }
      }
    };

    using Cost = ll;
    using Data = ll;
    Data merge(Data a, Data b) { return ; }
    Data e() { return ; }
    Data apply(Data a, int c, int, Cost w) { return ; }
    """

  'rerooting':
    'prefix':'rerooting'
    'body':'Rerooting<Cost, Data, merge, e, apply> g(N);'

  'lim_grid':
    'prefix':'lim_grid'
    'body':'if(${1:nx}<0||${1:nx}>=H||${2:ny}<0||${2:ny}>=W) {continue;}'

  'Maximum_rectangle_LR':
    'prefix':'Maximum_rectangle_LR'
    'body':"""
    pair<vector<ll>, vector<ll>> LR(vector<ll> &h) {
      ll n = h.size();
      vector<ll> l(n, 0), r(n, n - 1);
      stack<pair<ll, ll>> sl, sr;
      for(ll i = 0; i < n; i++) {
        while(!sl.empty() && h[i] <= sl.top().first) {sl.pop();}
        if(!sl.empty()) {l[i] = sl.top().second + 1;}
        sl.emplace(h[i], i);
      }
      for(ll i = n - 1; i >= 0; i--) {
        while(!sr.empty() && h[i] <= sr.top().first) {sr.pop();}
        if(!sr.empty()) {r[i] = sr.top().second - 1;}
        sr.emplace(h[i], i);
      }
      return {l, r};
    }
    // min l[i], max r[i] s.t. [l[i],r[i]]<=H[i], 0-indexed
    """

  'floor':
    'prefix':'floor'
    'body':"""
    auto floor(auto a, auto b) {
      assert(b != 0);
      if(b < 0) { a = -a, b = -b; }
      return a / b - (a % b < 0);
    }
    """

  'under':
    'prefix':'under'
    'body':"""
    auto under(auto a, auto b) {
      assert(b != 0);
      if(b < 0) { a = -a, b = -b; }
      return a / b - (a % b <= 0);
    }
    """

  'ceil':
    'prefix':'ceil'
    'body':"""
    auto ceil(auto a, auto b) {
      assert(b != 0);
      if(b < 0) { a = -a, b = -b; }
      return a / b + (a % b > 0);
    }
    """

  'over':
    'prefix':'over'
    'body':"""
    auto over(auto a, auto b) {
      assert(b != 0);
      if(b < 0) { a = -a, b = -b; }
      return a / b + (a % b >= 0);
    }
    """

  'RelaxedConvolution':
    'prefix':'RelaxedConvolution'
    'body':"""
    struct RelaxedConvolution {
      vector<mint> a, b, c;
      ll k;
      RelaxedConvolution(ll n): a(n), b(n), c(n), k(0) {}
      mint operator()(mint na, mint nb) {
        a[k] = na;
        b[k] = nb;
        ll s = k + 2;
        for(ll w = 1; s % w == 0 && w < s; w <<= 1) {
          for(ll r = 0; r < 2; r++) {
            if(r == 0 || w * 2 != s) {
              vector<mint> f(w), g(w);
              for(ll i = 0; i < w; i++) {f[i] = a[w - 1 + i], g[i] = b[k - w + 1 + i];}
              f = convolution(f, g);
              for(ll i = 0, j = k; i < (ll)f.size() && j < (ll)c.size(); i++, j++) {c[j] += f[i];}
            }
            swap(a, b);
          }
        }
        return c[k++];
      }
    };
    """

  'BinaryTrie':
    'prefix':'BinaryTrie'
    'body':"""
    template<int MAX_LOG = 32, typename T = int> struct BinaryTrie {
     private:
      struct node {
        int cnt;
        T lazy;
        node *ch[2];
        node(): cnt(0), lazy(0), ch{nullptr, nullptr} {}
      };
      void push(node *t, int b) {
        if((t->lazy >> (T)b) & (T)1) { swap(t->ch[0], t->ch[1]); }
        if(t->ch[0]) { t->ch[0]->lazy ^= t->lazy; }
        if(t->ch[1]) { t->ch[1]->lazy ^= t->lazy; }
        t->lazy = 0;
      }
      node *add(node *t, T val, int b = MAX_LOG - 1) {
        if(!t) { t = new node; }
        t->cnt += 1;
        if(b < 0) { return t; }
        push(t, b);
        bool f = (val >> (T)b) & (T)1;
        t->ch[f] = add(t->ch[f], val, b - 1);
        return t;
      }
      node *sub(node *t, T val, int b = MAX_LOG - 1) {
        assert(t);
        t->cnt -= 1;
        if(t->cnt == 0) { return nullptr; }
        if(b < 0) { return t; }
        push(t, b);
        bool f = (val >> (T)b) & (T)1;
        t->ch[f] = sub(t->ch[f], val, b - 1);
        return t;
      }
      T get_min(node *t, T val, int b = MAX_LOG - 1) {
        assert(t);
        if(b < 0) { return 0; }
        push(t, b);
        bool f = (val >> (T)b) & (T)1;
        f ^= !t->ch[f];
        return get_min(t->ch[f], val, b - 1) | ((T)f << (T)b);
      }
      T get(node *t, int k, int b = MAX_LOG - 1) {
        if(b < 0) { return 0; }
        push(t, b);
        int m = t->ch[0] ? t->ch[0]->cnt : 0;
        return k < m ? get(t->ch[0], k, b - 1) : get(t->ch[1], k - m, b - 1) | ((T)1 << (T)b);
      }
      int count_lower(node *t, T val, int b = MAX_LOG - 1) {
        if(!t || b < 0) { return 0; }
        push(t, b);
        bool f = (val >> (T)b) & (T)1;
        return (f && t->ch[0] ? t->ch[0]->cnt : 0) + count_lower(t->ch[f], val, b - 1);
      }
      node *root;

     public:
      BinaryTrie(): root(nullptr) {}
      int size() const { return root ? root->cnt : 0; }
      bool empty() const { return !root; }
      void insert(T val) { root = add(root, val); }
      void erase(T val) {
        if(!count(val)) { return; }
        root = sub(root, val);
      }
      void xor_all(T val) {
        if(root) { root->lazy ^= val; }
      }
      T max_element(T xor_val = 0) {
        xor_all(xor_val);
        T r = get_min(root, -1);
        xor_all(xor_val);
        return r;
      }
      T min_element(T xor_val = 0) {
        xor_all(xor_val);
        T r = get_min(root, 0);
        xor_all(xor_val);
        return r;
      }
      T kth_smallest(int k, T xor_val = 0) {
        assert(0 <= k && k < size());
        xor_all(xor_val);
        T r = get(root, k);
        xor_all(xor_val);
        return r;
      }
      int lower_bound(T val, T xor_val = 0) {
        xor_all(xor_val);
        int r = count_lower(root, val);
        xor_all(xor_val);
        return r;
      }
      int upper_bound(T val, T xor_val = 0) {
        xor_all(xor_val);
        int r = count_lower(root, val + 1);
        xor_all(xor_val);
        return r;
      }
      int count(T val) {
        if(!root) { return 0; }
        node *t = root;
        for(int i = MAX_LOG - 1; i >= 0; i--) {
          push(t, i);
          t = t->ch[(val >> (T)i) & (T)1];
          if(!t) { return 0; }
        }
        return t->cnt;
      }
    };
    """

  'binarytrie':
    'prefix':'binarytrie'
    'body':'BinaryTrie<30> b;'

  'ranges':
    'prefix':'ranges'
    'body':'ranges::'

  'views':
    'prefix':'views'
    'body':'views::'

  'views_reverse':
    'prefix':'views_reverse'
    'body':'views::reverse($1)$2'

  'views_keys':
    'prefix':'keys'
    'body':'views::keys($1)$2'

  'views_values':
    'prefix':'values'
    'body':'views::values($1)$2'

  'Lowlink':
    'prefix':'Lowlink'
    'body':"""
    struct Lowlink {
      const vector<vector<ll>> g;
      ll N;
      vector<ll> ord, low;
      vector<ll> articulation;  // 関節点
      vector<pair<ll, ll>> bridge;  // 橋 (辺(u, v)が u < v となるよう格納)
      Lowlink(const vector<vector<ll>> &g_): g(g_), N(g.size()), ord(N, -1), low(N, -1) {
        for(ll i = 0, k = 0; i < N; i++) {
          if(ord[i] == -1) {k = dfs(i, k, -1);}
        }
      }
      ll dfs(ll idx, ll k, ll par) {
        low[idx] = (ord[idx] = k++);
        ll cnt = 0;
        bool arti = false, second = false;
        for(auto &to : g[idx]) {
          if(ord[to] == -1) {
            cnt++;
            k = dfs(to, k, idx);
            low[idx] = min(low[idx], low[to]);
            arti |= (par != -1) && (low[to] >= ord[idx]);
            if(ord[idx] < low[to]) {bridge.emplace_back(minmax(idx, to));}
          }
          else if(to != par || second) {low[idx] = min(low[idx], ord[to]);}
          else {second = true;}
        }
        arti |= par == -1 && cnt > 1;
        if(arti) {articulation.emplace_back(idx);}
        return k;
      }
    };
    """

  'StringSearch':
    'prefix':'StringSearch'
    'body':"""
    template<typename T> struct SparseTable {
      inline static constexpr T INF = numeric_limits<T>::max() / 2;
      int N;
      vector<vector<T>> table;
      T f(T a, T b) { return min(a, b); }
      SparseTable() {}
      SparseTable(const vector<T> &v): N(ssize(v)) {
        int b = 1;
        while((1 << b) <= N) { ++b; }
        table.emplace_back(v);
        for(int i = 1; i < b; i++) {
          table.emplace_back(vector<T>(N, INF));
          for(int j = 0; j + (1 << i) <= N; j++) {
            table[i][j] = f(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);
          }
        }
      }
      T query(int l, int r) {  // [l, r)
        assert(0 <= l && l <= r && r <= N);
        if(l == r) { return INF; }
        int b = 31 - __builtin_clz(r - l);
        return f(table[b][l], table[b][r - (1 << b)]);
      }
    };

    template<typename T> struct StringSearch {
      const T &S;
      ll N;
      vector<int> sa, la, inv;
      SparseTable<int> sparse;
      StringSearch(const T &s_): S(s_), N(ssize(S)) {
        sa = suffix_array(S);
        la = lcp_array(S, sa);
        inv.resize(N);
        for(ll i = 0; i < N; i++) { inv[sa[i]] = i; }
        sparse = SparseTable<int>{la};
      }
      // lcp(s[i, N), s[j, N))
      ll lcp(ll i, ll j) {
        assert(0 <= min(i, j) && max(i, j) < N);
        if(i == j) { return N - i; }
        auto [x, y] = minmax(inv[i], inv[j]);
        return sparse.query(x, y);
      }
      // lcp(s[a, b), s[c, d))
      ll lcp(ll a, ll b, ll c, ll d) {
        assert(0 <= a && a <= b && b <= N);
        assert(0 <= c && c <= d && d <= N);
        ll l = lcp(a, c);
        return min({l, b - a, d - c});
      }
      ll lcp(pair<ll, ll> p, pair<ll, ll> q) {
        return lcp(p.first, p.second, q.first, q.second);
      }
      // s[i, N) > s[j, N) : 1
      // s[i, N) = s[j, N) : 0
      // s[i, N) < s[j, N) : -1
      ll compare(ll i, ll j) {
        assert(0 <= min(i, j) && max(i, j) < N);
        if(i == j) { return 0; }
        return inv[i] < inv[j] ? -1 : 1;
      }
      // s[a, b) > s[c, d) : 1
      // s[a, b) = s[c, d) : 0
      // s[a, b) < s[c, d) : -1
      ll compare(ll a, ll b, ll c, ll d) {
        ll l = lcp(a, b, c, d);
        return a + l == b     ? (c + l == d ? 0 : -1)
        : c + l == d          ? 1
        : S[a + l] < S[c + l] ? -1
                              : 1;
      }
      ll compare(pair<ll, ll> p, pair<ll, ll> q) {
        return compare(p.first, p.second, q.first, q.second);
      }
    };
    """

  'Tree':
    'prefix':'Tree'
    'body':"""
    struct Tree : vector<vector<ll>> {
      using vector<vector<ll>>::operator=;

     private:
      void dfs_sz(ll v, ll p) {
        sz[v] = 1;
        ord.emplace_back(v);
        for(ll i = p, x = 0; i != -1;) {
          bl[v][x] = i;
          i = bl[i][x], x++;
        }
        for(auto &nv : (*this)[v]) {
          if(nv == p) {
            if((ll)(*this)[v].size() >= 2 && nv == (*this)[v][0]) { std::swap((*this)[v][0], (*this)[v][1]); }
            else { continue; }
          }
          dp[nv] = dp[v] + 1;
          dfs_sz(nv, v);
          sz[v] += sz[nv];
          if(sz[nv] > sz[(*this)[v][0]]) { std::swap(nv, (*this)[v][0]); }
        }
      }
      void dfs_hld(ll v) {
        down[v] = id++;
        for(auto &nv : (*this)[v]) {
          if(nv == par(v)) { continue; }
          nx[nv] = (nv == (*this)[v][0] ? nx[v] : nv);
          dfs_hld(nv);
        }
        up[v] = id;
      }
      vector<pair<ll, ll>> ascend(ll u, ll v) const {
        vector<pair<ll, ll>> r;
        while(nx[u] != nx[v]) {
          r.emplace_back(down[u], down[nx[u]]);
          u = par(nx[u]);
        }
        if(u != v) { r.emplace_back(down[u], down[v] + 1); }
        return r;
      }
      vector<pair<ll, ll>> descend(ll u, ll v) const {
        if(u == v) { return {}; }
        if(nx[u] == nx[v]) { return {{down[u] + 1, down[v]}}; }
        auto r = descend(u, par(nx[v]));
        r.emplace_back(down[nx[v]], down[v]);
        return r;
      }

     public:
      ll n, root, id = 0;
      vector<array<ll, 24>> bl;
      vector<ll> dp, sz, ord, down, up, nx;
      Tree(ll n_, ll r = 0): n(n_), root(r) { this->resize(n); }
      Tree(const vector<vector<ll>> &g, ll r = 0): n(g.size()), root(r) {
        *this = g;
        build();
      }
      void add_edge(ll u, ll v) {
        (*this)[u].emplace_back(v);
        (*this)[v].emplace_back(u);
      }
      void build() {
        bl.resize(n);
        dp.resize(n);
        sz.resize(n);
        down.assign(n, -1);
        up.assign(n, -1);
        nx.assign(n, root);
        for(auto &v : bl) { ranges::fill(v, -1); }
        dfs_sz(root, -1);
        dfs_hld(root);
      }
      ll depth(ll i) const { return dp[i]; }
      ll par(ll i) const { return i == root ? root : bl[i][0]; }
      ll order(ll i) const { return ord[i]; }
      ll in(ll i) const { return down[i]; }
      ll out(ll i) const { return up[i]; }
      ll size(ll i) const { return sz[i]; }
      ll kth_ancestor(ll i, ll k) const {
        if(dp[i] < k) { return -1; }
        while(k) {
          ll t = __builtin_ctz(k);
          i = bl[i][t], k ^= 1 << t;
        }
        return i;
      }
      ll dis(ll u, ll v) { return dp[u] + dp[v] - dp[lca(u, v)] * 2; }
      bool onpath(ll u, ll v, ll x) { return dis(u, v) == dis(u, x) + dis(x, v); }
      // vertex adjacent to u on u-v path
      ll nxt(ll u, ll v) const {
        if(dp[u] >= dp[v]) { return par(u); }
        ll x = kth_ancestor(v, dp[v] - dp[u] - 1);
        return bl[x][0] == u ? x : bl[u][0];
      }
      vector<ll> path(ll u, ll v) const {
        vector<ll> pre, suf;
        while(dp[u] > dp[v]) {
          pre.emplace_back(u);
          u = bl[u][0];
        }
        while(dp[u] < dp[v]) {
          suf.emplace_back(v);
          v = bl[v][0];
        }
        while(u != v) {
          pre.emplace_back(u);
          suf.emplace_back(v);
          u = bl[u][0];
          v = bl[v][0];
        }
        pre.emplace_back(u);
        ranges::reverse(suf);
        copy(suf.begin(), suf.end(), back_inserter(pre));
        return pre;
      }
      ll lca(ll u, ll v) {
        while(nx[u] != nx[v]) {
          if(down[u] < down[v]) { std::swap(u, v); }
          u = par(nx[u]);
        }
        return dp[u] < dp[v] ? u : v;
      }
      // vertex at distance x from u on u-v path
      ll jump(ll u, ll v, ll x) {
        ll lc = lca(u, v), d1 = dp[u] - dp[lc];
        if(x <= d1) { return kth_ancestor(u, x); }
        ll d = d1 + dp[v] - dp[lc];
        if(x <= d) { return kth_ancestor(v, d - x); }
        return -1;
      }
      vector<ll> diameter() {
        ll s = ranges::max_element(dp) - dp.begin();
        vector<ll> d(n, -1);
        d[s] = 0;
        queue<ll> q;
        q.emplace(s);
        while(!q.empty()) {
          ll v = q.front();
          q.pop();
          for(auto &nv : (*this)[v]) {
            if(d[nv] == -1) {
              d[nv] = d[v] + 1;
              q.emplace(nv);
            }
          }
        }
        ll t = ranges::max_element(d) - d.begin();
        return path(t, s);
      }
      template<typename F> void query(ll u, ll v, bool vertex, const F &f) {
        ll l = lca(u, v);
        for(auto &&[a, b] : ascend(u, l)) {
          ll s = a + 1, t = b;
          s > t ? f(t, s) : f(s, t);
        }
        if(vertex) f(down[l], down[l] + 1);
        for(auto &&[a, b] : descend(l, v)) {
          ll s = a, t = b + 1;
          s > t ? f(t, s) : f(s, t);
        }
      }
      template<typename F> void noncommutative_query(ll u, ll v, bool vertex, const F &f) {
        ll l = lca(u, v);
        for(auto &&[a, b] : ascend(u, l)) { f(a + 1, b); }
        if(vertex) { f(down[l], down[l] + 1); }
        for(auto &&[a, b] : descend(l, v)) { f(a, b + 1); }
      }
      template<typename F> void subtree_query(ll u, bool vertex, const F &f) {
        f(down[u] + int(!vertex), up[u]);
      }
    };
    """

  'PI':
    'prefix':'PI'
    'body':'numbers::pi'

  '__int128_t':
    'prefix':'int128t'
    'body':'__int128_t'

  'UniteInterval':
    'prefix':'UniteInterval'
    'body':"""
    // union of [a1,b1), [a2,b2) ...
    template<typename T> vector<pair<T, T>> UniteInterval(const vector<pair<T, T>> &v) {
      vector<pair<T, T>> u{v}, r;
      ranges::sort(u);
      for(auto &p : u) {
        r.emplace_back(p);
        while((int)r.size() >= 2) {
          const int n = r.size();
          if(r[n - 2].second < r[n - 1].first) { break; }
          pair<T, T> q = {r[n - 2].first, max<T>(r[n - 2].second, r[n - 1].second)};
          r.pop_back();
          r.pop_back();
          r.emplace_back(q);
        }
      }
      return r;
    }
    """

  'uniteinterval':
    'prefix':'uniteinterval'
    'body':'UniteInterval($1);$2'

  'Mulall':
    'prefix':'Mulall'
    'body':"""
    auto mulall(vector<auto> &v) {
      queue<int> q;
      for(int i = 0; i < (int)v.size(); i++) { q.emplace(i); }
      while((int)q.size() >= 2) {
        int x = q.front();
        q.pop();
        int y = q.front();
        q.pop();
        v[x] = convolution(v[x], v[y]);
        q.emplace(x);
      }
      return v[q.front()];
    }
    """

  'mulall':
    'prefix':'mulall'
    'body':'mulall($1);$2'

  'Bostan_Mori':
    'prefix':'Bostan_Mori'
    'body':"""
    template<typename T> T Bostan_Mori(FPS<T> p, FPS<T> q, ll n) {
      ll m = max(p.size(), q.size());
      p.resize(m);
      q.resize(m);
      while(n) {
        FPS<T> r = q;
        for(ll i = 0; i < ssize(r); i += 2) {r[i] = -r[i];}
        FPS<T> v = q * r, u = p * r;
        for(ll i = n % 2; i < ssize(u); i += 2) {p[i / 2] = u[i];}
        for(ll i = 0; i < ssize(v); i += 2){ q[i / 2] = v[i];}
        n /= 2;
      }
      return p[0] / q[0];
    }

    // ini = { a_0, a_1, ..., a_{k-1} }
    // a_n = rec_0 * a_{n-1} + rec_1 * a_{n-2} +...+ rec_{k-1} * a_{n-k}
    template<typename T> T Recurrence(vector<T> &ini, vector<T> &rec, ll n) {
      ll s = ini.size(), k = rec.size();
      assert(s >= k);
      FPS<T> p, q(k + 1), a(s);
      q[0] = 1;
      for(ll i = 0; i < k; i++) {q[i + 1] = -rec[i];}
      for(ll i = 0; i < s; i++) {a[i] = ini[i];}
      p = (q * a).pre(k);
      return Bostan_Mori(p, q, n);
    }
    """

  'if':
    'prefix':'if'
    'body':'if($1){$2}$3'

  'elif':
    'prefix':'else if'
    'body':'else if($1){$2}$3'

  'else':
    'prefix':'else'
    'body':'else{$1}$2'

  'PersistentArray':
    'prefix':'PersistentArray'
    'body':"""
    template<typename T, int shift = 4> struct PersistentArray {
      struct Node {
        Node *ns[1 << shift];
        Node() { memset(ns, 0, sizeof(ns)); }
        Node(const Node &other) { memcpy(ns, other.ns, sizeof(ns)); }
        Node(const Node *other) { memcpy(ns, other->ns, sizeof(ns)); }
      };
      inline Node *my_new() { return new Node(); }
      inline Node *my_new(const Node &other) { return new Node(other); }
      inline Node *my_new(const Node *other) { return new Node(other); }
      inline T *my_new_leaf(const T &val) { return new T{val}; }
      static constexpr int mask = (1 << shift) - 1;
      Node *root;
      int depth;
      T ID;
      PersistentArray() {}
      PersistentArray(ll MAX, T ID_ = T(0)): root(my_new()), depth(0), ID(ID_) {
        while(MAX) {
          depth++;
          MAX >>= shift;
        }
      }
      PersistentArray(const vector<T> &v, T ID_ = T(0)): root(my_new()), depth(0), ID(ID_) {
        ll MAX = v.size();
        while(MAX) {
          depth++;
          MAX >>= shift;
        }
        for(ll i = 0; i < (ll)v.size(); i++) {
          Node *n = root;
          for(ll k = i, d = depth; d; d--) {
            if(!(n->ns[k & mask])) {
              if(d == 1) { n->ns[k & mask] = reinterpret_cast<Node *>(my_new_leaf(v[i])); }
              else { n->ns[k & mask] = my_new(); }
            }
            n = n->ns[k & mask];
            k >>= shift;
          }
        }
      }
      T get(Node *n, ll k) const {
        for(ll i = depth; i; i--) {
          n = n ? n->ns[k & mask] : nullptr;
          k >>= shift;
        }
        return n ? *reinterpret_cast<T *>(n) : ID;
      }
      T get(ll k) const { return get(root, k); }
      Node *update(Node *n, ll k, const T &val) {
        stack<pair<Node *, int>> st;
        for(ll i = depth; i; i--) {
          st.emplace(n, k & mask);
          n = n ? n->ns[k & mask] : nullptr;
          k >>= shift;
        }
        Node *chd = reinterpret_cast<Node *>(my_new_leaf(val));
        while(!st.empty()) {
          Node *par;
          ll k;
          tie(par, k) = st.top();
          st.pop();
          Node *nxt = par ? my_new(par) : my_new();
          nxt->ns[k] = chd;
          chd = nxt;
        }
        return root = chd;
      }
      Node *update(ll k, const T &val) { return update(root, k, val); }
    };
    """

  'lll':
    'prefix':'lll'
    'body':"""
    const ll D_SI = 125;
    struct lll : vector<ll> {
      static const ll BASE = 100000000;
      static const ll BASE_D = 8;
      ll sign;
      lll(ll n = 0): vector<ll>(D_SI, 0), sign(1) {
        if(n < 0) { sign = -1, n = -n; }
        (*this)[0] = n;
        this->normalize();
      }
      lll(ll size, ll n): vector<ll>(size, n), sign(1) {}
      lll &normalize() {
        ll c = 0;
        bool e = false;
        for(ll i = 0;; ++i) {
          if(i >= this->size()) { this->push_back(0); }
          if((*this)[i] < 0 && i + 1 >= this->size()) { this->push_back(0); }
          while((*this)[i] < 0) {
            (*this)[i + 1] -= 1;
            (*this)[i] += BASE;
          }
          ll a = (*this)[i] + c;
          (*this)[i] = a % BASE;
          if((*this)[i]) { e = 1; }
          c = a / BASE;
          if(c == 0 && i == this->size() - 1) { break; }
        }
        if(!e) { sign = 1; }
        return (*this);
      }
      friend lll abs(const lll &x) {
        lll z = x;
        if(z.sign == -1) { z.sign = 1; }
        return z;
      }
      lll operator-() const {
        lll r = *this;
        bool z = 1;
        for(ll i = 0; i < (ll)this->size(); i++) {
          if(r[i] != 0) {
            z = 0;
            break;
          }
        }
        if(!z) { r.sign = -r.sign; }
        return r;
      }
      lll &operator+=(const lll &r) {
        while(size() < r.size()) this->emplace_back(0);
        if(sign == r.sign) {
          for(ll i = 0; i < (ll)r.size(); i++) {
            (*this)[i] += r[i];
          }
        }
        else {
          if(sign == 1 && abs(*this) < abs(r)) { sign = -1; }
          else if(sign == -1 && abs(*this) <= abs(r)) { sign = 1; }
          if(abs(*this) >= abs(r)) {
            for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] -= r[i]; }
          }
          else {
            for(ll i = 0; i < (ll)size(); i++) { (*this)[i] = -(*this)[i]; }
            for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] += r[i]; }
          }
        }
        return this->normalize();
      }
      lll &operator-=(const lll &r) {
        while(size() < r.size()) { this->emplace_back(0); }
        if(sign == -r.sign) {
          for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] += r[i]; }
        }
        else {
          if(sign == 1 && abs(*this) < abs(r)) { sign = -1; }
          else if(sign == -1 && abs(*this) <= abs(r)) { sign = 1; }
          if(abs(*this) >= abs(r)) {
            for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] -= r[i]; }
          }
          else {
            for(ll i = 0; i < (ll)size(); i++) { (*this)[i] = -(*this)[i]; }
            for(ll i = 0; i < (ll)r.size(); i++) { (*this)[i] += r[i]; }
          }
        }
        return this->normalize();
      }
      lll &operator*=(ll r) {
        if((sign == 1 && r >= 0) || (sign == -1 && r < 0)) { sign = 1; }
        else { sign = -1; }
        if(r < 0) { r = -r; }
        for(ll i = 0; i < (ll)size(); i++) { (*this)[i] *= r; }
        return this->normalize();
      }
      lll &operator*=(const lll &r) {
        ll tx = size() - 1, ty = r.size() - 1;
        for(tx = size() - 1; tx >= 0; --tx) {
          if((*this)[tx] > 0) { break; }
        }
        for(ty = r.size() - 1; ty >= 0; --ty) {
          if(r[ty] > 0) { break; }
        }
        lll res(0);
        res.resize(tx + ty + 2);
        if(sign == r.sign) { res.sign = 1; }
        else { res.sign = -1; }
        for(ll i = 0; i <= tx; i++) {
          for(ll j = 0; j <= ty && i + j < res.size() - 1; j++) {
            ll val = (*this)[i] * r[j] + res[i + j];
            res[i + j + 1] += val / lll::BASE;
            res[i + j] = val % lll::BASE;
          }
        }
        return (*this) = res.normalize();
      }
      friend lll POW(const lll &a, ll n) {
        lll r(1), b = a;
        while(n > 0) {
          if(n & 1) { r = r * b; }
          b = b * b;
          n >>= 1;
        }
        return r;
      }
      lll operator+(const lll &r) const { return lll(*this) += r; }
      lll operator-(const lll &r) const { return lll(*this) -= r; }
      lll operator*(ll r) const { return lll(*this) *= r; }
      lll operator*(const lll &r) const { return lll(*this) *= r; }
      lll &operator/=(ll r) {
        if(r < 0) { sign *= -1, r = -r; }
        ll c = 0, t = 0;
        for(ll i = size() - 1; i >= 0; i--) {
          t = lll::BASE * c + (*this)[i];
          (*this)[i] = t / r;
          c = t % r;
        }
        this->normalize();
        return (*this);
      }
      ll operator%=(ll r) {
        if(r < 0) { sign *= -1, r = -r; }
        ll c = 0, t = 0;
        for(ll i = size() - 1; i >= 0; i--) {
          t = lll::BASE * c + (*this)[i];
          (*this)[i] = t / r;
          c = t % r;
        }
        return c;
      }
      lll operator/(ll r) const { return lll(*this) /= r; }
      ll operator%(ll r) const { return lll(*this) %= r; }
      friend pair<lll, lll> divmod(const lll &a, const lll &r) {
        lll zero = 0, s = 0, t = 0;
        if(abs(a) < abs(r)) { return {zero, a}; }
        lll ar = abs(r);
        s.resize(a.size()), t.resize(r.size());
        ll tx = a.size() - 1;
        for(; tx >= 0; --tx) {
          if(a[tx] > 0) { break; }
        }
        for(ll i = tx; i >= 0; i--) {
          t = t * lll::BASE + a[i];
          ll lo = 0, hi = lll::BASE;
          if(t >= ar) {
            while(hi - lo > 1) {
              ll mid = (hi + lo) / 2;
              if(ar * mid > t) hi = mid;
              else lo = mid;
            }
            t -= ar * lo;
          }
          s[i] = lo;
        }
        if(a.sign == r.sign) { s.sign = 1, t.sign = 1; }
        else { s.sign = -1, t.sign = 1; }
        return make_pair(s.normalize(), t.normalize());
      }
      lll operator/(const lll &r) const { return divmod((*this), r).first; }
      lll operator%(const lll &r) const { return divmod((*this), r).second; }
      lll &operator/=(const lll &r) { return (*this) = (*this) / r; }
      lll &operator%=(const lll &r) { return (*this) = (*this) % r; }
      friend bool operator<(const lll &x, const lll &y) {
        if(x.sign < y.sign) { return true; }
        else if(x.sign > y.sign) { return false; }
        else {
          ll tx = x.size() - 1, ty = y.size() - 1;
          for(tx = x.size() - 1; tx >= 0; --tx) {
            if(x[tx] > 0) { break; }
          }
          for(ty = y.size() - 1; ty >= 0; --ty) {
            if(y[ty] > 0) { break; }
          }
          if(tx < ty) { return true; }
          else if(tx > ty) { return false; }
          else if(x.sign == 1) {
            for(ll i = tx; i >= 0; i--) {
              if(x[i] != y[i]) { return x[i] < y[i]; }
            }
            return false;
          }
          else {
            for(ll i = tx; i >= 0; i--) {
              if(x[i] != y[i]) { return x[i] > y[i]; }
            }
            return false;
          }
        }
      }
      friend bool operator>(const lll &x, const lll &y) { return y < x; }
      friend bool operator<=(const lll &x, const lll &y) { return !(x > y); }
      friend bool operator>=(const lll &x, const lll &y) { return !(x < y); }
      friend bool operator==(const lll &x, const lll &y) {
        if(x.sign != y.sign) { return 0; }
        ll tx = (ll)x.size() - 1, ty = (ll)y.size() - 1;
        for(tx = x.size() - 1; tx >= 0; --tx) {
          if(x[tx] > 0) { break; }
        }
        for(ty = y.size() - 1; ty >= 0; --ty) {
          if(y[ty] > 0) { break; }
        }
        if(tx != ty) { return false; }
        for(ll i = tx; i >= 0; i--) {
          if(x[i] != y[i]) { return false; }
        }
        return true;
      }
      friend bool operator!=(const lll &x, const lll &y) { return !(x == y); }
    };

    lll tolll(const string &is) {
      string s = is;
      if(s[0] == '-') { s = s.substr(1); }
      while(s.size() % lll::BASE_D != 0) s = "0" + s;
      ll N = s.size();
      lll res(N / lll::BASE_D, 0);
      for(ll i = 0; i < (ll)s.size(); i++) {
        res[(N - i - 1) / lll::BASE_D] *= 10;
        res[(N - i - 1) / lll::BASE_D] += s[i] - '0';
      }
      if(is[0] == '-') { res.sign = -1; }
      return res;
    }
    string tostr(const lll &r) {
      stringstream ss;
      if(r.sign == -1) { ss << '-'; }
      ll d = r.size() - 1;
      for(; d >= 0; --d) {
        if(r[d] > 0) { break; }
      }
      if(d == -1) { ss << 0; }
      else { ss << r[d]; }
      for(ll i = d - 1; i >= 0; i--) {
        ss.width(lll::BASE_D);
        ss.fill('0');
        ss << r[i];
      }
      return ss.str();
    }

    istream &operator>>(istream &is, lll &x) {
      string s;
      is >> s;
      x = tolll(s);
      return is;
    }
    ostream &operator<<(ostream &os, const lll &x) {
      if(x.sign == -1) { os << '-'; }
      ll d = x.size() - 1;
      for(d = x.size() - 1; d >= 0; --d) {
        if(x[d] > 0) { break; }
      }
      if(d == -1) { os << 0; }
      else { os << x[d]; }
      for(ll i = d - 1; i >= 0; i--) {
        os.width(lll::BASE_D);
        os.fill('0');
        os << x[i];
      }
      return os;
    }
    """

  'Rotate':
    'prefix':'Rotate'
    'body':"""
    auto rotate = [&n]<typename T>(vector<vector<T>> &v) {
      vector<vector<T>> u(n, vector<T>(n));
      for(ll i = 0; i < n; i++) {
        for(ll j = 0; j < n; j++) {
          u[j][n - 1 - i] = v[i][j];
        }
      }
      v = u;
      return;
    };
    """

  'rotate':
    'prefix':'rotate'
    'body':'rotate($1);'

  'ImplicitTreap':
    'prefix':'ImplicitTreap'
    'body':"""
    template<typename T0, typename T1> struct ImplicitTreap {
     private:
      virtual T0 f0(T0, T0) = 0;
      const T0 u0;
      virtual T1 f1(T1, T1) = 0;
      const T1 u1;
      virtual T0 g(T0, T1) = 0;
      virtual T1 p(T1, int) = 0;
      struct xorshift {
        uint64_t x;
        xorshift() {
          mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
          x = rnd();
          for(int i = 0; i < 100; i++) { random(); }
        }
        uint64_t random() {
          x = x ^ (x << 7);
          return x = x ^ (x >> 9);
        }
      } rnd;
      struct Node {
        T0 value, acc;
        T1 lazy;
        int priority, cnt;
        bool rev;
        Node *l, *r;
        Node(T0 value_, int priority_, T0 u0_, T1 u1_): value(value_), acc(u0_), lazy(u1_), priority(priority_), cnt(1), rev(false), l(nullptr), r(nullptr) {}
      } *root = nullptr;
      using Tree = Node *;
      int cnt(Tree t) { return t ? t->cnt : 0; }
      T0 acc(Tree t) { return t ? t->acc : u0; }
      void update_cnt(Tree t) {
        if(t) { t->cnt = 1 + cnt(t->l) + cnt(t->r); }
      }
      void update_acc(Tree t) {
        if(t) { t->acc = f0(acc(t->l), f0(t->value, acc(t->r))); }
      }
      void pushup(Tree t) { update_cnt(t), update_acc(t); }
      void pushdown(Tree t) {
        if(t && t->rev) {
          t->rev = false;
          swap(t->l, t->r);
          if(t->l) { t->l->rev ^= 1; }
          if(t->r) { t->r->rev ^= 1; }
        }
        if(t && t->lazy != u1) {
          if(t->l) {
            t->l->lazy = f1(t->l->lazy, t->lazy);
            t->l->acc = g(t->l->acc, p(t->lazy, cnt(t->l)));
          }
          if(t->r) {
            t->r->lazy = f1(t->r->lazy, t->lazy);
            t->r->acc = g(t->r->acc, p(t->lazy, cnt(t->r)));
          }
          t->value = g(t->value, p(t->lazy, 1));
          t->lazy = u1;
        }
        pushup(t);
      }
      void split(Tree t, int key, Tree &l, Tree &r) {
        if(!t) {
          l = r = nullptr;
          return;
        }
        pushdown(t);
        int implicit_key = cnt(t->l) + 1;
        if(key < implicit_key) { split(t->l, key, l, t->l), r = t; }
        else { split(t->r, key - implicit_key, t->r, r), l = t; }
        pushup(t);
      }
      void insert(Tree &t, int key, Tree item) {
        Tree t1, t2;
        split(t, key, t1, t2);
        merge(t1, t1, item);
        merge(t, t1, t2);
      }
      void merge(Tree &t, Tree l, Tree r) {
        pushdown(l);
        pushdown(r);
        if(!l || !r) { t = l ? l : r; }
        else if(l->priority > r->priority) { merge(l->r, l->r, r), t = l; }
        else { merge(r->l, l, r->l), t = r; }
        pushup(t);
      }
      void erase(Tree &t, int key) {
        Tree t1, t2, t3;
        split(t, key + 1, t1, t2);
        split(t1, key, t1, t3);
        merge(t, t1, t2);
      }
      void update(Tree t, int l, int r, T1 x) {
        if(l >= r) return;
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        t2->lazy = f1(t2->lazy, x);
        t2->acc = g(t2->acc, p(x, cnt(t2)));
        merge(t2, t2, t3);
        merge(t, t1, t2);
      }
      T0 query(Tree t, int l, int r) {
        if(l == r) return u0;
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        T0 ret = t2->acc;
        merge(t2, t2, t3);
        merge(t, t1, t2);
        return ret;
      }
      int find(Tree t, T0 x, int offset, bool left = true) {
        if(f0(t->acc, x) == x) { return -1; }
        else {
          if(left) {
            if(t->l && f0(t->l->acc, x) != x) { return find(t->l, x, offset, left); }
            else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->r, x, offset + cnt(t->l) + 1, left); }
          }
          else {
            if(t->r && f0(t->r->acc, x) != x) { return find(t->r, x, offset + cnt(t->l) + 1, left); }
            else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->l, x, offset, left); }
          }
        }
      }
      void reverse(Tree t, int l, int r) {
        if(l > r) { return; }
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        t2->rev ^= 1;
        merge(t2, t2, t3);
        merge(t, t1, t2);
      }
      void rotate(Tree t, int l, int m, int r) {
        reverse(t, l, r);
        reverse(t, l, l + r - m);
        reverse(t, l + r - m, r);
      }
      void dump(Tree t) {
        if(!t) return;
        pushdown(t);
        dump(t->l);
        cout << t->value << " ";
        dump(t->r);
      }

     public:
      ImplicitTreap(T0 u0_, T1 u1_): u0(u0_), u1(u1_) {}
      void set_by_vector(const vector<T0> &a) {
        for(int i = 0; i < a.size(); i++) {
          insert(i, a[i]);
        }
      }
      int size() { return cnt(root); }
      void insert(int pos, T0 x) { insert(root, pos, new Node(x, rnd.random(), u0, u1)); }
      void update(int l, int r, T1 x) { update(root, l, r, x); }
      T0 query(int l, int r) { return query(root, l, r); }
      int binary_search(int l, int r, T0 x, bool left = true) {
        if(l >= r) return -1;
        Tree t1, t2, t3;
        split(root, l, t1, t2);
        split(t2, r - l, t2, t3);
        int ret = find(t2, x, l, left);
        merge(t2, t2, t3);
        merge(root, t1, t2);
        return ret;
      }
      void erase(int pos) { erase(root, pos); }
      void reverse(int l, int r) { reverse(root, l, r); }
      void rotate(int l, int m, int r) { rotate(root, l, m, r); }
      void dump() {
        dump(root);
        cout << endl;
      }
      T0 operator[](int pos) { return query(pos, pos + 1); }
    };

    /*
    int size() : O(1)
    void insert(int pos, T0 x)       : 先頭から pos の位置 (pos == 0 なら先頭)に x を挿入 O(logn)
    void update(int l, int r, T1 x)  : [l,r) に x を作用　O(logn)
    T0 query(int l, int r)           : [l,r) の累積 O(logn)
    void erase(int pos)              : 位置 pos を削除 O(logn)
    void reverse(int l, int r)       : [l,r) を反転 O(logn)
    void rotate(int l, int m, int r) : [l,r) の先頭が m になるよう回転
    T0 operator[]                    : ランダムアクセス O(logn)
    void dump()                      : 配列の中身を print (debug用)
    int binary_search(int l, int r, T0 x, bool left = true) :
      k∈[l, r) で f0(tr[k], x) != x となる最左/右のもの。存在しない場合は-1 O(logn)
      ex) MinMonoidの場合、x未満の最左/最右の要素の位置を返す
    */
    """

  'ImplicitTreap_Update_Min':
    'prefix':'ImplicitTreap_Update_Min'
    'body':"""
    template<typename T0, typename T1> struct UpdateMinQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      UpdateMinQuery(): UpdateMinQuery(numeric_limits<T0>::max(), numeric_limits<T1>::min()) {}
      T0 f0(T0 x, T0 y) override { return min(x, y); }
      T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T1 p(T1 x, int len) override { return x; }
    };
    """

  'ImplicitTreap_Add_Sum':
    'prefix':'ImplicitTreap_Add_Sum'
    'body':"""
    template<typename T0, typename T1> struct AddSumQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      AddSumQuery(): AddSumQuery(0, 0) {}
      T0 f0(T0 x, T0 y) override { return x + y; }
      T1 f1(T1 x, T1 y) override { return x + y; }
      T0 g(T0 x, T1 y) override { return x + y; }
      T1 p(T1 x, int len) override { return x * len; }
    };
    """

  'ImplicitTreap_Add_Min':
    'prefix':'ImplicitTreap_Add_Min'
    'body':"""
    template<typename T0, typename T1> struct AddMinQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      AddMinQuery(): AddMinQuery(numeric_limits<T0>::max(), 0) {}
      T0 f0(T0 x, T0 y) override { return min(x, y); }
      T1 f1(T1 x, T1 y) override { return x + y; }
      T0 g(T0 x, T1 y) override { return x + y; }
      T1 p(T1 x, int len) override { return x; }
    };
    """

  'ImplicitTreap_Update_Sum':
    'prefix':'ImplicitTreap_Update_Sum'
    'body':"""
    template<typename T0, typename T1> struct UpdateSumQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      UpdateSumQuery(): UpdateSumQuery(0, numeric_limits<T1>::min()) {}
      T0 f0(T0 x, T0 y) override { return x + y; }
      T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T1 p(T1 x, int len) override { return x == numeric_limits<T1>::min() ? numeric_limits<T1>::min() : x * len; }
    };
    """

  'ImplicitTreap_Affine_Sum':
    'prefix':'ImplicitTreap_Affine_Sum'
    'body':"""
    template<typename T0> struct AffineSumQuery : public ImplicitTreap<T0, pair<T0, T0>> {
      using T1 = pair<T0, T0>;  // first * x + second
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      AffineSumQuery(): AffineSumQuery(0, {1, 0}) {}
      T0 f0(T0 x, T0 y) override { return x + y; }
      T1 f1(T1 x, T1 y) override { return {x.first * y.first, x.second * y.first + y.second}; }
      T0 g(T0 x, T1 y) override { return y.first * x + y.second; }
      T1 p(T1 x, int len) override { return {x.first, x.second * len}; }
      // update(i, j, {a, b}); // [i, j)にax + bを作用
      // update(i, j, {0, a}); // update
      // update(i, j, {1, a}); // 加算
      // update(i, j, {a, 0}); // 倍
    };
    """

  'ImplicitTreap_Affine_MinMax':
    'prefix':'ImplicitTreap_Affine_MinMax'
    'body':"""
    template<typename T> struct AffineMinMaxQuery : public ImplicitTreap<pair<T, T>, pair<T, T>> {
      using T0 = pair<T, T>;  // {min, max}
      using T1 = pair<T, T>;  // first * x + second
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      AffineMinMaxQuery(): AffineMinMaxQuery({numeric_limits<T>::max(), -numeric_limits<T>::max()}, {1, 0}) {
      }
      T0 f0(T0 x, T0 y) override { return {min(x.first, y.first), max(x.second, y.second)}; }
      T1 f1(T1 x, T1 y) override { return {x.first * y.first, x.second * y.first + y.second}; }
      T0 g(T0 x, T1 y) override {
        T0 ret = {x.first * y.first + y.second, x.second * y.first + y.second};
        if(y.first < 0) swap(ret.first, ret.second);
        return ret;
      }
      T1 p(T1 x, int len) override { return x; }
      // update(i, j, {a, b}); // [i, j)にax + bを作用
      // update(i, j, {0, a}); // update
      // update(i, j, {1, a}); // 加算
      // update(i, j, {a, 0}); // 倍
    };
    """

  'PrioritySum_super':
    'prefix':'PrioritySum_super'
    'body':"""
    using T = pair<ll, ll>;
    T op(T l, T r) { return {l.first + r.first, l.second + r.second}; }
    T e() { return {0, 0}; }
    ll tar;
    bool F(T x) { return tar > x.second; }

    struct PrioritySum {
      int n;
      segtree<T, op, e> seg;
      vector<ll> s;
      PrioritySum() {}
      void use(ll x) { s.emplace_back(x); }
      void build() {
        ranges::sort(s);
        s.erase(unique(s.begin(), s.end()), s.end());
        n = s.size();
        seg = segtree<T, op, e>(n);
      }
      void insert(ll x, ll c = 1) {
        int idx = ranges::lower_bound(s, x) - s.begin();
        auto [sum, cnt] = seg.get(idx);
        seg.set(idx, {sum + x * c, cnt + c});
      }
      void erase(ll x, ll c = 1) { insert(x, -c); }
      ll min(int k) const {
        if(!k) { return 0; }
        tar = k;
        int idx = seg.max_right<F>(0);
        auto [sum, cnt] = seg.prod(0, idx);
        sum += s[idx] * (k - cnt);
        return sum;
      }
      ll max(int k) const {
        if(!k) { return 0; }
        tar = k;
        int idx = seg.min_left<F>(n) - 1;
        auto [sum, cnt] = seg.prod(idx, n);
        sum -= s[idx] * (cnt - k);
        return sum;
      }
    } s;
    """

  'PairQuery':
    'prefix':'_PairQuery'
    'body':"""
    template<typename T0, typename T1> struct ImplicitTreap {
     private:
      virtual T0 f0(T0, T0) = 0;
      const T0 u0;
      virtual T1 f1(T1, T1) = 0;
      const T1 u1;
      virtual T0 g(T0, T1) = 0;
      virtual T1 p(T1, int) = 0;
      struct xorshift {
        uint64_t x;
        xorshift() {
          mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
          x = rnd();
          for(int i = 0; i < 100; i++) { random(); }
        }
        uint64_t random() {
          x = x ^ (x << 7);
          return x = x ^ (x >> 9);
        }
      } rnd;
      struct Node {
        T0 value, acc;
        T1 lazy;
        int priority, cnt;
        bool rev;
        Node *l, *r;
        Node(T0 value_, int priority_, T0 u0_, T1 u1_): value(value_), acc(u0_), lazy(u1_), priority(priority_), cnt(1), rev(false), l(nullptr), r(nullptr) {}
      } *root = nullptr;
      using Tree = Node *;
      int cnt(Tree t) { return t ? t->cnt : 0; }
      T0 acc(Tree t) { return t ? t->acc : u0; }
      void update_cnt(Tree t) {
        if(t) { t->cnt = 1 + cnt(t->l) + cnt(t->r); }
      }
      void update_acc(Tree t) {
        if(t) { t->acc = f0(acc(t->l), f0(t->value, acc(t->r))); }
      }
      void pushup(Tree t) { update_cnt(t), update_acc(t); }
      void pushdown(Tree t) {
        if(t && t->rev) {
          t->rev = false;
          swap(t->l, t->r);
          if(t->l) { t->l->rev ^= 1; }
          if(t->r) { t->r->rev ^= 1; }
        }
        if(t && t->lazy != u1) {
          if(t->l) {
            t->l->lazy = f1(t->l->lazy, t->lazy);
            t->l->acc = g(t->l->acc, p(t->lazy, cnt(t->l)));
          }
          if(t->r) {
            t->r->lazy = f1(t->r->lazy, t->lazy);
            t->r->acc = g(t->r->acc, p(t->lazy, cnt(t->r)));
          }
          t->value = g(t->value, p(t->lazy, 1));
          t->lazy = u1;
        }
        pushup(t);
      }
      void split(Tree t, int key, Tree &l, Tree &r) {
        if(!t) {
          l = r = nullptr;
          return;
        }
        pushdown(t);
        int implicit_key = cnt(t->l) + 1;
        if(key < implicit_key) { split(t->l, key, l, t->l), r = t; }
        else { split(t->r, key - implicit_key, t->r, r), l = t; }
        pushup(t);
      }
      void insert(Tree &t, int key, Tree item) {
        Tree t1, t2;
        split(t, key, t1, t2);
        merge(t1, t1, item);
        merge(t, t1, t2);
      }
      void merge(Tree &t, Tree l, Tree r) {
        pushdown(l);
        pushdown(r);
        if(!l || !r) { t = l ? l : r; }
        else if(l->priority > r->priority) { merge(l->r, l->r, r), t = l; }
        else { merge(r->l, l, r->l), t = r; }
        pushup(t);
      }
      void erase(Tree &t, int key) {
        Tree t1, t2, t3;
        split(t, key + 1, t1, t2);
        split(t1, key, t1, t3);
        merge(t, t1, t2);
      }
      void update(Tree t, int l, int r, T1 x) {
        if(l >= r) return;
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        t2->lazy = f1(t2->lazy, x);
        t2->acc = g(t2->acc, p(x, cnt(t2)));
        merge(t2, t2, t3);
        merge(t, t1, t2);
      }
      T0 query(Tree t, int l, int r) {
        if(l == r) return u0;
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        T0 ret = t2->acc;
        merge(t2, t2, t3);
        merge(t, t1, t2);
        return ret;
      }
      int find(Tree t, T0 x, int offset, bool left = true) {
        if(f0(t->acc, x) == x) { return -1; }
        else {
          if(left) {
            if(t->l && f0(t->l->acc, x) != x) { return find(t->l, x, offset, left); }
            else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->r, x, offset + cnt(t->l) + 1, left); }
          }
          else {
            if(t->r && f0(t->r->acc, x) != x) { return find(t->r, x, offset + cnt(t->l) + 1, left); }
            else { return (f0(t->value, x) != x) ? offset + cnt(t->l) : find(t->l, x, offset, left); }
          }
        }
      }
      void reverse(Tree t, int l, int r) {
        if(l > r) { return; }
        Tree t1, t2, t3;
        split(t, l, t1, t2);
        split(t2, r - l, t2, t3);
        t2->rev ^= 1;
        merge(t2, t2, t3);
        merge(t, t1, t2);
      }
      void rotate(Tree t, int l, int m, int r) {
        reverse(t, l, r);
        reverse(t, l, l + r - m);
        reverse(t, l + r - m, r);
      }
      void dump(Tree t) {
        if(!t) return;
        pushdown(t);
        dump(t->l);
        cout << t->value << " ";
        dump(t->r);
      }

     public:
      ImplicitTreap(T0 u0_, T1 u1_): u0(u0_), u1(u1_) {}
      void set_by_vector(const vector<T0> &a) {
        for(int i = 0; i < a.size(); i++) {
          insert(i, a[i]);
        }
      }
      int size() { return cnt(root); }
      void insert(int pos, T0 x) { insert(root, pos, new Node(x, rnd.random(), u0, u1)); }
      void update(int l, int r, T1 x) { update(root, l, r, x); }
      T0 query(int l, int r) { return query(root, l, r); }
      int binary_search(int l, int r, T0 x, bool left = true) {
        if(l >= r) return -1;
        Tree t1, t2, t3;
        split(root, l, t1, t2);
        split(t2, r - l, t2, t3);
        int ret = find(t2, x, l, left);
        merge(t2, t2, t3);
        merge(root, t1, t2);
        return ret;
      }
      void erase(int pos) { erase(root, pos); }
      void reverse(int l, int r) { reverse(root, l, r); }
      void rotate(int l, int m, int r) { rotate(root, l, m, r); }
      void dump() {
        dump(root);
        cout << endl;
      }
      T0 operator[](int pos) { return query(pos, pos + 1); }
    };

    template<typename T0, typename T1> struct UpdateSumQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      UpdateSumQuery(): UpdateSumQuery(0, numeric_limits<T1>::min()) {}
      T0 f0(T0 x, T0 y) override { return x + y; }
      T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T1 p(T1 x, int len) override { return x == numeric_limits<T1>::min() ? numeric_limits<T1>::min() : x * len; }
    };

    template<typename T0, typename T1> struct UpdateMinQuery : public ImplicitTreap<T0, T1> {
      using ImplicitTreap<T0, T1>::ImplicitTreap;
      UpdateMinQuery(): UpdateMinQuery(numeric_limits<T0>::max(), numeric_limits<T1>::min()) {}
      T0 f0(T0 x, T0 y) override { return min(x, y); }
      T1 f1(T1 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T0 g(T0 x, T1 y) override { return y == numeric_limits<T1>::min() ? x : y; }
      T1 p(T1 x, int len) override { return x; }
    };

    namespace std {
    template<typename T0, typename T1> class numeric_limits<pair<T0, T1>>
    {
     public:
      static constexpr pair<T0, T1> min() { return {numeric_limits<T0>::min(), numeric_limits<T1>::min()}; }
      static constexpr pair<T0, T1> max() { return {numeric_limits<T0>::max(), numeric_limits<T1>::max()}; }
    };
    }  // namespace std

    template<typename T0, typename T1, bool ascending = true> struct PairQuery {
      UpdateSumQuery<T1, T1> tr;
      UpdateMinQuery<pair<T0, T1>, pair<T0, T1>> tr2;
      int cnt = 0;
      void insert(const pair<T0, T1> &a) {
        int p = tr2.binary_search(0, tr2.size(), a, !ascending);
        if(ascending) {
          tr.insert(p + 1, a.second);
          tr2.insert(p + 1, a);
        }
        else {
          if(p == -1) {
            tr.insert(tr.size(), a.second);
            tr2.insert(tr2.size(), a);
          }
          else {
            tr.insert(p, a.second);
            tr2.insert(p, a);
          }
        }
        cnt++;
      }
      // 第一要素がxのものとxより左側のものに対し第二要素の累積を返す
      T1 query(T0 x) {
        if(ascending) {
          int p = tr2.binary_search(0, tr2.size(), {x, numeric_limits<T1>::max()}, false);
          p++;
          return tr.query(0, p);
        }
        else {
          int p = tr2.binary_search(0, tr2.size(), {x, numeric_limits<T1>::min()});
          if(p == -1) p = cnt;
          return tr.query(0, p);
        }
      }
      void erase_at(int k) {
        assert(0 <= k && k < cnt);
        tr.erase(k);
        tr2.erase(k);
        cnt--;
      }
      void erase(const pair<T0, T1> &a) {
        int p = tr2.binary_search(0, tr2.size(), a, !ascending);
        if(ascending) { p++; }
        else {
          if(p == -1) p = cnt;
          p--;
        }
        assert(0 <= p && p < cnt && tr2[p] == a);
        erase_at(p);
      }
      int size() const { return cnt; }
      T1 sum(int k) { return tr.query(0, k); }
      pair<T0, T1> operator[](int k) { return tr2[k]; }
      void dump() { tr2.dump(); }
      T1 operator()(int k) { return sum(k); }
    };

    template<typename T> using MaxSum = PairQuery<T, T, false>;
    template<typename T> using MinSum = PairQuery<T, T, true>;
    """

  'array':
    'prefix':'array'
    'body':'array<ll,$1>$2'

  'va':
    'prefix':'va'
    'body':'vector<array<ll,$1>>$2'

  'GCDCNT':
    'prefix':'GCDCNT'
    'body':"""
    // i∈[1,n] で gcd(i, k) == first となるものの個数/総和を求める
    template<bool Sum = false, typename T = ll> vector<pair<ll, T>> GCDcnt(ll n, ll k) {
      vector<ll> p, div;
      ll l = k;
      for(ll i = 1; i * i <= k; i++) {
        if(k % i) { continue; }
        div.emplace_back(i);
        if(i * i != k) { div.emplace_back(k / i); }
        if(i == 1 || l % i) { continue; }
        while(l % i == 0) { l /= i; }
        p.emplace_back(i);
      }
      if(l != 1) { p.emplace_back(l); }

      ll s = p.size();
      vector<pair<ll, bool>> e;
      for(ll i = 0; i < 1 << s; i++) {
        ll t = 1;
        bool odd = false;
        for(ll j = 0; j < s; j++) {
          if(i & 1 << j) {
            t *= p[j];
            odd = !odd;
          }
        }
        e.emplace_back(t, odd);
      }

      vector<pair<ll, T>> ret;
      for(auto &i : div) {
        T r = 0, tmp;
        ll K = k / i, N = n / i, cnt;
        for(auto &[t, odd] : e) {
          if(K % t) { continue; }
          cnt = N / t;
          if(!Sum) { tmp = cnt; }
          else { tmp = T(cnt + 1) * cnt * t * i / 2; }
          r += odd ? -tmp : tmp;
        }
        ret.emplace_back(i, r);
      }
      return ret;
    }
    """

  'gcdcnt':
    'prefix':'gcdcnt'
    'body':'GCDcnt($1,$2)'

  'bit':
    'prefix':'bit'
    'body':'${1:i}>>${2:j}&1'

  'nbit':
    'prefix':'nbit'
    'body':'~${1:i}>>${2:j}&1'

  'PrimeEnum':
    'prefix':'PrimeEnum'
    'body':"""
    vector<ll> PrimeEnum(ll n) {
      vector<bool> sieve(n / 3 + 1, true);
      for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {
        if(!sieve[i]) { continue; }
        for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }
      }
      vector<ll> ret = {2, 3};
      for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {
        if(sieve[i]) { ret.emplace_back(p); }
      }
      while(!ret.empty() && ret.back() > n) { ret.pop_back(); }
      return ret;
    }
    """

  'primeenum':
    'prefix':'primeenum'
    'body':'PrimeEnum($1)'

  'DivisorTransform':
    'prefix':'DivisorTransform'
    'body':"""
    vector<ll> PrimeEnum(ll n) {
      vector<bool> sieve(n / 3 + 1, true);
      for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {
        if(!sieve[i]) { continue; }
        for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }
      }
      vector<ll> ret = {2, 3};
      for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {
        if(sieve[i]) { ret.emplace_back(p); }
      }
      while(!ret.empty() && ret.back() > n) { ret.pop_back(); }
      return ret;
    }

    struct DivisorTransform {
      template<typename T> static void ZetaTransform(vector<T> &v) {
        const int n = v.size() - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = 1; i * p <= n; i++) { v[i * p] += v[i]; }
        }
      }
      template<typename T> static void MobiusTransform(vector<T> &v) {
        const int n = v.size() - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = n / p; i > 0; i--) { v[i * p] -= v[i]; }
        }
      }
      template<typename I, typename T> static void ZetaTransform(map<I, T> &m) {
        for(auto p = m.rbegin(); p != m.rend(); p++) {
          for(auto &x : m) {
            if(p->first == x.first) { break; }
            if(p->first % x.first == 0) { p->second += x.second; }
          }
        }
      }
      template<typename I, typename T> static void MobiusTransform(map<I, T> m) {
        for(auto &x : m) {
          for(auto p = m.rbegin(); p != m.rend(); p++) {
            if(x.first == p->first) { break; }
            if(p->first % x.first == 0) { p->second -= x.second; }
          }
        }
      }
    };
    """

  'MultipleTransform':
    'prefix':'MultipleTransform'
    'body':"""
    vector<ll> PrimeEnum(ll n) {
      vector<bool> sieve(n / 3 + 1, true);
      for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {
        if(!sieve[i]) { continue; }
        for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }
      }
      vector<ll> ret = {2, 3};
      for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {
        if(sieve[i]) { ret.emplace_back(p); }
      }
      while(!ret.empty() && ret.back() > n) { ret.pop_back(); }
      return ret;
    }

    struct MultipleTransform {
      template<typename T> static void ZetaTransform(vector<T> &v) {
        const int n = v.size() - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = n / p; i > 0; i--) { v[i] += v[i * p]; }
        }
      }
      template<typename T> static void MobiusTransform(vector<T> &v) {
        const int n = v.size() - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = 1; i * p <= n; i++) { v[i] -= v[i * p]; }
        }
      }
      template<typename I, typename T> static void ZetaTransform(map<I, T> &m) {
        for(auto &x : m) {
          for(auto p = m.rbegin(); p->first != x.first; p++) {
            if(p->first % x.first == 0) { x.second += p->second; }
          }
        }
      }
      template<typename I, typename T> static void MobiusTransform(map<I, T> &m) {
        for(auto p1 = m.rbegin(); p1 != m.rend(); p1++) {
          for(auto p2 = m.rbegin(); p2 != p1; p2++) {
            if(p2->first % p1->first == 0) { p1->second -= p2.second; }
          }
        }
      }
    };
    """

  'GCD_convolution':
    'prefix':'GCD_convolution'
    'body':"""
    vector<ll> PrimeEnum(ll n) {
      vector<bool> sieve(n / 3 + 1, true);
      for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {
        if(!sieve[i]) { continue; }
        for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }
      }
      vector<ll> ret = {2, 3};
      for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {
        if(sieve[i]) { ret.emplace_back(p); }
      }
      while(!ret.empty() && ret.back() > n) { ret.pop_back(); }
      return ret;
    }

    struct MultipleTransform {
      template<typename T> static void ZetaTransform(vector<T> &v) {
        const int n = v.size() - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = n / p; i > 0; i--) { v[i] += v[i * p]; }
        }
      }
      template<typename T> static void MobiusTransform(vector<T> &v) {
        const int n = v.size() - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = 1; i * p <= n; i++) { v[i] -= v[i * p]; }
        }
      }
    };

    template<typename T> vector<T> GCD_convolution(const vector<T> &a, const vector<T> &b) {
      assert(a.size() == b.size());
      auto s = a, t = b;
      MultipleTransform::ZetaTransform(s);
      MultipleTransform::ZetaTransform(t);
      for(int i = 0; i < (int)a.size(); i++) { s[i] *= t[i]; }
      MultipleTransform::MobiusTransform(s);
      return s;
    }
    """

  'LCM_convolution':
    'prefix':'LCM_convolution'
    'body':"""
    vector<ll> PrimeEnum(ll n) {
      vector<bool> sieve(n / 3 + 1, true);
      for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {
        if(!sieve[i]) { continue; }
        for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }
      }
      vector<ll> ret = {2, 3};
      for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {
        if(sieve[i]) { ret.emplace_back(p); }
      }
      while(!ret.empty() && ret.back() > n) { ret.pop_back(); }
      return ret;
    }

    struct DivisorTransform {
      template<typename T> static void ZetaTransform(vector<T> &v) {
        const int n = v.size() - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = 1; i * p <= n; i++) { v[i * p] += v[i]; }
        }
      }
      template<typename T> static void MobiusTransform(vector<T> &v) {
        const int n = v.size() - 1;
        for(auto &p : PrimeEnum(n)) {
          for(ll i = n / p; i > 0; i--) { v[i * p] -= v[i]; }
        }
      }
    };

    template<typename T> vector<T> LCM_convolution(const vector<T> &a, const vector<T> &b) {
      assert(a.size() == b.size());
      auto s = a, t = b;
      DivisorTransform::ZetaTransform(s);
      DivisorTransform::ZetaTransform(t);
      for(int i = 0; i < (int)a.size(); i++) { s[i] *= t[i]; }
      DivisorTransform::MobiusTransform(s);
      return s;
    }
    """

  'chmax':
    'prefix':'chmax'
    'body':'$1=max($1,$2);$3'

  'chmin':
    'prefix':'chmin'
    'body':'$1=min($1,$2);$3'

  'BinaryTreePathCount':
    'prefix':'BinaryTreePathCount'
    'body':"""
    vector<mint> BinaryTreePathCount(ll n) {
      ll D = 63 - __builtin_clzll(n + 1), L = n - (1LL << D) + 1;
      vector<mint> cnt(130), bin(130, 1);
      for(ll i = 1; i < 130; i++) { bin[i] = bin[i] * 2; }
      map<ll, mint> memo[65][130];
      for(ll k = 0; k < 130; k++) {
        auto calc = [&](auto &&calc, ll d, ll l) -> mint {
          if(!d) { return 0; }
          if(memo[d][k].contains(l)) { return memo[d][k][l]; }
          mint r = 0;
          if(k < d) {
            r = bin[k];
            if(k >= 2) { r += bin[k - 2] * (k - 1); }
          }
          else if(k >= 2) { r += bin[k - 2] * max(0LL, d * 2 - k - 1); }
          ll t = 1LL << d - 1;
          if(l >= t) {
            r += calc(calc, d, 0) + calc(calc, d - 1, l - t);
            if(k == d) { r += l; }
            else if(k > d && k < d * 2) { r += l * bin[k - d - 1]; }
            else if(k == d * 2) { r += mint(t) * (l - t); }
          }
          else {
            r += calc(calc, d - 1, l) + calc(calc, d - 1, 0);
            if(k == d) { r += l; }
            else if(k > d && k < d * 2) { r += l * bin[k - d - 1]; }
          }
          return memo[d][k][l] = r;
        };
        cnt[k] = calc(calc, D, L);
      }
      return cnt;
    }
    """

  'binarytreepathcount':
    'prefix':'binarytreepathcount'
    'body':'BinaryTreePathCount($1)'

  's1':
    'prefix':'s1'
    'body':'string ${1:S}; cin>>${1:S};$2'

  's2':
    'prefix':'s2'
    'body':'string ${1:s},${2:t}; cin>>${1:s}>>${2:t};$3'

  'assign':
    'prefix':'assign'
    'body':'assign($1,$2);$3'

  'secsort':
    'prefix':'secsort'
    'body':'ranges::sort($1, {}, &pair<ll, ll>::second);$2'

  'Maxedge':
    'prefix':'Maxedge'
    'body':"""
    vector<vector<ll>> mx(n, vector<ll>(24, 0));
    auto DFS = [&](auto &&DFS, ll v, ll p, ll d) -> void {
      mx[v][0] = d;
      for(auto &[nv, w] : g[v]) {
        if(nv == p) { continue; }
        DFS(DFS, nv, v, w);
      }
    };
    DFS(DFS, 0, -1, 0);
    for(ll j = 0; j < 23; j++) {
      for(ll i = 0; i < n; i++) {
        ll nx = t.bl[i][j];
        if(nx != -1) { mx[i][j + 1] = max(mx[i][j], mx[nx][j]); }
      }
    }
    auto maxedge = [&](ll u, ll v) -> ll {
      ll l = t.lca(u, v);
      auto maxedge_lca = [&](ll v, ll l) {
        ll d = t.depth(v) - t.depth(l), r = 0;
        while(d) {
          ll tmp = __builtin_ctz(d);
          r = max(r, mx[v][tmp]);
          v = t.bl[v][tmp];
          d ^= 1 << tmp;
        }
        return r;
      };
      return max(maxedge_lca(v, l), maxedge_lca(u, l));
    };
    """

  'maxedge':
    'prefix':'maxedge'
    'body':'maxedge($1,$2)'

  'Minedge':
    'prefix':'Minedge'
    'body':"""
    vector<vector<ll>> mn(n, vector<ll>(24, 0));
    auto DFS = [&](auto &&DFS, ll v, ll p, ll d) -> void {
      mn[v][0] = d;
      for(auto &[nv, w] : g[v]) {
        if(nv == p) { continue; }
        DFS(DFS, nv, v, w);
      }
    };
    DFS(DFS, 0, -1, 0);
    for(ll j = 0; j < 23; j++) {
      for(ll i = 0; i < n; i++) {
        ll nx = t.bl[i][j];
        if(nx != -1) { mn[i][j + 1] = min(mn[i][j], mn[nx][j]); }
      }
    }
    auto minedge = [&](ll u, ll v) -> ll {
      ll l = t.lca(u, v);
      auto minedge_lca = [&](ll v, ll l) {
        ll d = t.depth(v) - t.depth(l), r = 1e18;
        while(d) {
          ll tmp = __builtin_ctz(d);
          r = min(r, mn[v][tmp]);
          v = t.bl[v][tmp];
          d ^= 1 << tmp;
        }
        return r;
      };
      return min(minedge_lca(v, l), minedge_lca(u, l));
    };
    """

  'minedge':
    'prefix':'minedge'
    'body':'minedge($1,$2)'

  'stable_sort':
    'prefix':'stable_sort'
    'body':'ranges::stable_sort($1);$2'

  'subset':
    'prefix':'subset'
    'body':'for(ll j = i; j > 0; j = (j - 1) & i) {$1}$2'

  'superset':
    'prefix':'superset'
    'body':'for(ll j = i; j < 1 << n; j = (j + 1) | i){$1}$2'

  'SupersetTransform':
    'prefix':'SupersetTransform'
    'body':"""
    struct SupersetTransform {
      template<typename T> static void ZetaTransform(vector<T> &v) {
        const int n = v.size();
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k] += v[j + k + i]; }
          }
        }
      }
      template<typename T> static void MobiusTransform(vector<T> &v) {
        const int n = v.size();
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k] -= v[j + k + i]; }
          }
        }
      }
    };
    """

  'AND_convolution':
    'prefix':'AND_convolution'
    'body':"""
    struct SupersetTransform {
      template<typename T> static void ZetaTransform(vector<T> &v) {
        const int n = v.size();
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k] += v[j + k + i]; }
          }
        }
      }
      template<typename T> static void MobiusTransform(vector<T> &v) {
        const int n = v.size();
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k] -= v[j + k + i]; }
          }
        }
      }
    };

    template<typename T> vector<T> AND_convolution(vector<T> a, vector<T> b) {
      const int n = a.size();
      assert(a.size() == b.size());
      assert(!(n & (n - 1)));
      SupersetTransform::ZetaTransform(a);
      SupersetTransform::ZetaTransform(b);
      for(int i = 0; i < n; i++) { a[i] *= b[i]; }
      SupersetTransform::MobiusTransform(a);
      return a;
    }
    """

  'SubsetTransform':
    'prefix':'SubsetTransform'
    'body':"""
    struct SubsetTransform {
      template<typename T> static void ZetaTransform(vector<T> &v) {
        const int n = v.size();
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k + i] += v[j + k]; }
          }
        }
      }
      template<typename T> static void MobiusTransform(vector<T> &v) {
        const int n = v.size();
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k + i] -= v[j + k]; }
          }
        }
      }
    };
    """

  'OR_convolution':
    'prefix':'OR_convolution'
    'body':"""
    struct SubsetTransform {
      template<typename T> static void ZetaTransform(vector<T> &v) {
        const int n = v.size();
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k + i] += v[j + k]; }
          }
        }
      }
      template<typename T> static void MobiusTransform(vector<T> &v) {
        const int n = v.size();
        for(int i = 1; i < n; i <<= 1) {
          for(int j = 0; j < n; j += i << 1) {
            for(int k = 0; k < i; k++) { v[j + k + i] -= v[j + k]; }
          }
        }
      }
    };

    template<typename T> vector<T> OR_convolution(vector<T> a, vector<T> b) {
      const int n = a.size();
      assert(a.size() == b.size());
      assert(!(n & (n - 1)));
      SubsetTransform::ZetaTransform(a);
      SubsetTransform::ZetaTransform(b);
      for(int i = 0; i < n; i++) { a[i] *= b[i]; }
      SubsetTransform::MobiusTransform(a);
      return a;
    }
    """

  'WalshHadamardTransform':
    'prefix':'WalshHadamardTransform'
    'body':"""
    template<typename T> void WalshHadamardTransform(vector<T> &v, bool inv) {
      const int n = v.size();
      for(int i = 1; i < n; i <<= 1) {
        for(int j = 0; j < n; j += i << 1) {
          for(int k = 0; k < i; k++) {
            T s = v[j + k], t = v[j + k + i];
            v[j + k] = s + t;
            v[j + k + i] = s - t;
          }
        }
      }
      if(inv) {
        T inv_n = T(1) / n;
        for(auto &x : v) { x *= inv_n; }
      }
    }
    """

  'XOR_convolution':
    'prefix':'XOR_convolution'
    'body':"""
    template<typename T> void WalshHadamardTransform(vector<T> &v, bool inv) {
      const int n = v.size();
      for(int i = 1; i < n; i <<= 1) {
        for(int j = 0; j < n; j += i << 1) {
          for(int k = 0; k < i; k++) {
            T s = v[j + k], t = v[j + k + i];
            v[j + k] = s + t;
            v[j + k + i] = s - t;
          }
        }
      }
      if(inv) {
        T inv_n = T(1) / n;
        for(auto &x : v) { x *= inv_n; }
      }
    }

    template<typename T> vector<T> XOR_convolution(vector<T> a, vector<T> b) {
      const int n = a.size();
      assert(a.size() == b.size());
      assert(!(n & (n - 1)));
      WalshHadamardTransform(a, false);
      WalshHadamardTransform(b, false);
      for(int i = 0; i < n; i++) { a[i] *= b[i]; }
      WalshHadamardTransform(a, true);
      return a;
    }
    """

  'mymin':
    'prefix':'mymin'
    'body':'*ranges::min_element($1,[&](auto x,auto y){return $2;});$3 // condition to get x'

  'CommonInterval':
    'prefix':'CommonInterval'
    'body':'ll CommonInterval(pair<ll, ll> x, pair<ll, ll> y) { return max(min(x.second, y.second) - max(x.first, y.first) + 1, 0LL); }'

  'LongestCommonInterval':
    'prefix':'LongestCommonInterval'
    'body':"""
    template<typename T> T LCI(vector<pair<T, T>> v) {
      const int n = v.size();
      ranges::sort(v);
      T m = v[0].second, r = 0;
      for(ll i = 1; i < n; i++) {
        r = max(r, min(m, v[i].second) - v[i].first);
        m = max(m, v[i].second);
      }
      return r;
    }
    """

  'ShortestCommonInterval':
    'prefix':'ShortestCommonInterval'
    'body':"""
    template<typename T> vector<T> SCI(vector<pair<T, T>> &v) {
      auto CI = [](pair<T, T> x, pair<T, T> y) { return max(min(x.second, y.second) - max(x.first, y.first) + 1, 0LL); };
      pair<T, T> l, r, p;
      l = *ranges::min_element(v, [&](auto x, auto y) { return x.first > y.first; });
      r = *ranges::min_element(v, [&](auto x, auto y) { return x.second < y.second; });
      p = *ranges::min_element(v, [&](auto x, auto y) { return x.second - x.first < y.second - y.first; });

      vector<T> sci;
      for(auto &i : v) { sci.emplace_back(min({CI(i, l), CI(i, r), CI(i, p)})); }
      return sci;
    }
    """

  'count_if':
    'prefix':'count_if'
    'body':'ranges::count_if($1,[&](auto x){return $2;})'

  'MEX':
    'prefix':'MEX'
    'body':"""
    struct MEX {
      set<pair<ll, ll>> s;
      MEX() {
        s.emplace(-1e18, -1e18);
        s.emplace(1e18, 1e18);
      }
      bool contains(ll x) const {
        auto it = prev(s.lower_bound({x + 1, x + 1}));
        auto [l, r] = *it;
        return l <= x && x <= r;
      }
      bool insert(ll x) {
        auto nit = s.lower_bound({x + 1, x + 1}), it = prev(nit);
        auto [l, r] = *it;
        auto [nl, nr] = *nit;
        if(l <= x && x <= r) { return false; }
        if(r == x - 1) {
          if(nl == x + 1) {
            s.erase(it);
            s.erase(nit);
            s.emplace(l, nr);
          }
          else {
            s.erase(it);
            s.emplace(l, x);
          }
        }
        else {
          if(nl == x + 1) {
            s.erase(nit);
            s.emplace(x, nr);
          }
          else { s.emplace(x, x); }
        }
        return true;
      }
      void erase(ll x) {
        auto it = prev(s.lower_bound({x + 1, x + 1}));
        auto [l, r] = *it;
        s.erase(it);
        if(l != x) { s.emplace(l, x - 1); }
        if(r != x) { s.emplace(x + 1, r); }
      }
      ll query(ll x = 0) const {
        auto [l, r] = *prev(s.lower_bound({x + 1, x + 1}));
        return l <= x && x <= r ? r + 1 : x;
      }
    } mex;
    """

  'SlopeTrick':
    'prefix':'SlopeTrick'
    'body':"""
    struct SlopeTrick {
      ll min_f, add_l, add_r;
      priority_queue<ll> L;
      priority_queue<ll, vector<ll>, greater<ll>> R;

     private:
      void push_R(const ll &a) { R.emplace(a - add_r); }
      ll top_R() const { return R.empty() ? 1e18 : R.top() + add_r; }
      ll pop_R() {
        ll val = top_R();
        if(!R.empty()) { R.pop(); }
        return val;
      }
      void push_L(const ll &a) { L.emplace(a - add_l); }
      ll top_L() const { return L.empty() ? -1e18 : L.top() + add_l; }
      ll pop_L() {
        ll val = top_L();
        if(!L.empty()) { L.pop(); }
        return val;
      }
      size_t size() { return L.size() + R.size(); }

     public:
      SlopeTrick(): min_f(0), add_l(0), add_r(0) {}
      struct Query {
        ll lx, rx, min_f;
      };
      Query query() const { return (Query){top_L(), top_R(), min_f}; }
      void add_all(const ll &a) { min_f += a; }
      void add_a_x(const ll &a) {
        min_f += max(0LL, a - top_R());
        push_R(a);
        push_L(pop_R());
      }
      void add_x_a(const ll &a) {
        min_f += max(0LL, top_L() - a);
        push_L(a);
        push_R(pop_L());
      }
      void add_abs(const ll &a) {
        add_a_x(a);
        add_x_a(a);
      }
      void clear_right() {
        while(!R.empty()) { R.pop(); }
      }
      void clear_left() {
        while(!L.empty()) { L.pop(); }
      }
      void shift(const ll &a, const ll &b) {
        assert(a <= b);
        add_l += a;
        add_r += b;
      }
      void shift(const ll &a) { shift(a, a); }
      ll get(const ll &x) {
        ll r = min_f;
        while(!L.empty()) { r += max(0LL, pop_L() - x); }
        while(!R.empty()) { r += max(0LL, x - pop_R()); }
        return r;
      }
      void merge(SlopeTrick &st) {
        if(st.size() > size()) {
          swap(st.L, L);
          swap(st.R, R);
          swap(st.add_l, add_l);
          swap(st.add_r, add_r);
          swap(st.min_f, min_f);
        }
        while(!st.R.empty()) { add_x_a(st.pop_R()); }
        while(!st.L.empty()) { add_a_x(st.pop_L()); }
        min_f += st.min_f;
      }
    }st;
    // https://ei1333.github.io/library/structure/others/slope-trick.hpp
    """

  'slopetrick':
    'prefix':'slopetrick'
    'body':'SlopeTrick st;'

  'Root':
    'prefix':'Root'
    'body':"""
    uint64_t Root(uint64_t a, int k=2) {
      if(a <= 1 || k == 1) { return a; }
      if(k >= 64) { return 1; }
      auto check = [&](__uint128_t n) {
        __uint128_t x = 1, m = n;
        for(ll p = k; p; p >>= 1, m *= m) {
          if(p & 1) { x *= m; }
        }
        return x <= a;
      };
      uint64_t n = powl(a, (long double)(1.0) / k);
      while(!check(n)) { --n; }
      while(check(n + 1)) { ++n; }
      return n;
    }
    """

  'root':
    'prefix':'root'
    'body':'Root($1,$2)'

  'Interval':
    'prefix':'Interval'
    'body':"""
    struct Interval {
      set<pair<ll, ll>> s;
      ll cnt;
      Interval(): cnt(0) {
        s.emplace(-1e18, -1e18);
        s.emplace(1e18, 1e18);
      }
      bool contains(ll l, ll r) const {
        assert(l <= r);
        auto [L, R] = *prev(s.lower_bound({l + 1, l + 1}));
        return L <= l && r <= R;
      }
      bool contains(ll x) const { return contains(x, x); }
      pair<ll, ll> covered_by(ll l, ll r) const {
        assert(l <= r);
        auto [L, R] = *prev(s.lower_bound({l + 1, l + 1}));
        if(L <= l && r <= R) { return {L, R}; }
        return {-1e18, -1e18};
      }
      pair<ll, ll> covered_by(ll x) const { return covered_by(x, x); }
      ll insert(ll l, ll r) {
        assert(l <= r);
        auto it = prev(s.lower_bound({l + 1, l + 1}));
        if(it->first <= l && r <= it->second) { return 0; }
        ll sum_erased = 0;
        if(it->first <= l && l <= it->second + 1) {
          l = it->first;
          sum_erased += it->second - it->first + 1;
          it = s.erase(it);
        }
        else it = next(it);
        while(r > it->second) {
          sum_erased += it->second - it->first + 1;
          it = s.erase(it);
        }
        if(it->first - 1 <= r && r <= it->second) {
          sum_erased += it->second - it->first + 1;
          r = it->second;
          s.erase(it);
        }
        s.emplace(l, r);
        cnt += r - l + 1 - sum_erased;
        return r - l + 1 - sum_erased;
      }
      ll insert(ll x) {
        auto nit = s.lower_bound({x + 1, x + 1}), it = prev(nit);
        auto [l, r] = *it;
        auto [nl, nr] = *nit;
        if(l <= x && x <= r) { return 0; }
        if(r == x - 1) {
          if(nl == x + 1) {
            s.erase(it);
            s.erase(nit);
            s.emplace(l, nr);
          }
          else {
            s.erase(it);
            s.emplace(l, x);
          }
        }
        else {
          if(nl == x + 1) {
            s.erase(nit);
            s.emplace(x, nr);
          }
          else { s.emplace(x, x); }
        }
        cnt++;
        return 1;
      }
      ll erase(ll l, ll r) {
        assert(l <= r);
        auto it = prev(s.lower_bound({l + 1, l + 1}));
        if(it->first <= l && r <= it->second) {
          if(it->first < l) { s.emplace(it->first, l - 1); }
          if(r < it->second) { s.emplace(r + 1, it->second); }
          s.erase(it);
          cnt -= r - l + 1;
          return r - l + 1;
        }
        ll ret = 0;
        if(it->first <= l && l <= it->second) {
          ret += it->second - l + 1;
          if(it->first < l) { s.emplace(it->first, l - 1); }
          it = s.erase(it);
        }
        else it = next(it);
        while(it->second <= r) {
          ret += it->second - it->first + 1;
          it = s.erase(it);
        }
        if(it->first <= r && r <= it->second) {
          ret += r - it->first + 1;
          if(r < it->second) { s.emplace(r + 1, it->second); }
          s.erase(it);
        }
        cnt -= ret;
        return ret;
      }
      ll erase(ll x) {
        auto it = prev(s.lower_bound({x + 1, x + 1}));
        auto [l, r] = *it;
        if(!(l <= x && x <= r)) { return 0; }
        s.erase(it);
        if(l != x) { s.emplace(l, x - 1); }
        if(r != x) { s.emplace(x + 1, r); }
        cnt--;
        return 1;
      }
      int size() const { return (int)s.size() - 2; }
      ll count() const { return cnt; }
      ll mex(ll x = 0) const {
        auto [l, r] = *prev(s.lower_bound({x + 1, x + 1}));
        return l <= x && x <= r ? r + 1 : x;
      }
      bool same(ll x, ll y) const {
        auto ix = covered_by(x).first, iy = covered_by(y).first;
        return ix == iy && ix != -1e18;
      }
      void dump() const {
        for(auto &[l, r] : s) {
          if(l == -1e18 || r == 1e18) { continue; }
          cout << "[" << l << ", " << r << "] ";
        }
        cout << "\\\\n";
      }
    } I;

    /*
    bool contains(l,r)/(x) : return if [l,r]/x is covered
    pi covered_by(l,r)/(x) : return interval [l,r]/x is covered or {-1e18,-1e18}
    ll insert(l,r)/(x)     : insert [l,r]/x, return Δcnt
    ll erase(l,r)/(x)      : erase(l,r)/x, return -Δcnt
    int size()             : return the number of interval
    ll count()             : return the number of integer contained
    ll mex(x = 0)          : return mex[x, inf)
    bool same(x,y)         : return if x and y are covered by same interval
    void dump()            : debug
    */
    """

  'unsigned long long':
    'prefix':'ull'
    'body':'unsigned long long'

  'Time':
    'prefix':'Time'
    'body':"""
    struct Time {
      int lim;
      bool start;
      chrono::system_clock::time_point t;
      Time(int lim): lim(lim), start(false){};
      long double operator()(bool output = true) {
        if(!start) {
          t = chrono::system_clock::now();
          start = true;
          return 0;
        }
        auto d = chrono::system_clock::now() - t;
        auto msec = chrono::duration_cast<chrono::milliseconds>(d).count();
        if(output) {
          cerr << "\\\\n-------------------------------\\\\n";
          if(msec <= lim) {
            cerr << "[\\\\033[36mi\\\\033[m] ";
            cerr << "\\\\033[36mExecution Time : " << msec << " ms\\\\033[m\\\\n";
          }
          else {
            cerr << "[\\\\033[33m!\\\\033[m] ";
            cerr << "\\\\033[33mExecution Time : " << msec << " ms\\\\033[m\\\\n";
          }
          cerr << "-------------------------------\\\\n";
        }
        return msec;
      }
    } Time(2000);
    """

  'RollingHash':
    'prefix':'RollingHash'
    'body':"""
    struct Modint2_61 {
      static constexpr unsigned long long MOD = (1ULL << 61) - 1;
      unsigned long long x;
      constexpr Modint2_61(): x(0ULL) {}
      constexpr Modint2_61(unsigned long long y): x(y >= MOD ? y - MOD : y) { assert(y < MOD * 2); }
      unsigned long long val() const noexcept { return x; }
      Modint2_61 operator-() const { return Modint2_61(MOD - x); }
      Modint2_61 operator+(const Modint2_61 &a) const { return Modint2_61(x + a.x); }
      Modint2_61 operator-(const Modint2_61 &a) const { return Modint2_61(x + MOD - a.x); }
      Modint2_61 operator*(const Modint2_61 &a) const {
        __uint128_t r = __uint128_t(x) * a.x;
        r = (r >> 61) + (r & MOD);
        return Modint2_61(r);
      }
      Modint2_61 operator/(const Modint2_61 &a) const { return *this * a.inv(); }
      Modint2_61 pow(ll n) const {
        if(n < 0) { return inv().pow(-n); }
        Modint2_61 r(1), t = *this;
        while(n) {
          if(n & 1) { r *= t; }
          t *= t;
          n >>= 1;
        }
        return r;
      }
      Modint2_61 inv() const { return pow(MOD - 2); }
      Modint2_61 &operator+=(const Modint2_61 &a) { return *this = *this + a; }
      Modint2_61 &operator-=(const Modint2_61 &a) { return *this = *this - a; }
      Modint2_61 &operator*=(const Modint2_61 &a) { return *this = *this * a; }
      Modint2_61 &operator/=(const Modint2_61 &a) { return *this = *this / a; }
      template<typename T> friend Modint2_61 operator+(T a, const Modint2_61 &b) { return (Modint2_61(a) += b); }
      template<typename T> friend Modint2_61 operator-(T a, const Modint2_61 &b) { return (Modint2_61(a) -= b); }
      template<typename T> friend Modint2_61 operator*(T a, const Modint2_61 &b) { return (Modint2_61(a) *= b); }
      template<typename T> friend Modint2_61 operator/(T a, const Modint2_61 &b) { return (Modint2_61(a) /= b); }
      explicit operator bool() const { return x; }
      bool operator==(const Modint2_61 &a) const { return (x == a.x); }
      bool operator!=(const Modint2_61 &a) const { return (x != a.x); }
      bool operator<(const Modint2_61 &a) const { return x < a.x; }  // to use map
      friend ostream &operator<<(ostream &os, const Modint2_61 &a) { return os << a.x; }
    };

    using mint = Modint2_61;
    const unsigned long long base = chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now().time_since_epoch()).count() % Modint2_61::MOD;
    struct RollingHash {
      vector<mint> hashed, power;
      int n;
      RollingHash(){}
      RollingHash(const string &s): n(ssize(s)) {
        hashed.assign(n + 1, 0);
        power.assign(n + 1, 0);
        power[0] = 1;
        for(ll i = 0; i < n; i++) {
          power[i + 1] = power[i] * base;
          hashed[i + 1] = hashed[i] * base + s[i];
        }
      }
      mint hash(ll l, ll r) const {
        return hashed[r] - hashed[l] * power[r - l];
      }
      static mint hash(const string &s) {
        mint r = 0;
        for(auto &i : s) { r = r * base + i; }
        return r;
      }
      mint connect(mint h1, mint h2, ll h2len) const {
        return h1 * power[h2len] + h2;
      }
      void connect(const string &s) {
        ll m = ssize(s);
        hashed.resize(n + m + 1);
        power.resize(n + m + 1);
        for(ll i = n; i < n + m; i++) {
          power[i + 1] = power[i] * base;
          hashed[i + 1] = hashed[i] * base + s[i - n];
        }
      }
      int find(string &s, int lhs = 0) const {
        mint h = hash(s);
        for(int i = lhs; i <= n - ssize(s); i++) {
          if(h == hash(i, i + ssize(s))) { return i; }
        }
        return -1;
      }
      ll LCP(const RollingHash &b, ll l1, ll r1, ll l2, ll r2) {
        ll len = min(r1 - l1, r2 - l2);
        ll low = -1, high = len + 1;
        while(high - low > 1) {
          ll mid = (low + high) / 2;
          if(hash(l1, l1 + mid) == b.hash(l2, l2 + mid)) { low = mid; }
          else { high = mid; }
        }
        return low;
      }
    };
    // https://github.com/tatyam-prime/kyopro_library/blob/master/RollingHash.cpp
    // https://nyaannyaan.github.io/library/string/rolling-hash.hpp (hash(string),find)
    """

  'Modint2_61':
    'prefix':'Modint2_61'
    'body':"""
    struct Modint2_61 {
      static constexpr unsigned long long MOD = (1ULL << 61) - 1;
      unsigned long long x;
      constexpr Modint2_61(): x(0ULL) {}
      constexpr Modint2_61(unsigned long long y): x(y >= MOD ? y - MOD : y) { assert(y < MOD * 2); }
      unsigned long long val() const noexcept { return x; }
      Modint2_61 operator-() const { return Modint2_61(MOD - x); }
      Modint2_61 operator+(const Modint2_61 &a) const { return Modint2_61(x + a.x); }
      Modint2_61 operator-(const Modint2_61 &a) const { return Modint2_61(x + MOD - a.x); }
      Modint2_61 operator*(const Modint2_61 &a) const {
        __uint128_t r = __uint128_t(x) * a.x;
        r = (r >> 61) + (r & MOD);
        return Modint2_61(r);
      }
      Modint2_61 operator/(const Modint2_61 &a) const { return *this * a.inv(); }
      Modint2_61 pow(ll n) const {
        if(n < 0) { return inv().pow(-n); }
        Modint2_61 r(1), t = *this;
        while(n) {
          if(n & 1) { r *= t; }
          t *= t;
          n >>= 1;
        }
        return r;
      }
      Modint2_61 inv() const { return pow(MOD - 2); }
      Modint2_61 &operator+=(const Modint2_61 &a) { return *this = *this + a; }
      Modint2_61 &operator-=(const Modint2_61 &a) { return *this = *this - a; }
      Modint2_61 &operator*=(const Modint2_61 &a) { return *this = *this * a; }
      Modint2_61 &operator/=(const Modint2_61 &a) { return *this = *this / a; }
      template<typename T> friend Modint2_61 operator+(T a, const Modint2_61 &b) { return (Modint2_61(a) += b); }
      template<typename T> friend Modint2_61 operator-(T a, const Modint2_61 &b) { return (Modint2_61(a) -= b); }
      template<typename T> friend Modint2_61 operator*(T a, const Modint2_61 &b) { return (Modint2_61(a) *= b); }
      template<typename T> friend Modint2_61 operator/(T a, const Modint2_61 &b) { return (Modint2_61(a) /= b); }
      explicit operator bool() const { return x; }
      bool operator==(const Modint2_61 &a) const { return (x == a.x); }
      bool operator!=(const Modint2_61 &a) const { return (x != a.x); }
      bool operator<(const Modint2_61 &a) const { return x < a.x; }  // to use map
      friend ostream &operator<<(ostream &os, const Modint2_61 &a) { return os << a.x; }
    };

    using mint=Modint2_61;
    const unsigned long long base = chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now().time_since_epoch()).count() % Modint2_61::MOD;
    """

  'gcd':
    'prefix':'gcd'
    'body':'gcd($1,$2)'

  'lcm':
    'prefix':'lcm'
    'body':'lcm($1,$2)'

  'Segtree2D':
    'prefix':'Segtree2D'
    'body':"""
    template<typename S, auto op, auto e> struct SegTree2D {
     private:
      vector<S> seg;
      bool built;
      int id(int x, int y) const { return x * 2 * W + y; }
      S inner_prod(int x, int ly, int ry) {
        S res = e();
        for(; ly < ry; ly >>= 1, ry >>= 1) {
          if(ly & 1) { res = op(res, seg[id(x, ly)]), ly++; }
          if(ry & 1) { --ry, res = op(res, seg[id(x, ry)]); }
        }
        return res;
      }

     public:
      int H, W;
      SegTree2D(int x, int y): built(false) {
        H = W = 1;
        while(H < x) { H <<= 1; }
        while(W < y) { W <<= 1; }
        seg.assign(4 * H * W, e());
      }
      void set(int x, int y, const S &s) {
        if(!built) { seg[id(x + H, y + W)] = s; }
        else {
          x += H, y += W;
          seg[id(x, y)] = s;
          for(int i = x >> 1; i; i >>= 1) { seg[id(i, y)] = op(seg[id(2 * i, y)], seg[id(2 * i + 1, y)]); }
          for(; x; x >>= 1) {
            for(int j = y >> 1; j; j >>= 1) { seg[id(x, j)] = op(seg[id(x, 2 * j)], seg[id(x, 2 * j + 1)]); }
          }
        }
      }
      void build() {
        built = true;
        for(int y = W; y < 2 * W; y++) {
          for(int x = H - 1; x; x--) { seg[id(x, y)] = op(seg[id(2 * x, y)], seg[id(2 * x + 1, y)]); }
        }
        for(int x = 0; x < 2 * H; x++) {
          for(int y = W - 1; y; y--) { seg[id(x, y)] = op(seg[id(x, 2 * y)], seg[id(x, 2 * y + 1)]); }
        }
      }
      S get(int x, int y) const { return seg[id(x + H, y + W)]; }
      S operator()(int x, int y) const { return seg[id(x + H, y + W)]; }
      S prod(int lx, int rx, int ly, int ry) {
        if(lx >= rx || ly >= ry) { return e(); }
        S res = e();
        lx += H, rx += H, ly += W, ry += W;
        for(; lx < rx; lx >>= 1, rx >>= 1) {
          if(lx & 1) { res = op(res, inner_prod(lx, ly, ry)), lx++; }
          if(rx & 1) { --rx, res = op(res, inner_prod(rx, ly, ry)); }
        }
        return res;
      }
      S operator()(int lx, int rx, int ly, int ry) { return prod(lx, rx, ly, ry); }
    };
    """

  'segtree2D':
    'prefix':'segtree2D'
    'body':'SegTree2D<S,op,e> seg(${1:h},${2:w});'

  'BSGS':
    'prefix':'BSGS'
    'body':"""
    template<typename T> ll BSGS(T s, T g, ll n, ll m, const auto &f, const auto &fm) {
      unordered_map<T, int> mp;
      for(int i = 1; i <= m; i++) {
        g = f(g);
        mp[g] = -i;
      }
      for(int i = 1;; i++) {
        s = fm(s);
        if(mp.count(s)) { return m * i + mp[s]; }
        if(n <= m * i) { return -1; }
      }
    }
    """

  'C++17':
    'prefix':'C++17'
    'body':"""
    #if __cplusplus <= 201703L
    #define ssize(v) ((int)(v).size())
    template<typename T> ll bit_ceil(T n) {
      ll r = 1;
      while(r < n) { r <<= 1; }
      return r;
    }
    template<typename T> ll bit_width(T n) { return 64 - __builtin_clzll(n); }
    template<typename T> ll countr_zero(T n) { return __builtin_ctzll(n); }
    template<typename T> ll popcount(T n) { return __builtin_popcountll(n); }
    namespace ranges {
    template<typename T> void sort(vector<T> &v) { sort(v.begin(), v.end()); }
    template<typename T> void stable_sort(vector<T> &v) { stable_sort(v.begin(), v.end()); }
    template<typename T, typename F> void sort(vector<T> &v, const F &f) { sort(v.begin(), v.end(), f); }
    template<typename T> void reverse(vector<T> &v) { reverse(v.begin(), v.end()); }
    template<typename T> T max(const vector<T> &v) { return *max_element(v.begin(), v.end()); }
    template<typename T> T min(const vector<T> &v) { return *min_element(v.begin(), v.end()); }
    template<typename T, typename U> bool binary_search(const vector<T> &v, U x) { return binary_search(v.begin(), v.end(), x); }
    template<typename T, typename F> bool all_of(const vector<T> &v, const F &f) { return all_of(v.begin(), v.end(), f); }
    template<typename T, typename F> bool any_of(const vector<T> &v, const F &f) { return any_of(v.begin(), v.end(), f); }
    template<typename T, typename F> bool none_of(const vector<T> &v, const F &f) { return none_of(v.begin(), v.end(), f); }
    template<typename T, typename F> int count_if(const vector<T> &v, const F &f) { return count_if(v.begin(), v.end(), f); }
    template<typename T, typename U> auto lower_bound(const vector<T> &v, U x) { return lower_bound(v.begin(), v.end(), x); }
    template<typename T, typename U> auto upper_bound(const vector<T> &v, U x) { return upper_bound(v.begin(), v.end(), x); }
    template<typename T> auto max_element(const vector<T> &v) { return max_element(v.begin(), v.end()); }
    template<typename T> auto min_element(const vector<T> &v) { return min_element(v.begin(), v.end()); }
    template<typename T, typename U> void fill(vector<T> &v, U x) { fill(v.begin(), v.end(), x); }
    }  // namespace ranges
    #endif
    """

  'SubsetConvolution':
    'prefix':'SubsetConvolution'
    'body':"""
    template<int S> struct SubsetConvolution {
      using fps = array<mint, S + 1>;
      static constexpr int s = S;
      vector<int> pc;
      SubsetConvolution(): pc(1 << s) {
        for(int i = 1; i < (1 << s); i++) { pc[i] = pc[i - (i & -i)] + 1; }
      }
      void add(fps &l, const fps &r, int d) {
        for(int i = 0; i < d; ++i) { l[i] += r[i]; }
      }
      void sub(fps &l, const fps &r, int d) {
        for(int i = d; i <= s; ++i) { l[i] -= r[i]; }
      }
      void zeta(vector<fps> &a) {
        int n = a.size();
        for(int w = 1; w < n; w *= 2) {
          for(int k = 0; k < n; k += w * 2) {
            for(int i = 0; i < w; ++i) { add(a[k + w + i], a[k + i], pc[k + w + i]); }
          }
        }
      }
      void mobius(vector<fps> &a) {
        int n = a.size();
        for(int w = n >> 1; w; w >>= 1) {
          for(int k = 0; k < n; k += w * 2) {
            for(int i = 0; i < w; ++i) { sub(a[k + w + i], a[k + i], pc[k + w + i]); }
          }
        }
      }
      vector<fps> lift(const vector<mint> &a) {
        vector<fps> A(a.size());
        for(int i = 0; i < (int)a.size(); i++) {
          ranges::fill(A[i], 0);
          A[i][pc[i]] = a[i];
        }
        return A;
      }
      vector<mint> unlift(const vector<fps> &A) {
        vector<mint> a(A.size());
        for(int i = 0; i < (int)A.size(); i++) { a[i] = A[i][pc[i]]; }
        return a;
      }
      void prod(vector<fps> &A, const vector<fps> &B) {
        int n = A.size(), d = __builtin_ctz(n);
        for(int i = 0; i < n; i++) {
          fps c{};
          for(int j = 0; j <= d; j++) {
            for(int k = 0; k <= d - j; k++) { c[j + k] += A[i][j] * B[i][k]; }
          }
          A[i].swap(c);
        }
      }
      vector<mint> multiply(const vector<mint> &a, const vector<mint> &b) {
        vector<fps> A = lift(a), B = lift(b);
        zeta(A), zeta(B);
        prod(A, B);
        mobius(A);
        return unlift(A);
      }
    };
    // https://nyaannyaan.github.io/library/set-function/subset-convolution.hpp.html
    """

  'BlockCutTree':
    'prefix':'BlockCutTree'
    'body':"""
    struct Lowlink {
     private:
      int dfs(int idx, int k, int par) {
        low[idx] = (ord[idx] = k++);
        int cnt = 0;
        bool arti = false, second = false;
        for(auto &to : g[idx]) {
          if(ord[to] == -1) {
            cnt++;
            k = dfs(to, k, idx);
            low[idx] = min(low[idx], low[to]);
            arti |= (par != -1) && (low[to] >= ord[idx]);
            if(ord[idx] < low[to]) { bridge.emplace_back(minmax(idx, to)); }
          }
          else if(to != par || second) { low[idx] = min(low[idx], ord[to]); }
          else { second = true; }
        }
        arti |= par == -1 && cnt > 1;
        if(arti) { articulation.emplace_back(idx); }
        return k;
      }

     public:
      const vector<vector<int>> g;
      int N;
      vector<int> ord, low;
      vector<int> articulation;
      vector<pair<int, int>> bridge;
      Lowlink(const vector<vector<int>> &g_): g(g_), N(g.size()), ord(N, -1), low(N, -1) {
        for(int i = 0, k = 0; i < N; i++) {
          if(ord[i] == -1) { k = dfs(i, k, -1); }
        }
      }
    };

    struct BiConnectedComponents : Lowlink {
     private:
      void build() {
        used.assign(this->g.size(), 0);
        for(int i = 0; i < ssize(used); i++) {
          if(!used[i]) { dfs(i, -1); }
        }
      }
      void dfs(int idx, int par) {
        used[idx] = true;
        for(auto &to : this->g[idx]) {
          if(to == par) { continue; }
          if(!used[to] || this->ord[to] < this->ord[idx]) { tmp.emplace_back(minmax<int>(idx, to)); }
          if(!used[to]) {
            dfs(to, idx);
            if(this->low[to] >= this->ord[idx]) {
              bc.emplace_back();
              while(true) {
                auto e = tmp.back();
                bc.back().emplace_back(e);
                tmp.pop_back();
                if(e.first == min<int>(idx, to) && e.second == max<int>(idx, to)) { break; }
              }
            }
          }
        }
      }

     public:
      vector<int> used;
      vector<vector<pair<int, int>>> bc;
      vector<pair<int, int>> tmp;
      BiConnectedComponents(const vector<vector<int>> &g): Lowlink(g) { build(); }
    };

    struct BlockCutTree {
     private:
      void build() {
        auto ar = bcc.articulation;
        idar.resize(g.size(), -1);
        idcc.resize(g.size(), -1);
        for(int i = 0; i < ssize(ar); i++) { idar[ar[i]] = i; }
        tree.resize(ar.size() + bcc.bc.size());
        vector<int> last(g.size(), -1);
        for(int i = 0; i < ssize(bcc.bc); i++) {
          vector<int> st;
          for(auto &[u, v] : bcc.bc[i]) {
            st.emplace_back(u);
            st.emplace_back(v);
          }
          for(auto &u : st) {
            if(idar[u] == -1) { idcc[u] = i + ar.size(); }
            else if(last[u] != i) {
              add(i + ar.size(), idar[u]);
              last[u] = i;
            }
          }
        }
      }
      void add(int i, int j) {
        if(i == -1 || j == -1) { return; }
        tree[i].emplace_back(j);
        tree[j].emplace_back(i);
      }

     public:
      const vector<vector<int>> &g;
      BiConnectedComponents bcc;
      vector<vector<int>> tree;
      vector<int> idar, idcc;
      BlockCutTree(const vector<vector<int>> &g): g(g), bcc(g) { build(); }

      vector<int> &operator[](int i) { return tree[i]; }
      int size() const { return tree.size(); }
      int id(int i) { return idar[i] == -1 ? idcc[i] : idar[i]; }
      bool is_arti(int i) { return idar[i] != -1; }
      int arti() const { return bcc.articulation.size(); }
    };
    """

  'SternBrocotTree':
    'prefix':'SternBrocotTree'
    'body':"""
    struct SternBrocotTree {
      using Node = SternBrocotTree;
      ll lx, ly, x, y, rx, ry;
      vector<ll> seq;
      SternBrocotTree(): lx(0), ly(1), x(1), y(1), rx(1), ry(0) {}
      SternBrocotTree(ll X, ll Y): SternBrocotTree() {
        assert(X >= 1 && Y >= 1);
        ll g = gcd(X, Y);
        X /= g, Y /= g;
        while(min(X, Y) > 0) {
          if(X > Y) {
            ll d = X / Y;
            X -= d * Y;
            go_right(d - (X == 0 ? 1 : 0));
          }
          else {
            ll d = Y / X;
            Y -= d * X;
            go_left(d - (Y == 0 ? 1 : 0));
          }
        }
      }
      SternBrocotTree(const pair<ll, ll> &xy): SternBrocotTree(xy.first, xy.second) {}
      SternBrocotTree(const vector<ll> &_seq): SternBrocotTree() {
        for(const ll &d : _seq) {
          assert(d != 0);
          if(d > 0) { go_right(d); }
          if(d < 0) { go_left(d); }
        }
        assert(seq == _seq);
      }

      pair<ll, ll> get() const { return make_pair(x, y); }
      pair<ll, ll> lower_bound() const { return make_pair(lx, ly); }
      pair<ll, ll> upper_bound() const { return make_pair(rx, ry); }
      ll depth() const {
        ll r = 0;
        for(auto &s : seq) { r += abs(s); }
        return r;
      }
      void go_left(ll d = 1) {
        if(d <= 0) { return; }
        if(seq.empty() || seq.back() > 0) { seq.emplace_back(0); }
        seq.back() -= d;
        rx += lx * d, ry += ly * d;
        x = rx + lx, y = ry + ly;
      }
      void go_right(ll d = 1) {
        if(d <= 0) { return; }
        if(seq.empty() || seq.back() < 0) { seq.emplace_back(0); }
        seq.back() += d;
        lx += rx * d, ly += ry * d;
        x = rx + lx, y = ry + ly;
      }
      bool go_parent(ll d = 1) {
        if(d <= 0) { return true; }
        while(d != 0) {
          if(seq.empty()) { return false; }
          ll d2 = min(d, abs(seq.back()));
          if(seq.back() > 0) {
            x -= rx * d2, y -= ry * d2;
            lx = x - rx, ly = y - ry;
            seq.back() -= d2;
          }
          else {
            x -= lx * d2, y -= ly * d2;
            rx = x - lx, ry = y - ly;
            seq.back() += d2;
          }
          d -= d2;
          if(seq.back() == 0) { seq.pop_back(); }
          if(d2 == 0) { break; }
        }
        return true;
      }
      static Node lca(const Node &lhs, const Node &rhs) {
        Node n;
        for(int i = 0; i < min<int>(lhs.seq.size(), rhs.seq.size()); i++) {
          ll val1 = lhs.seq[i], val2 = rhs.seq[i];
          if((val1 < 0) != (val2 < 0)) { break; }
          if(val1 < 0) { n.go_left(min(-val1, -val2)); }
          if(val1 > 0) { n.go_right(min(val1, val2)); }
          if(val1 != val2) { break; }
        }
        return n;
      }
      friend ostream &operator<<(ostream &os, const Node &rhs) {
        os << "\\\\n";
        os << "L : (" << rhs.lx << ", " << rhs.ly << " )\\\\n";
        os << "M : (" << rhs.x << ", " << rhs.y << " )\\\\n";
        os << "R : (" << rhs.rx << ", " << rhs.ry << " )\\\\n";
        os << "seq : {";
        for(auto &x : rhs.seq) { os << x << ", "; }
        os << "}\\\\n";
        return os;
      }
      friend bool operator<(const Node &lhs, const Node &rhs) { return lhs.x * rhs.y < rhs.x * lhs.y; }
      friend bool operator==(const Node &lhs, const Node &rhs) { return lhs.x == rhs.x && lhs.y == rhs.y; }
    };
    """

  'SternBrocotTree_BinarySearch':
    'prefix':'SternBrocotTree_BinarySearch'
    'body':"""
    pair<pair<ll, ll>, pair<ll, ll>> SternBrocotTree_BinarySearch(function<bool(pair<ll, ll>)> f, const ll &INF) {
      assert(INF >= 0);
      SternBrocotTree m;
      if(INF == 0) { return {m.lower_bound(), m.upper_bound()}; }
      auto over = [&](bool return_value) {
        return max(m.x, m.y) > INF || f(m.get()) == return_value;
      };
      if(f(make_pair(0, 1))) { return {m.lower_bound(), m.upper_bound()}; }
      ll go_left = over(true);
      for(; true; go_left ^= 1) {
        if(go_left) {
          ll a = 1;
          for(; true; a *= 2) {
            m.go_left(a);
            if(over(false)) {
              m.go_parent(a);
              break;
            }
          }
          for(a /= 2; a != 0; a /= 2) {
            m.go_left(a);
            if(over(false)) { m.go_parent(a); }
          }
          m.go_left();
          if(max(m.get().first, m.get().second) > INF) { return {m.lower_bound(), m.upper_bound()}; }
        }
        else {
          ll a = 1;
          for(; true; a *= 2) {
            m.go_right(a);
            if(over(true)) {
              m.go_parent(a);
              break;
            }
          }
          for(a /= 2; a != 0; a /= 2) {
            m.go_right(a);
            if(over(true)) { m.go_parent(a); }
          }
          m.go_right();
          if(max(m.get().first, m.get().second) > INF) { return {m.lower_bound(), m.upper_bound()}; }
        }
      }
    }
    """

  'CartesianTree':
    'prefix':'CartesianTree'
    'body':"""
    template<typename T> pair<vector<vector<int>>, int> CartesianTree(vector<T> &v) {
      int N = ssize(v);
      vector<vector<int>> g(N);
      vector<int> p(N, -1), st;
      st.reserve(N);
      for(int i = 0; i < N; i++) {
        int pre = -1;
        while(!st.empty() && v[i] < v[st.back()]) {
          pre = st.back();
          st.pop_back();
        }
        if(pre != -1) { p[pre] = i; }
        if(!st.empty()) { p[i] = st.back(); }
        st.emplace_back(i);
      }
      int root = -1;
      for(int i = 0; i < N; i++) {
        if(p[i] != -1) { g[p[i]].emplace_back(i); }
        else root = i;
      }
      return {g, root};
    }
    """

  'PrimeRange':
    'prefix':'PrimeRange'
    'body':"""
    vector<ll> PrimeEnum(ll n) {
      vector<bool> sieve(n / 3 + 1, true);
      for(ll p = 5, d = 4, i = 1, sq = sqrt(n); p <= sq; p += d = 6 - d, i++) {
        if(!sieve[i]) { continue; }
        for(ll q = p * p / 3, r = d * p / 3 + (d * p % 3 == 2), s = 2 * p, qe = ssize(sieve); q < qe; q += r = s - r) { sieve[q] = false; }
      }
      vector<ll> ret = {2, 3};
      for(ll p = 5, d = 4, i = 1; p <= n; p += d = 6 - d, i++) {
        if(sieve[i]) { ret.emplace_back(p); }
      }
      while(!ret.empty() && ret.back() > n) { ret.pop_back(); }
      return ret;
    }

    uint64_t Root(uint64_t a, int k = 2) {
      if(a <= 1 || k == 1) { return a; }
      if(k >= 64) { return 1; }
      auto check = [&](__uint128_t n) {
        __uint128_t x = 1, m = n;
        for(ll p = k; p; p >>= 1, m *= m) {
          if(p & 1) { x *= m; }
        }
        return x <= a;
      };
      uint64_t n = powl(a, (long double)(1.0) / k);
      while(!check(n)) { --n; }
      while(check(n + 1)) { ++n; }
      return n;
    }

    vector<vector<pair<ll, ll>>> PrimeRange(ll l, ll r) {
      int n = r - l + 1;
      vector<ll> v(n);
      iota(v.begin(), v.end(), l);
      vector<vector<pair<ll, ll>>> p(n);
      for(auto &i : PrimeEnum(Root(r))) {
        for(ll j = (l + i - 1) / i * i; j <= r; j += i) {
          int c = 0;
          while(v[j - l] % i == 0) {
            v[j - l] /= i;
            c++;
          }
          if(c) { p[j - l].emplace_back(i, c); }
        }
      }
      for(int i = 0; i < n; i++) {
        if(v[i] != 1) { p[i].emplace_back(v[i], 1); }
      }
      return p;
    }
    """

  'primerange':
    'prefix':'primerange'
    'body':'PrimeRange($1,$2)$3'

  'LinkCutTree':
    'prefix':'LinkCutTree'
    'body':"""
    template<typename T> struct LinkCutTree {
     public:
      struct node {
        int sz, sub1, sub2;
        T val, al, lazy, sum1, sum2;
        node *left, *right, *par;
        bool rev;
        node(const T _val): sz(1), sub1(1), sub2(0), val(_val), al(_val), lazy(0), sum1(_val), sum2(0), left(nullptr), right(nullptr), par(nullptr), rev(false) {}
        bool isRoot() const { return (!par) || (par->left != this && par->right != this); }
        void push() {
          if(lazy != 0) {
            val += lazy;
            al += lazy * sz;
            if(left) { left->lazy += lazy; }
            if(right) { right->lazy += lazy; }
            lazy = 0;
          }
          if(!rev) { return; }
          swap(left, right);
          if(left) { left->rev = !(left->rev); }
          if(right) { right->rev = !(right->rev); }
          rev = false;
        }
        void eval() {
          sz = 1;
          sub1 = sub2 + 1;
          al = val;
          sum1 = sum2 + val;
          if(left) {
            left->push();
            sz += left->sz;
            sub1 += left->sub1;
            al += left->al;
            sum1 += left->sum1;
          }
          if(right) {
            right->push();
            sz += right->sz;
            sub1 += right->sub1;
            al += right->al;
            sum1 += right->sum1;
          }
        }
      };

     private:
      void rotate(node *u, bool right) {
        node *p = u->par, *g = p->par;
        if(right) {
          if((p->left = u->right)) { u->right->par = p; }
          u->right = p;
          p->par = u;
        }
        else {
          if((p->right = u->left)) { u->left->par = p; }
          u->left = p;
          p->par = u;
        }
        p->eval();
        u->eval();
        u->par = g;
        if(!g) { return; }
        if(g->left == p) { g->left = u; }
        if(g->right == p) { g->right = u; }
        g->eval();
      }
      void splay(node *u) {
        while(!(u->isRoot())) {
          node *p = u->par, *gp = p->par;
          if(p->isRoot()) {
            p->push();
            u->push();
            rotate(u, (u == p->left));
          }
          else {
            gp->push();
            p->push();
            u->push();
            bool flag = (u == p->left);
            if((u == p->left) == (p == gp->left)) {
              rotate(p, flag);
              rotate(u, flag);
            }
            else {
              rotate(u, flag);
              rotate(u, !flag);
            }
          }
        }
        u->push();
      }
      node *access(node *u) {
        node *last = nullptr;
        for(node *v = u; v; v = v->par) {
          splay(v);
          if(v->right) {
            v->sub2 += v->right->sub1;
            v->sum2 += v->right->sum1;
          }
          v->right = last;
          if(v->right) {
            v->sub2 -= v->right->sub1;
            v->sum2 -= v->right->sum1;
          }
          v->eval();
          last = v;
        }
        splay(u);
        return last;
      }
      bool same(node *u, node *v) {
        access(u);
        access(v);
        return u == v || u->par;
      }
      void unite(node *u, node *v) {
        evert(u);
        access(v);
        u->par = v;
        v->sub2 += u->sub1;
        v->sum2 += u->sum1;
      }
      void cut(node *u) {
        access(u);
        u->left->par = nullptr;
        u->left = nullptr;
        u->eval();
      }
      void cut(node *u, node *v) {
        access(u);
        access(v);
        if(u->isRoot()) {
          v->sub2 -= u->sub1;
          v->sum2 -= u->sum1;
          u->par = nullptr;
        }
        else {
          v->left->par = nullptr;
          v->left = nullptr;
          v->eval();
        }
      }
      node *lca(node *u, node *v) {
        access(u);
        return access(v);
      }
      void evert(node *u) {
        access(u);
        u->rev = !(u->rev);
        u->push();
      }
      int depth(node *u) {
        access(u);
        return u->sz - 1;
      }
      void toRoot_range(node *u, const T x) {
        access(u);
        u->lazy += x;
        u->push();
      }
      T toRoot_query(node *u) {
        access(u);
        return u->al;
      }
      void range(node *u, node *v, const T x) {
        evert(u);
        access(v);
        v->lazy += x;
        v->push();
      }
      T query(node *u, node *v) {
        evert(u);
        access(v);
        return v->al;
      }
      int component_size(node *u) {
        evert(u);
        return u->sub1;
      }
      int subtree_size(node *u) {
        access(u);
        return u->sub2 + 1;
      }
      T component_query(node *u) {
        evert(u);
        return u->sum1;
      }
      T subtree_query(node *u) {
        access(u);
        return u->sum2 + u->val;
      }

     public:
      const int V;
      node **arr;
      LinkCutTree(const vector<T> &init_node_value): V((int)init_node_value.size()) {
        arr = new node *[V];
        for(int i = 0; i < V; i++) { arr[i] = new node(init_node_value[i]); }
      }
      bool same(int i, int j) { return same(arr[i], arr[j]); }
      void unite(int i, int j) { return unite(arr[i], arr[j]); }
      void cut(int i) { return cut(arr[i]); }
      void cut(int i, int j) { return cut(arr[i], arr[j]); }
      int lca(int i, int j) { return static_cast<size_t>(lca(arr[i], arr[j]) - arr[0]); }
      void evert(int i) { return evert(arr[i]); }
      int depth(int i) { return depth(arr[i]); }
      void toRoot_range(int i, const T x) { return toRoot_range(arr[i], x); }
      T toRoot_query(int i) { return toRoot_query(arr[i]); }
      void range(int i, int j, const T x) { return range(arr[i], arr[j], x); }
      T query(int i, int j) { return query(arr[i], arr[j]); }
      int component_size(int i) { return component_size(arr[i]); }
      int subtree_size(int i) { return subtree_size(arr[i]); }
      T component_query(int i) { return component_query(arr[i]); }
      T subtree_query(int i) { return subtree_query(arr[i]); }
    };

    /*
    bool same(i,j) : i と j が同じ木(連結成分)に属するか
    void unite(i,j) : i を j の non-preferred edge にする
    void cut(i) : i とその親の間の辺を削除する
    void cut(i,j) : i と j の間の辺を削除する
    int lca(i,j) : i と j の LCA を求める
    void evert(i) : 元の木の根を i にする
    int depth(i) : i の深さを求める
    void toRoot_range(i,x) : i から根までの間にある頂点すべてに x を足す
    T toRoot_query(i) : i から根までの間にある頂点すべてのコストの総和を求める
    void range(i,j,x) : i と j の間にある頂点すべてに x を足す
    T query(i,j) : i と j の間にある頂点すべてのコストの総和を求める
    int component_size(i) : i の属する連結成分のサイズを返す
    int subtree_size(i) : i を根とする部分木のサイズを返す
    T component_query(i) : i の属する連結成分内のコストの総和を返す
    T subtree_query(i) : i を根とする部分木内のコストの総和を返す
    */

    """

  'PrimitiveRoot':
    'prefix':'PrimitiveRoot'
    'body':"""
    constexpr ll safe_mod(ll x, ll m) {
      x %= m;
      if(x < 0) { x += m; }
      return x;
    }

    constexpr ll pow_mod_constexpr(ll x, ll n, int m) {
      if(m == 1) { return 0; }
      unsigned int _m = (unsigned int)(m);
      unsigned long long r = 1, y = safe_mod(x, m);
      while(n) {
        if(n & 1) { r = (r * y) % _m; }
        y = (y * y) % _m;
        n >>= 1;
      }
      return r;
    }

    constexpr int PrimitiveRoot(int m) {
      if(m == 2) { return 1; }
      if(m == 167772161) { return 3; }
      if(m == 469762049) { return 3; }
      if(m == 754974721) { return 11; }
      if(m == 998244353) { return 3; }
      int divs[20] = {};
      divs[0] = 2;
      int cnt = 1, x = (m - 1) / 2;
      while(x % 2 == 0) { x /= 2; }
      for(int i = 3; (ll)(i)*i <= x; i += 2) {
        if(x % i == 0) {
          divs[cnt++] = i;
          while(x % i == 0) { x /= i; }
        }
      }
      if(x > 1) { divs[cnt++] = x; }
      for(int g = 2;; g++) {
        bool ok = true;
        for(int i = 0; i < cnt; i++) {
          if(pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {
            ok = false;
            break;
          }
        }
        if(ok) { return g; }
      }
    }
    """

  'Order':
    'prefix':'Order'
    'body':"""
    struct Order {
     private:
      ll mod;
      size_t n;
      vector<pair<ll, ll>> fac;
      vector<ll> prod;
      ll internal_pow(ll x, ll k) const {
        ll r = 1;
        for(; k; k >>= 1) {
          if(k & 1) { r = __int128_t(r) * x % mod; }
          x = __int128_t(x) * x % mod;
        }
        return r;
      }
      int exponent(size_t i, ll x) const {
        const auto &[p, e] = fac[i];
        for(int j = 0; j < e; j++) {
          if(x == 1) { return j; }
          x = internal_pow(x, p);
        }
        return e;
      }
      ll query(size_t l, size_t r, ll x) const {
        ll res = 1;
        if(r - l == 1) {
          ll p = fac[l].first;
          int f = exponent(l, x);
          while(f--) { res *= p; }
          return res;
        }
        const size_t m = (l + r) >> 1;
        res *= query(l, m, internal_pow(x, prod[r] / prod[m]));
        res *= query(m, r, internal_pow(x, prod[m] / prod[l]));
        return res;
      }

     public:
      Order(ll p): mod(p) {
        fac = Prime(p - 1);
        n = fac.size();
        prod.resize(n + 1);
        prod[0] = 1;
        for(size_t i = 0; i < n; i++) {
          auto [pf, e] = fac[i];
          ll ppf = 1;
          while(e--) { ppf *= pf; }
          prod[i + 1] = prod[i] * ppf;
        }
      }
      ll query(ll x) const { return n ? query(0, n, x) : 0; }
      inline ll operator()(ll x) const { return query(x); }
    };
    """

  'Trie':
    'prefix':'Trie'
    'body':"""
    template<size_t X = 26, char margin = 'a'> struct Trie {
      struct Node {
        array<int, X> nxt;
        vector<int> idxs;
        int idx;
        char key;
        Node(char c): idx(-1), key(c) { ranges::fill(nxt, -1); }
      };
      vector<Node> st;
      Trie(char c = '$') { st.emplace_back(c); }
      inline int &next(int i, int j) { return st[i].nxt[j]; }
      void add(const string &s, int x) {
        int pos = 0;
        for(int i = 0; i < ssize(s); i++) {
          int k = s[i] - margin;
          if(~next(pos, k)) {
            pos = next(pos, k);
            continue;
          }
          int npos = st.size();
          next(pos, k) = npos;
          st.emplace_back(s[i]);
          pos = npos;
        }
      }
      int find(const string &s) {
        int pos = 0;
        for(int i = 0; i < ssize(s); i++) {
          int k = s[i] - margin;
          if(next(pos, k) < 0) { return -1; }
          pos = next(pos, k);
        }
        return pos;
      }
      int move(int pos, char c) {
        return pos < 0 ? -1 : next(pos, c - margin);
      }
      int size() const { return st.size(); }
      int idx(int pos) { return pos < 0 ? -1 : st[pos].idx; }
      vector<int> idxs(int pos) { return pos < 0 ? vector<int>() : st[pos].idxs; }
    };
    """

  'AhoCorasick':
    'prefix':'AhoCorasick'
    'body':"""
    template<size_t X = 26, char margin = 'a'> struct Trie {
      struct Node {
        array<int, X> nxt;
        vector<int> idxs;
        int idx;
        char key;
        Node(char c): idx(-1), key(c) { ranges::fill(nxt, -1); }
      };
      int c = 0;
      vector<Node> st;
      Trie() { st.emplace_back('$'); }
      Trie(const vector<string> &v) {
        st.emplace_back('$');
        for(auto &i : v) { insert(i); }
      }
      void clear() {
        st.clear();
        st.emplace_back('$');
      }
      inline int &next(int i, int j) { return st[i].nxt[j]; }
      void insert(const string &s) {
        int pos = 0;
        for(int i = 0; i < ssize(s); i++) {
          int k = s[i] - margin;
          if(~next(pos, k)) {
            pos = next(pos, k);
            continue;
          }
          int npos = st.size();
          next(pos, k) = npos;
          st.emplace_back(s[i]);
          pos = npos;
        }
        st[pos].idx = c;
        st[pos].idxs.emplace_back(c);
        c++;
      }
      int find(const string &s) {
        int pos = 0;
        for(int i = 0; i < ssize(s); i++) {
          int k = s[i] - margin;
          if(next(pos, k) < 0) { return -1; }
          pos = next(pos, k);
        }
        return pos;
      }
      int move(int pos, char c) {
        return pos < 0 ? -1 : next(pos, c - margin);
      }
      int size() const { return st.size(); }
      int idx(int pos) { return pos < 0 ? -1 : st[pos].idx; }
      vector<int> idxs(int pos) { return pos < 0 ? vector<int>() : st[pos].idxs; }
    };

    template<size_t X = 26, char margin = 'a'> struct AhoCorasick : Trie<X + 1, margin> {
      using TRIE = Trie<X + 1, margin>;
      using TRIE::c;
      using TRIE::next;
      using TRIE::st;
      using TRIE::TRIE;
      vector<int> cnt;
      void build(bool heavy = false) {
        int n = st.size();
        cnt.resize(n);
        for(int i = 0; i < n; i++) {
          if(heavy) { ranges::sort(st[i].idxs); }
          cnt[i] = st[i].idxs.size();
        }
        queue<int> q;
        for(int i = 0; i < (int)X; i++) {
          if(~next(0, i)) {
            next(next(0, i), X) = 0;
            q.emplace(next(0, i));
          }
          else { next(0, i) = 0; }
        }
        while(!q.empty()) {
          auto &x = st[q.front()];
          int fail = x.nxt[X];
          cnt[q.front()] += cnt[fail];
          q.pop();
          for(int i = 0; i < (int)X; i++) {
            int &nx = x.nxt[i];
            if(nx < 0) {
              nx = next(fail, i);
              continue;
            }
            q.emplace(nx);
            next(nx, X) = next(fail, i);
            if(heavy) {
              auto &idx = st[nx].idxs, &idy = st[next(fail, i)].idxs;
              vector<int> idz;
              ranges::set_union(idx, idy, back_inserter(idz));
              idx = idz;
            }
          }
        }
      }
      ll match_count(string s) {
        int res = 0, pos = 0;
        for(auto &c : s) {
          pos = next(pos, c - margin);
          res += cnt[pos];
        }
        return res;
      }
      vector<vector<int>> match(string s) {
        vector<vector<int>> res(c);
        int pos = 0;
        for(int i = 0; i < (int)s.size(); i++) {
          pos = next(pos, s[i] - margin);
          for(auto &x : st[pos].idxs) { res[x].emplace_back(i); }
        }
        return res;
      }
      int count(int pos) { return cnt[pos]; }
    };
    """

  'Enum_multiset':
    'prefix':'Enum_multiset'
    'body':"""
    // 各要素が[0, k)で長さnの広義単調増加列
    vector<vector<ll>> Enum_multiset(int k, int n) {
      vector<vector<ll>> r;
      vector<ll> v(n);
      auto DFS = [&](auto &&DFS, int p, int s) -> void {
        if(p == n) {
          r.emplace_back(v);
          return;
        }
        for(ll i = s; i < k; i++) {
          v[p] = i;
          DFS(DFS, p + 1, i);
        }
      };
      DFS(DFS, 0, 0);
      return r;
    }
    """

  'Enum_product':
    'prefix':'Enum_product'
    'body':"""
    // [0, v_0) x [0, v_1) x ...
    vector<vector<ll>> Enum_product(vector<ll> v) {
      vector<vector<ll>> r;
      int N = ssize(v);
      auto DFS = [&](auto &&DFS, vector<ll> &p) -> void {
        int n = ssize(p);
        if(n == N) {
          r.emplace_back(p);
          return;
        }
        for(ll i = 0; i < v[n]; i++) {
          p.emplace_back(i);
          DFS(DFS, p);
          p.pop_back();
        }
      };
      vector<ll> p;
      DFS(DFS, p);
      return r;
    }
    """

  'Enum_xor':
    'prefix':'Enum_xor'
    'body':"""
    // L <= x ^ a < R となる x の区間 [l, r)の列挙
    vector<pair<ll, ll>> Enum_xor(uint64_t a, uint64_t L, uint64_t R) {
      vector<pair<ll, ll>> r;
      for(ll i = 0; i < 64; i++) {
        if(L == R) { break; }
        ll b = 1LL << i;
        if(L & b) {
          r.emplace_back(L ^ a, (L ^ a) + b);
          L += b;
        }
        if(R & b) {
          r.emplace_back((R - b) ^ a, ((R - b) ^ a) + b);
          R -= b;
        }
        if(a & b) { a ^= b; }
      }
      return r;
    }
    """

  'Doubling':
    'prefix':'Doubling'
    'body':"""
    template<typename S, auto op> struct Doubling {
      static_assert(is_convertible_v<decltype(op), function<S(S, S)>>);

     private:
      int n = 0;
      vector<vector<ll>> nxts;
      vector<vector<S>> prds;

      void build() {
        vector<ll> nxt(n);
        vector<S> prd(n);
        for(int i = 0; i < n; i++) {
          if(int j = nxts.back()[i]; in(j)) {
            nxt[i] = nxts.back()[j];
            prd[i] = op(prds.back()[i], prds.back()[j]);
          }
          else {
            nxt[i] = j;
            prd[i] = prds.back()[i];
          }
        }
        nxts.emplace_back(move(nxt));
        prds.emplace_back(move(prd));
      }
      inline bool in(int i) const noexcept { return 0 <= i && i < n; }
      int pow_next(int s, int d) {
        assert(in(s));
        while(ssize(nxts) <= d) { build(); }
        return nxts[d][s];
      }
      const S &pow_prod(int s, int d) {
        assert(in(s));
        while(ssize(nxts) <= d) { build(); }
        return prds[d][s];
      }

     public:
      Doubling() = default;
      Doubling(const vector<ll> &g, vector<S> &w): n(ssize(g)), nxts(1, g), prds(1, w) { assert(ssize(g) == ssize(w)); }
      int next(int s, ll k) {
        for(int d = 0; k > 0 && in(s); d++, k >>= 1) {
          if(k & 1) { s = pow_next(s, d); }
        }
        return s;
      }
      S prod(int s, ll len) {
        assert(in(s));
        assert(len > 0);
        int d = 0;
        while(!(len & 1)) {
          d++;
          len /= 2;
        }
        S r = pow_prod(s, d);
        s = pow_next(s, d);
        for(++d, len /= 2; len && in(s); d++, len /= 2) {
          if(len & 1) {
            r = op(r, pow_prod(s, d));
            s = pow_next(s, d);
          }
        }
        return r;
      }
      int distance(int s, int l, int r) {
        assert(in(s));
        if(s <= l || r <= s) { return 0; }
        int d = 0;
        while(l < pow_next(s, d) && pow_next(s, d) < r) {
          if((1 << d) >= n) { return -1; }
          d++;
        }
        int ret = 0, cur = s;
        for(--d; d >= 0; d--) {
          if(int nxt = pow_next(cur, d); l < nxt && nxt < r) {
            ret += 1 << d;
            cur = nxt;
          }
        }
        return ret + 1;
      }
      template<typename F> ll maxlen(const int s, F f, const int maxd = 60) {
        assert(in(s));
        int d = 0;
        while(d <= maxd && f(pow_prod(s, d))) {
          if(!in(pow_next(s, d))) { return 1LL << maxd; }
          d++;
        }
        if(d > maxd) { return 1LL << maxd; }
        d--;
        int cur = pow_next(s, d);
        ll len = 1LL << d;
        S p = pow_prod(s, d);
        for(int e = d - 1; e >= 0; e--) {
          if(S nxtp = op(p, pow_prod(cur, e)); f(nxtp)) {
            swap(p, nxtp);
            cur = pow_next(cur, e);
            len += 1LL << e;
          }
        }
        return len;
      }
    };
    // https://hitonanode.github.io/cplib-cpp/other_algorithms/binary_lifting.hpp

    using S = ll;
    S op(S l, S r) { return $1; }$2
    """

  'doubling':
    'prefix':'doubling'
    'body':'Doubling<S,op>'

  'Matinv':
    'prefix':'Matinv'
    'body':"""
    template<typename T> pair<ll, T> GaussElimination(Matrix<T> &v, ll pivot_end = -1, bool diagonalize = false) {
      int H = v.size(), W = v[0].size(), rank = 0;
      if(pivot_end == -1) { pivot_end = W; }
      T det = 1;
      for(int j = 0; j < pivot_end; j++) {
        int idx = -1;
        for(int i = rank; i < H; i++) {
          if(v[i][j] != T(0)) {
            idx = i;
            break;
          }
        }
        if(idx == -1) {
          det = 0;
          continue;
        }
        if(rank != idx) {
          det = -det;
          swap(v[rank], v[idx]);
        }
        det *= v[rank][j];
        if(diagonalize && v[rank][j] != T(1)) {
          T c = T(1) / v[rank][j];
          for(int k = j; k < W; k++) { v[rank][k] *= c; }
        }
        int is = diagonalize ? 0 : rank + 1;
        for(int i = is; i < H; i++) {
          if(i == rank) { continue; }
          if(v[i][j] != T(0)) {
            T c = v[i][j] / v[rank][j];
            for(int k = j; k < W; k++) { v[i][k] -= v[rank][k] * c; }
          }
        }
        rank++;
      }
      return make_pair(rank, det);
    }

    template<typename T> Matrix<T> Matinv(const Matrix<T> &v) {
      int N = v.size();
      assert(N > 0);
      assert(N == (int)v[0].size());

      Matrix<T> m(N, 2 * N);
      for(int i = 0; i < N; i++) {
        ranges::copy(v[i], m[i].begin());
        m[i][N + i] = 1;
      }
      auto [rank, det] = GaussElimination(m, N, true);
      if(rank != N) { return {}; }

      Matrix<T> b(N, 0);
      for(int i = 0; i < N; i++) {
        copy(m[i].begin() + N, m[i].end(), back_inserter(b[i]));
      }
      return b;
    }
    """

  'F2_Matrix':
    'prefix':'F2_Matrix'
    'body':"""
    template<size_t N> bool operator<(const bitset<N> &a, const bitset<N> &b) {
      int f = (a ^ b)._Find_first();
      return f == N ? false : a[f];
    }

    template<size_t H_MAX, size_t W_MAX> struct F2_Matrix {
      int H, W;
      array<bitset<W_MAX>, H_MAX> A;
      F2_Matrix(int h = H_MAX, int w = W_MAX): H(h), W(w) {
        assert(h >= 0 && h <= (int)(H_MAX));
        assert(w >= 0 && w <= (int)(W_MAX));
        for(int i = 0; i < (int)H_MAX; i++) { A[i].reset(); }
      }
      inline bitset<W_MAX> &operator[](int i) { return A[i]; }
      inline const bitset<W_MAX> &operator[](int i) const { return A[i]; }
      static F2_Matrix I(int n) {
        F2_Matrix a(n, n);
        for(int i = 0; i < n; i++) { a[i][i] = true; }
        return a;
      }
      F2_Matrix &operator*=(const F2_Matrix &B) {
        F2_Matrix C(H, B.W);
        for(int i = 0; i < H; i++) {
          for(int j = 0; j < W; j++) {
            if(A[i][j]) { C[i] ^= B[j]; }
          }
        }
        swap(A, C.A);
        return *this;
      }
      F2_Matrix operator*(const F2_Matrix &B) const { return F2_Matrix(*this) *= B; }
      friend F2_Matrix and_or_product(const F2_Matrix &A, const F2_Matrix &B) {
        F2_Matrix C(A.H, B.W);
        for(int i = 0; i < A.H; i++) {
          for(int j = 0; j < A.W; j++) {
            if(A[i][j]) { C[i] |= B[j]; }
          }
        }
        return C;
      }
      int sweep(ll wr = -1) {
        if(wr == -1) { wr = W; }
        int t = 0;
        for(int u = 0; u < wr; u++) {
          int piv = -1;
          for(int i = t; i < H; i++) {
            if(A[i][u]) {
              piv = i;
              break;
            }
          }
          if(piv == -1) { continue; }
          if(piv != t) { swap(A[piv], A[t]); }
          for(int i = 0; i < H; i++) {
            if(i != t && A[i][u]) { A[i] ^= A[t]; }
          }
          t++;
        }
        return t;
      }
      F2_Matrix inv() const {
        assert(H == W);
        int N = H;
        F2_Matrix<H_MAX, W_MAX * 2> c(H, W * 2);
        for(int i = 0; i < N; i++) {
          c[i][i + N] = 1;
          for(int j = 0; j < N; j++) { c[i][j] = A[i][j]; }
        }
        int r = c.sweep();
        assert(r == N);
        F2_Matrix b(H, W);
        for(int i = 0; i < N; i++) {
          for(int j = 0; j < N; j++) { b[i][j] = c[i][i + N]; }
        }
        return b;
      }
      bool operator<(const F2_Matrix &rhs) const {
        if(H != rhs.H) { return H < rhs.H; }
        if(W != rhs.W) { return W < rhs.W; }
        return A < rhs.A;
      }
      bool operator==(const F2_Matrix &rhs) const {
        return H == rhs.H && W == rhs.W && A == rhs.A;
      }
      friend ostream &operator<<(ostream &os, const F2_Matrix &b) {
        for(int i = 0; i < b.H; i++) {
          os << "[ ";
          for(int j = 0; j < b.W; j++) { os << b[i][j] << ", "; }
          os << "],\\\\n";
        }
        return os;
      }
    };
    """

  'CompressedBIT2D':
    'prefix':'CompressedBIT2D'
    'body':"""
    template<typename S, typename T> struct CompressedBIT2D {
     private:
      int N;
      vector<fenwick_tree<T>> bit;
      vector<vector<S>> ys;
      vector<pair<S, S>> ps;
      int id(S x) const {
        return ranges::lower_bound(ps, make_pair(x, S()), [](const pair<S, S> &a, const pair<S, S> &b) { return a.first < b.first; }) - ps.begin();
      }
      int id(int i, S y) const { return ranges::lower_bound(ys[i], y) - ys[i].begin(); }

     public:
      CompressedBIT2D() = default;
      CompressedBIT2D(int N) { ps.reserve(N); }
      void use(S x, S y) { ps.emplace_back(x, y); }
      void build() {
        ranges::sort(ps);
        ps.erase(unique(ps.begin(), ps.end()), ps.end());
        N = ps.size();
        bit.resize(N + 1);
        ys.resize(N + 1);
        for(int i = 0; i <= N; ++i) {
          for(int j = i + 1; j <= N; j += j & -j) { ys[j].emplace_back(ps[i].second); }
          ranges::sort(ys[i]);
          ys[i].erase(unique(ys[i].begin(), ys[i].end()), ys[i].end());
          bit[i] = fenwick_tree<T>(ys[i].size() + 1);
        }
      }
      void add(S x, S y, T a) {
        int i = ranges::lower_bound(ps, make_pair(x, y)) - ps.begin();
        assert(ps[i] == make_pair(x, y));
        for(++i; i <= N; i += i & -i) { bit[i].add(id(i, y), a); }
      }
      T sum(S x, S y) {
        T r = T();
        for(int a = id(x); a; a -= a & -a) { r += bit[a].sum(0, id(a, y)); }
        return r;
      }
      T sum(S lx, S rx, S ly, S ry) {
        T r = T();
        int a = id(lx), b = id(rx);
        while(a != b) {
          if(a < b) {
            r += bit[b].sum(id(b, ly), id(b, ry));
            b -= b & -b;
          }
          else {
            r -= bit[a].sum(id(a, ly), id(a, ry));
            a -= a & -a;
          }
        }
        return r;
      }
    };
    """

  'compressedBIT2D':
    'prefix':'compressedBIT2D'
    'body':'CompressedBIT2D<ll,ll> W;'

  'CompressedSegTree2D':
    'prefix':'CompressedSegTree2D'
    'body':"""
    template<typename S, typename T, auto op, auto e> struct CompressedSegTree2D {
     private:
      int N;
      vector<segtree<T, op, e>> seg;
      vector<vector<S>> ys;
      vector<pair<S, S>> ps;
      int id(S x) const {
        return ranges::lower_bound(ps, make_pair(x, S()), [](const pair<S, S> &a, const pair<S, S> &b) { return a.first < b.first; }) - ps.begin();
      }
      int id(int i, S y) const { return ranges::lower_bound(ys[i], y) - ys[i].begin(); }

     public:
      CompressedSegTree2D() = default;
      void use(S x, S y) { ps.emplace_back(x, y); }
      void build() {
        ranges::sort(ps);
        ps.erase(unique(ps.begin(), ps.end()), ps.end());
        N = ps.size();
        seg.resize(2 * N);
        ys.resize(2 * N);
        for(int i = 0; i < N; i++) {
          ys[i + N].emplace_back(ps[i].second);
          seg[i + N] = segtree<T, op, e>(1);
        }
        for(int i = N - 1; i; i--) {
          ys[i].resize(ys[i << 1].size() + ys[i << 1 | 1].size());
          ranges::merge(ys[i << 1], ys[i << 1 | 1], ys[i].begin());
          ys[i].erase(unique(ys[i].begin(), ys[i].end()), ys[i].end());
          seg[i] = segtree<T, op, e>(ys[i].size());
        }
      }
      void set(S x, S y, T a) {
        int i = ranges::lower_bound(ps, make_pair(x, y)) - ps.begin();
        assert(ps[i] == make_pair(x, y));
        for(i += N; i; i >>= 1) { seg[i].set(id(i, y), a); }
      }
      T prod(S lx, S rx, S ly, S ry) {
        T L = e(), R = e();
        int a = id(lx), b = id(rx);
        for(a += N, b += N; a < b; a >>= 1, b >>= 1) {
          if(a & 1) {
            L = op(L, seg[a].prod(id(a, ly), id(a, ry)));
            a++;
          }
          if(b & 1) {
            b--;
            R = op(seg[b].prod(id(b, ly), id(b, ry)), R);
          }
        }
        return op(L, R);
      }
    };
    """

  'compressedSegTree2D':
    'prefix':'compressedSegTree2D'
    'body':'CompressedSegTree2D<ll,S,op,e> seg;'

  'GoldenSectionSearch':
    'prefix':'GoldenSectionSearch'
    'body':"""
    template<typename T, bool get_min = true> pair<ll, T> GoldenSectionSearch(const auto &f, ll Min, ll Max) {
      assert(Min <= Max);
      ll a = Min - 1, x, b, s = 1, t = 2;
      while(t < Max - Min + 2) { swap(s += t, t); }
      x = a + t - s;
      b = a + t;
      T fx = f(x), fy;
      while(a + b != 2 * x) {
        ll y = a + b - x;
        if(Max < y || (fy = f(y), get_min ? fx < fy : fx > fy)) {
          b = a;
          a = y;
        }
        else {
          a = x;
          x = y;
          fx = fy;
        }
      }
      return {x, fx};
    }
    """

  'ChromaticNumber':
    'prefix':'ChromaticNumber'
    'body':"""
    namespace ChromaticNumberImpl {
    template<unsigned mod> int calc(int n, vector<pair<int, int>> hist) {
      for(int c = 1; c <= n; c++) {
        ll sm = 0;
        for(auto &[i, x] : hist) { sm += (x = ll(x) * i % mod); }
        if(sm % mod != 0) { return c; }
      }
      return n;
    }
    }  // namespace ChromaticNumberImpl

    int ChromaticNumber(vector<vector<ll>> &g) {
      int n = g.size();
      vector<int> adj(n), dp(1 << n);
      for(int i = 0; i < n; i++) {
        for(auto &j : g[i]) {
          adj[i] |= 1 << j;
          adj[j] |= 1 << i;
        }
      }
      dp[0] = 1;
      for(int i = 1; i < 1 << n; i++) {
        int j = __builtin_ctz(i), k = i & (i - 1);
        dp[i] = dp[k] + dp[k & ~adj[j]];
      }
      vector<int> memo((1 << n) + 1);
      for(int i = 0; i < (1 << n); i++) { memo[dp[i]] += __builtin_parity(i) ? -1 : 1; }
      vector<pair<int, int>> hist;
      for(int i = 1; i <= (1 << n); i++) {
        if(memo[i]) { hist.emplace_back(i, memo[i]); }
      }
      return min(ChromaticNumberImpl::calc<1000000021>(n, hist), ChromaticNumberImpl::calc<1000000033>(n, hist));
    }
    """

  'fill':
    'prefix':'fill'
    'body':'ranges::fill($1);'

  'AuxiliaryTree':
    'prefix':'AuxiliaryTree'
    'body':"""
    struct AuxiliaryTree : Tree {
      vector<vector<ll>> g;
      vector<ll> id, inv;
      AuxiliaryTree(const vector<vector<ll>> &g, ll r = 0): Tree(g, r), inv(g.size()) {}
      int build(const vector<ll> &v) {
        int N = v.size();
        g.assign(N, vector<ll>());
        id = v;
        ranges::sort(id, [&](auto x, auto y) { return (*this).in(x) < (*this).in(y); });
        stack<int> s;
        s.emplace(id[0]);
        inv[id[0]] = 0;
        for(int i = 0; i < N - 1; i++) {
          int u = (*this).lca(id[i], id[i + 1]);
          if(u != id[i]) {
            int p = inv[s.top()];
            while(true) {
              s.pop();
              if(s.empty() || (*this).depth(u) >= (*this).depth(s.top())) { break; }
              int tmp = inv[s.top()];
              g[tmp].emplace_back(p);
              p = tmp;
            }
            if(s.empty() || s.top() != u) {
              s.emplace(u);
              id.emplace_back(u);
              inv[u] = g.size();
              g.push_back({p});
            }
            else { g[inv[u]].emplace_back(p); }
          }
          s.emplace(id[i + 1]);
          inv[id[i + 1]] = i + 1;
        }
        int p = ((s.size() > 1) ? inv[s.top()] : -1);
        while(s.size() > 1) {
          s.pop();
          int tmp = inv[s.top()];
          g[tmp].emplace_back(p);
          p = tmp;
        }
        return inv[s.top()];
      }
      inline vector<ll> operator[](ll i) { return g[i]; }
      inline ll operator()(ll i) { return id[i]; }
    };
    """

  'CompressedBIT':
    'prefix':'CompressedBIT'
    'body':"""
    template<typename S, typename T> struct CompressedBIT {
     private:
      fenwick_tree<T> f;
      vector<S> p;
      int id(S x) const { return ranges::lower_bound(p, x) - p.begin(); }

     public:
      CompressedBIT() = default;
      CompressedBIT(int N) { p.reserve(N); }
      void use(S x) { p.emplace_back(x); }
      void build() {
        ranges::sort(p);
        p.erase(unique(p.begin(), p.end()), p.end());
        f = fenwick_tree<T>(p.size());
      }
      void add(S i, T x) { f.add(id(i), x); }
      T sum(S l, S r) { return f.sum(id(l), id(r)); }
    };
    """

  'compressedBIT':
    'prefix':'compressedBIT'
    'body':'CompressedBIT<ll,ll> B;'

  'CompressedSegTree':
    'prefix':'CompressedSegTree'
    'body':"""
    template<typename T, typename S, auto op, auto e> struct CompressedSegTree {
     private:
      segtree<S, op, e> seg;
      vector<T> p;
      int id(T x) { return ranges::lower_bound(p, x) - p.begin(); }

     public:
      CompressedSegTree() = default;
      CompressedSegTree(int N) { p.reserve(N); }
      void use(ll x) { p.emplace_back(x); }
      void build() {
        ranges::sort(p);
        p.erase(unique(p.begin(), p.end()), p.end());
        seg = segtree<S, op, e>(p.size());
      }
      void set(T i, S x) { seg.set(id(i), x); }
      S get(T i) { return seg.get(id(i)); }
      S prod(T l, T r) { return seg.prod(id(l), id(r)); }
      S all_prod() { return seg.all_prod(); }
      template<auto f> int max_right(T l) {
        return seg.max_right(id(l), [](S x) { return f(x); });
      }
      template<auto f> int min_left(T r) {
        return seg.min_left(id(r), [](S x) { return f(x); });
      }
    };
    """

  'compressedSegTree':
    'prefix':'compressedSegTree'
    'body':'CompressedSegTree<ll,S,op,e> seg;'

  'CompressedLazySegTree':
    'prefix':'CompressedLazySegTree'
    'body':"""
    template<typename T, typename S, auto op, auto e, typename F, auto fx, auto fg, auto id> struct CompressedLazySegTree {
     private:
      lazy_segtree<S, op, e, F, fx, fg, id> seg;
      vector<T> p;
      int idx(T x) { return ranges::lower_bound(p, x) - p.begin(); }

     public:
      CompressedLazySegTree() = default;
      CompressedLazySegTree(int N) { p.reserve(N); }
      void use(T x) { p.emplace_back(x); }
      void build() {
        ranges::sort(p);
        p.erase(unique(p.begin(), p.end()), p.end());
        seg = lazy_segtree<S, op, e, F, fx, fg, id>(p.size());
      }
      void set(T i, S x) { seg.set(idx(i), x); }
      S get(T i) { return seg.get(idx(i)); }
      S prod(T l, T r) { return seg.prod(idx(l), idx(r)); }
      S all_prod() { return seg.all_prod(); }
      void apply(T i, F f) { seg.apply(idx(i), f); }
      void apply(T l, T r, F f) { seg.apply(idx(l), idx(r), f); }
      template<auto f> int max_right(T l) {
        return seg.max_right(idx(l), [](S x) { return f(x); });
      }
      template<auto f> int min_left(T r) {
        return seg.min_left(idx(r), [](S x) { return f(x); });
      }
    };
    """

  'compressedLazySegTree':
    'prefix':'compressedLazySegTree'
    'body':'CompressedLazySegTree<ll,S,op,e,F,fx,fg,id> seg;'

  'Require_in':
    'prefix':'Reqin'
    'body':"""
    template<typename T> int Reqin(vector<vector<T>> &g_) {
      int N = g_.size();
      scc_graph s(N);
      vector<vector<int>> g(N);
      for(int i = 0; i < N; i++) {
        for(auto &j : g_[i]) {
          s.add_edge(i, j);
          g[j].emplace_back(i);
        }
      }
      auto scc = s.scc();
      for(auto &i : scc) { ranges::sort(i); }
      int r = 0;
      for(auto &i : scc) {
        bool in = false;
        for(auto &j : i) {
          for(auto &k : g[j]) {
            if(!ranges::binary_search(i, k)) {
              in = true;
              break;
            }
          }
          if(in) { break; }
        }
        if(!in) { r++; }
      }
      return r;
    }
    """

  'Palindrome':
    'prefix':'Palindrome'
    'body':"""
    template<typename T> vector<int> Manacher(const T &S) {
      const int N = S.size();
      vector<int> r(N);
      int i = 0, j = 0;
      while(i < N) {
        while(i - j >= 0 && i + j < N && S[i - j] == S[i + j]) { j++; }
        r[i] = j;
        int k = 1;
        while(i - k >= 0 && i + k < N && k + r[i - k] < j) {
          r[i + k] = r[i - k];
          k++;
        }
        i += k;
        j -= k;
      }
      return r;
    }

    template<typename T> vector<pair<int, int>> WidestPalindrome(const T &vec) {
      using U = typename T::value_type;
      vector<U> v;
      const int N = vec.size();
      for(int i = 0; i < N - 1; i++) {
        v.emplace_back(vec[i]);
        v.emplace_back(-1);
      }
      v.emplace_back(vec.back());
      const auto m = Manacher(v);
      vector<pair<int, int>> r;
      for(int i = 0; i < N * 2 - 1; i++) {
        if(i & 1) {
          int w = m[i] / 2;
          r.emplace_back((i + 1) / 2 - w, (i + 1) / 2 + w);
        }
        else {
          int w = (m[i] - 1) / 2;
          r.emplace_back(i / 2 - w, i / 2 + w + 1);
        }
      }
      return r;
    }

    template<typename T> vector<int> LeftmostPalindrome(const T &vec) {
      const int N = vec.size();
      vector<int> v(N, -1);
      for(auto &[l, r] : WidestPalindrome(vec)) { v[r - 1] = max(v[r - 1], r - l); }
      for(int i = N - 2; i >= 0; i--) { v[i] = max(v[i], v[i + 1] - 2); }
      vector<int> r(N);
      for(int i = 0; i < N; i++) { r[i] = i + 1 - v[i]; }
      return r;
    }
    """

  'SegTreeBeats':
    'prefix':'SegTreeBeats'
    'body':"""
    struct SegTreeBeats {
     private:
      static constexpr ll INF = numeric_limits<ll>::max() / 2.1;
      struct alignas(32) Node {
        ll sum = 0, add = 0;
        ll g1 = 0, g2 = -INF, gc = 1;
        ll l1 = 0, l2 = INF, lc = 1;
      };

      vector<Node> v;
      ll n, log;

      void update(int k) {
        Node &p = v[k], &l = v[k * 2], &r = v[k * 2 + 1];
        p.sum = l.sum + r.sum;
        if(l.g1 == r.g1) {
          p.g1 = l.g1;
          p.g2 = max(l.g2, r.g2);
          p.gc = l.gc + r.gc;
        }
        else {
          bool f = l.g1 > r.g1;
          p.g1 = f ? l.g1 : r.g1;
          p.gc = f ? l.gc : r.gc;
          p.g2 = max(f ? r.g1 : l.g1, f ? l.g2 : r.g2);
        }
        if(l.l1 == r.l1) {
          p.l1 = l.l1;
          p.l2 = min(l.l2, r.l2);
          p.lc = l.lc + r.lc;
        }
        else {
          bool f = l.l1 < r.l1;
          p.l1 = f ? l.l1 : r.l1;
          p.lc = f ? l.lc : r.lc;
          p.l2 = min(f ? r.l1 : l.l1, f ? l.l2 : r.l2);
        }
      }
      void push_add(int k, ll x) {
        Node &p = v[k];
        p.sum += x << (log + __builtin_clz(k) - 31);
        p.g1 += x;
        p.l1 += x;
        if(p.g2 != -INF) { p.g2 += x; }
        if(p.l2 != INF) { p.l2 += x; }
        p.add += x;
      }
      void push_min(int k, ll x) {
        Node &p = v[k];
        p.sum += (x - p.g1) * p.gc;
        if(p.l1 == p.g1) { p.l1 = x; }
        if(p.l2 == p.g1) { p.l2 = x; }
        p.g1 = x;
      }
      void push_max(int k, ll x) {
        Node &p = v[k];
        p.sum += (x - p.l1) * p.lc;
        if(p.g1 == p.l1) { p.g1 = x; }
        if(p.g2 == p.l1) { p.g2 = x; }
        p.l1 = x;
      }
      void push(int k) {
        Node &p = v[k];
        if(p.add) {
          push_add(k * 2, p.add);
          push_add(k * 2 + 1, p.add);
          p.add = 0;
        }
        if(p.g1 < v[k * 2].g1) { push_min(k * 2, p.g1); }
        if(p.l1 > v[k * 2].l1) { push_max(k * 2, p.l1); }
        if(p.g1 < v[k * 2 + 1].g1) { push_min(k * 2 + 1, p.g1); }
        if(p.l1 > v[k * 2 + 1].l1) { push_max(k * 2 + 1, p.l1); }
      }
      void subtree_chmin(int k, ll x) {
        if(v[k].g1 <= x) { return; }
        if(v[k].g2 < x) {
          push_min(k, x);
          return;
        }
        push(k);
        subtree_chmin(k * 2, x);
        subtree_chmin(k * 2 + 1, x);
        update(k);
      }
      void subtree_chmax(int k, ll x) {
        if(x <= v[k].l1) { return; }
        if(x < v[k].l2) {
          push_max(k, x);
          return;
        }
        push(k);
        subtree_chmax(k * 2, x);
        subtree_chmax(k * 2 + 1, x);
        update(k);
      }
      template<int cmd> inline void apply(int k, ll x) {
        if constexpr(cmd == 1) { subtree_chmin(k, x); }
        if constexpr(cmd == 2) { subtree_chmax(k, x); }
        if constexpr(cmd == 3) { push_add(k, x); }
        if constexpr(cmd == 4) {
          subtree_chmax(k, x);
          subtree_chmax(k, x);
        }
      }
      template<int cmd> void apply(int l, int r, ll x) {
        if(l == r) { return; }
        l += n, r += n;
        for(int i = log; i >= 1; i--) {
          if(((l >> i) << i) != l) { push(l >> i); }
          if(((r >> i) << i) != r) { push((r - 1) >> i); }
        }
        {
          int l2 = l, r2 = r;
          while(l < r) {
            if(l & 1) { apply<cmd>(l++, x); }
            if(r & 1) { apply<cmd>(--r, x); }
            l >>= 1;
            r >>= 1;
          }
          l = l2, r = r2;
        }
        for(int i = 1; i <= log; i++) {
          if(((l >> i) << i) != l) { update(l >> i); }
          if(((r >> i) << i) != r) { update((r - 1) >> i); }
        }
      }
      template<int cmd> inline ll e() {
        if constexpr(cmd == 1) { return INF; }
        if constexpr(cmd == 2) { return -INF; }
        return 0;
      }
      template<int cmd> inline void op(ll &a, const Node &b) {
        if constexpr(cmd == 1) { a = min(a, b.l1); }
        if constexpr(cmd == 2) { a = max(a, b.g1); }
        if constexpr(cmd == 3) { a += b.sum; }
      }
      template<int cmd> ll prod(int l, int r) {
        if(l == r) { return e<cmd>(); }
        l += n, r += n;
        for(int i = log; i >= 1; i--) {
          if(((l >> i) << i) != l) { push(l >> i); }
          if(((r >> i) << i) != r) { push((r - 1) >> i); }
        }
        ll lx = e<cmd>(), rx = e<cmd>();
        while(l < r) {
          if(l & 1) { op<cmd>(lx, v[l++]); }
          if(r & 1) { op<cmd>(rx, v[--r]); }
          l >>= 1;
          r >>= 1;
        }
        if constexpr(cmd == 1) { lx = min(lx, rx); }
        if constexpr(cmd == 2) { lx = max(lx, rx); }
        if constexpr(cmd == 3) { lx += rx; }
        return lx;
      }

     public:
      SegTreeBeats() {}
      SegTreeBeats(int N): SegTreeBeats(vector<ll>(N)) {}
      SegTreeBeats(const vector<ll> &vc): n(1), log(0) {
        while(n < ssize(vc)) {
          n <<= 1;
          log++;
        }
        v.resize(2 * n);
        for(ll i = 0; i < ssize(vc); i++) { v[i + n].sum = v[i + n].g1 = v[i + n].l1 = vc[i]; }
        for(ll i = n - 1; i; i--) { update(i); }
      }

      void chmin(int l, int r, ll x) { apply<1>(l, r, x); }
      void chmax(int l, int r, ll x) { apply<2>(l, r, x); }
      void add(int l, int r, ll x) { apply<3>(l, r, x); }
      void update(int l, int r, ll x) { apply<4>(l, r, x); }
      ll getmin(int l, int r) { return prod<1>(l, r); }
      ll getmax(int l, int r) { return prod<2>(l, r); }
      ll getsum(int l, int r) { return prod<3>(l, r); }
    };
    """

  'Lazy_add/or_max/and/or':
    'prefix':'Lazy_add/or_max/and/or'
    'body':"""
    template<class S, auto op, auto e, class F, auto mapping, auto composition, auto id> struct lazy_segtree {
      static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>, "op must work as S(S, S)");
      static_assert(std::is_convertible_v<decltype(e), std::function<S()>>, "e must work as S()");
      static_assert(std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>, "mapping must work as F(F, S)");
      static_assert(std::is_convertible_v<decltype(composition), std::function<F(F, F)>>, "compostiion must work as F(F, F)");
      static_assert(std::is_convertible_v<decltype(id), std::function<F()>>, "id must work as F()");

     public:
      lazy_segtree(): lazy_segtree(0) {}
      explicit lazy_segtree(int n): lazy_segtree(std::vector<S>(n, e())) {}
      explicit lazy_segtree(const std::vector<S>& v): _n(int(v.size())) {
        size = (int)bit_ceil((unsigned int)(_n));
        log = countr_zero((unsigned int)size);
        d = std::vector<S>(2 * size, e());
        lz = std::vector<F>(size, id());
        for(int i = 0; i < _n; i++) { d[size + i] = v[i]; }
        for(int i = size - 1; i >= 1; i--) { update(i); }
      }
      void set(int p, S x) {
        assert(0 <= p && p < _n);
        p += size;
        for(int i = log; i >= 1; i--) { push(p >> i); }
        d[p] = x;
        for(int i = 1; i <= log; i++) { update(p >> i); }
      }
      S get(int p) {
        assert(0 <= p && p < _n);
        p += size;
        for(int i = log; i >= 1; i--) { push(p >> i); }
        return d[p];
      }
      S prod(int l, int r) {
        assert(0 <= l && l <= r && r <= _n);
        if(l == r) { return e(); }
        l += size;
        r += size;
        for(int i = log; i >= 1; i--) {
          if(((l >> i) << i) != l) { push(l >> i); }
          if(((r >> i) << i) != r) { push((r - 1) >> i); }
        }
        S sml = e(), smr = e();
        while(l < r) {
          if(l & 1) { sml = op(sml, d[l++]); }
          if(r & 1) { smr = op(d[--r], smr); }
          l >>= 1;
          r >>= 1;
        }
        return op(sml, smr);
      }
      S all_prod() { return d[1]; }
      void apply(int p, F f) {
        assert(0 <= p && p < _n);
        p += size;
        for(int i = log; i >= 1; i--) { push(p >> i); }
        d[p] = mapping(f, d[p]);
        for(int i = 1; i <= log; i++) { update(p >> i); }
      }
      void apply(int l, int r, F f) {
        assert(0 <= l && l <= r && r <= _n);
        if(l == r) return;
        l += size;
        r += size;
        for(int i = log; i >= 1; i--) {
          if(((l >> i) << i) != l) { push(l >> i); }
          if(((r >> i) << i) != r) { push((r - 1) >> i); }
        }
        {
          int l2 = l, r2 = r;
          while(l < r) {
            if(l & 1) { all_apply(l++, f); }
            if(r & 1) { all_apply(--r, f); }
            l >>= 1;
            r >>= 1;
          }
          l = l2;
          r = r2;
        }
        for(int i = 1; i <= log; i++) {
          if(((l >> i) << i) != l) { update(l >> i); }
          if(((r >> i) << i) != r) { update((r - 1) >> i); }
        }
      }
      template<bool (*g)(S)> int max_right(int l) {
        return max_right(l, [](S x) { return g(x); });
      }
      template<class G> int max_right(int l, G g) {
        assert(0 <= l && l <= _n);
        assert(g(e()));
        if(l == _n) { return _n; }
        l += size;
        for(int i = log; i >= 1; i--) { push(l >> i); }
        S sm = e();
        do {
          while(l % 2 == 0) l >>= 1;
          if(!g(op(sm, d[l]))) {
            while(l < size) {
              push(l);
              l = (2 * l);
              if(g(op(sm, d[l]))) {
                sm = op(sm, d[l]);
                l++;
              }
            }
            return l - size;
          }
          sm = op(sm, d[l]);
          l++;
        } while((l & -l) != l);
        return _n;
      }
      template<bool (*g)(S)> int min_left(int r) {
        return min_left(r, [](S x) { return g(x); });
      }
      template<class G> int min_left(int r, G g) {
        assert(0 <= r && r <= _n);
        assert(g(e()));
        if(r == 0) { return 0; }
        r += size;
        for(int i = log; i >= 1; i--) { push((r - 1) >> i); }
        S sm = e();
        do {
          r--;
          while(r > 1 && (r % 2)) r >>= 1;
          if(!g(op(d[r], sm))) {
            while(r < size) {
              push(r);
              r = (2 * r + 1);
              if(g(op(d[r], sm))) {
                sm = op(d[r], sm);
                r--;
              }
            }
            return r + 1 - size;
          }
          sm = op(d[r], sm);
        } while((r & -r) != r);
        return 0;
      }

     private:
      int _n, size, log;
      std::vector<S> d;
      std::vector<F> lz;
      void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
      void all_apply(int k, F f) {
        d[k] = mapping(f, d[k]);
        if(k < size) {
          lz[k] = composition(f, lz[k]);
          if(d[k].fail) { push(k), update(k); }
        }
      }
      void push(int k) {
        all_apply(2 * k, lz[k]);
        all_apply(2 * k + 1, lz[k]);
        lz[k] = id();
      }
    };

    using ull = unsigned long long;
    constexpr ull dig = 60, mask = (1ULL << dig) - 1;

    struct S {
      ull max, range_or, range_and;
      bool fail;
      S(ull x = 0): max(x), range_or(x), range_and(x), fail(false) {}
    };
    struct F {
      ull bit_and, bit_or;
      F(): bit_and(mask), bit_or(0) {}
      F(ull a, ull o): bit_and(a), bit_or(o) {}
      static F b_and(ull x) noexcept { return {x, 0}; }
      static F b_or(ull x) noexcept { return {mask, x}; }
    };
    S op(S l, S r) {
      l.max = max(l.max, r.max);
      l.range_or |= r.range_or;
      l.range_and &= r.range_and;
      return l;
    }
    S e() { return S(); }
    S fx(F f, S x) {
      if((x.range_or - x.range_and) & (~f.bit_and | f.bit_or)) {
        x.fail = true;
        return x;
      }
      x.range_or = (x.range_or & f.bit_and) | f.bit_or;
      x.range_and = (x.range_and & f.bit_and) | f.bit_or;
      x.max = (x.max & f.bit_and) | f.bit_or;
      return x;
    }
    F fg(F f, F g) { return F{f.bit_and & g.bit_and, f.bit_or | g.bit_or}; }
    F id() { return F(); }
    """

  'Lazy_update/gcd_max/sum':
    'prefix':'Lazy_update/gcd_max/sum'
    'body':"""
    template<class S, auto op, auto e, class F, auto mapping, auto composition, auto id> struct lazy_segtree {
      static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>, "op must work as S(S, S)");
      static_assert(std::is_convertible_v<decltype(e), std::function<S()>>, "e must work as S()");
      static_assert(std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>, "mapping must work as F(F, S)");
      static_assert(std::is_convertible_v<decltype(composition), std::function<F(F, F)>>, "compostiion must work as F(F, F)");
      static_assert(std::is_convertible_v<decltype(id), std::function<F()>>, "id must work as F()");

     public:
      lazy_segtree(): lazy_segtree(0) {}
      explicit lazy_segtree(int n): lazy_segtree(std::vector<S>(n, e())) {}
      explicit lazy_segtree(const std::vector<S>& v): _n(int(v.size())) {
        size = (int)bit_ceil((unsigned int)(_n));
        log = countr_zero((unsigned int)size);
        d = std::vector<S>(2 * size, e());
        lz = std::vector<F>(size, id());
        for(int i = 0; i < _n; i++) { d[size + i] = v[i]; }
        for(int i = size - 1; i >= 1; i--) { update(i); }
      }
      void set(int p, S x) {
        assert(0 <= p && p < _n);
        p += size;
        for(int i = log; i >= 1; i--) { push(p >> i); }
        d[p] = x;
        for(int i = 1; i <= log; i++) { update(p >> i); }
      }
      S get(int p) {
        assert(0 <= p && p < _n);
        p += size;
        for(int i = log; i >= 1; i--) { push(p >> i); }
        return d[p];
      }
      S prod(int l, int r) {
        assert(0 <= l && l <= r && r <= _n);
        if(l == r) { return e(); }
        l += size;
        r += size;
        for(int i = log; i >= 1; i--) {
          if(((l >> i) << i) != l) { push(l >> i); }
          if(((r >> i) << i) != r) { push((r - 1) >> i); }
        }
        S sml = e(), smr = e();
        while(l < r) {
          if(l & 1) { sml = op(sml, d[l++]); }
          if(r & 1) { smr = op(d[--r], smr); }
          l >>= 1;
          r >>= 1;
        }
        return op(sml, smr);
      }
      S all_prod() { return d[1]; }
      void apply(int p, F f) {
        assert(0 <= p && p < _n);
        p += size;
        for(int i = log; i >= 1; i--) { push(p >> i); }
        d[p] = mapping(f, d[p]);
        for(int i = 1; i <= log; i++) { update(p >> i); }
      }
      void apply(int l, int r, F f) {
        assert(0 <= l && l <= r && r <= _n);
        if(l == r) return;
        l += size;
        r += size;
        for(int i = log; i >= 1; i--) {
          if(((l >> i) << i) != l) { push(l >> i); }
          if(((r >> i) << i) != r) { push((r - 1) >> i); }
        }
        {
          int l2 = l, r2 = r;
          while(l < r) {
            if(l & 1) { all_apply(l++, f); }
            if(r & 1) { all_apply(--r, f); }
            l >>= 1;
            r >>= 1;
          }
          l = l2;
          r = r2;
        }
        for(int i = 1; i <= log; i++) {
          if(((l >> i) << i) != l) { update(l >> i); }
          if(((r >> i) << i) != r) { update((r - 1) >> i); }
        }
      }
      template<bool (*g)(S)> int max_right(int l) {
        return max_right(l, [](S x) { return g(x); });
      }
      template<class G> int max_right(int l, G g) {
        assert(0 <= l && l <= _n);
        assert(g(e()));
        if(l == _n) { return _n; }
        l += size;
        for(int i = log; i >= 1; i--) { push(l >> i); }
        S sm = e();
        do {
          while(l % 2 == 0) l >>= 1;
          if(!g(op(sm, d[l]))) {
            while(l < size) {
              push(l);
              l = (2 * l);
              if(g(op(sm, d[l]))) {
                sm = op(sm, d[l]);
                l++;
              }
            }
            return l - size;
          }
          sm = op(sm, d[l]);
          l++;
        } while((l & -l) != l);
        return _n;
      }
      template<bool (*g)(S)> int min_left(int r) {
        return min_left(r, [](S x) { return g(x); });
      }
      template<class G> int min_left(int r, G g) {
        assert(0 <= r && r <= _n);
        assert(g(e()));
        if(r == 0) { return 0; }
        r += size;
        for(int i = log; i >= 1; i--) { push((r - 1) >> i); }
        S sm = e();
        do {
          r--;
          while(r > 1 && (r % 2)) r >>= 1;
          if(!g(op(d[r], sm))) {
            while(r < size) {
              push(r);
              r = (2 * r + 1);
              if(g(op(d[r], sm))) {
                sm = op(d[r], sm);
                r--;
              }
            }
            return r + 1 - size;
          }
          sm = op(d[r], sm);
        } while((r & -r) != r);
        return 0;
      }

     private:
      int _n, size, log;
      std::vector<S> d;
      std::vector<F> lz;
      void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
      void all_apply(int k, F f) {
        d[k] = mapping(f, d[k]);
        if(k < size) {
          lz[k] = composition(f, lz[k]);
          if(d[k].fail) { push(k), update(k); }
        }
      }
      void push(int k) {
        all_apply(2 * k, lz[k]);
        all_apply(2 * k + 1, lz[k]);
        lz[k] = id();
      }
    };

    constexpr ll INF = 2e9;
    struct S {
      ll max, lcm, sz, sum;
      bool fail;
      S(): max(0), lcm(1), sz(0), sum(0), fail(false) {}
      S(ll x, ll sz = 1): max(x), lcm(x), sz(sz), sum(x * sz), fail(false) {}
    };
    struct F {
      ll g, upd;
      F(): g(0), upd(0) {}
      F(ll g, ll upd): g(g), upd(upd) {}
      static F gcd(ll x) noexcept { return F(x, 0); }
      static F update(ll x) noexcept { return F(0, x); }
    };
    S op(S l, S r) {
      if(!r.sz) { return l; }
      if(!l.sz) { return r; }
      S ret;
      ret.max = std::max(l.max, r.max);
      ret.sum = l.sum + r.sum;
      ret.lcm = min(INF, std::lcm(l.lcm, r.lcm));
      ret.sz = l.sz + r.sz;
      return ret;
    }
    S e() { return S(); }
    S fx(F f, S x) {
      if(x.fail) { return x; }
      if(f.upd) { x = S(f.upd, x.sz); }
      if(f.g) {
        if(x.sz * x.max == x.sum) { x = S(gcd(x.max, f.g), x.sz); }
        else if(x.lcm == INF || f.g % x.lcm) { x.fail = true; }
      }
      return x;
    }
    F fg(F f, F g) {
      if(f.upd) { return F::update(f.upd); }
      else if(g.upd) { return F::update(gcd(f.g, g.upd)); }
      else { return F::gcd(gcd(f.g, g.g)); }
    }
    F id() { return F(); }
    """

  'CentroidDecomposition':
    'prefix':'CentroidDecomposition'
    'body':"""
    struct CentroidDecomposition {
     private:
      const vector<vector<ll>> &g;
      vector<int> sub;
      vector<bool> vis;
      vector<vector<int>> tree;
      int root;
      int get_size(int v, int p) {
        sub[v] = 1;
        for(auto &nv : g[v]) {
          if(nv == p || vis[nv]) { continue; }
          sub[v] += get_size(nv, v);
        }
        return sub[v];
      }
      int get_centroid(int v, int p, int mid) {
        for(auto &nv : g[v]) {
          if(nv == p || vis[nv]) { continue; }
          if(sub[nv] > mid) { return get_centroid(nv, v, mid); }
        }
        return v;
      }
      int dfs(int v) {
        int centroid = get_centroid(v, -1, get_size(v, -1) / 2);
        vis[centroid] = true;
        for(auto &nv : g[centroid]) {
          if(!vis[nv]) {
            int nxt = dfs(nv);
            if(centroid != nxt) { tree[centroid].emplace_back(nxt); }
          }
        }
        vis[centroid] = false;
        return centroid;
      }

     public:
      CentroidDecomposition(const vector<vector<ll>> &g): g(g), sub(g.size(), 0), vis(g.size(), false), tree(g.size()) {}
      int build() { return root = dfs(0); }
      inline vector<int> operator[](ll i) { return tree[i]; }
    };
    """

  'DualSegTree':
    'prefix':'DualSegTree'
    'body':"""
    template<typename S, auto op, auto e> struct DualSegTree {
      vector<S> seg;
      int N, size = 1;
      DualSegTree(int n): DualSegTree(vector<S>(n, e())) {}
      DualSegTree(const vector<S> &v): N(v.size()) {
        while(size < N) { size <<= 1; }
        seg = vector<S>(size * 2, e());
        for(int i = 0; i < N; i++) { seg[size + i] = v[i]; }
      }
      void set(int i, const S &x) {
        i += size;
        for(int h = bit_width((unsigned)i); h; h--) {
          int j = i >> h;
          if(seg[j] != e()) {
            seg[j * 2] = op(seg[j * 2], seg[j]);
            seg[j * 2 + 1] = op(seg[j * 2 + 1], seg[j]);
            seg[j] = e();
          }
        }
        seg[i] = x;
      }
      S get(int i) {
        S r = e();
        for(i += size; i; i >>= 1) { r = op(r, seg[i]); }
        return r;
      }
      void apply(int l, int r, const S &x) {
        for(l += size, r += size; l < r; l >>= 1, r >>= 1) {
          if(l & 1) { seg[l++] = op(seg[l], x); }
          if(r & 1) { seg[r] = op(seg[--r], x); }
        }
      }
    };
    """

  'dualsegtree':
    'prefix':'dualsegtree'
    'body':'DualSegTree<S,op,e> seg($1);'

  'ErasablePriorityQueue':
    'prefix':'ErasablePriorityQueue'
    'body':"""
    template<typename T, typename Compare> struct ErasablePriorityQueue {
      priority_queue<T, vector<T>, Compare> q1, q2;
      ErasablePriorityQueue() {}
      ErasablePriorityQueue(initializer_list<T> ini): q1(ini.begin(), ini.end()) {}
      void push(T x) { q1.emplace(x); }
      void erase(T x) {
        if(!q1.empty() && q1.top() == x) {
          q1.pop();
          while(!q2.empty() && q1.top() == q2.top()) {
            q1.pop();
            q2.pop();
          }
        }
        else { q2.emplace(x); }
      }
      T top() const { return q1.top(); }
      int size() const { return q1.size() - q2.size(); }
      bool empty() const { return q1.empty(); }
    };
    """

  'ErasablePQ':
    'prefix':'ErasablePQ'
    'body':'ErasablePriorityQueue<${1:ll}, greater<${1:ll}>> $2'

  'ErasableQP':
    'prefix':'ErasableQP'
    'body':'ErasablePriorityQueue<${1:ll}, less<${1:ll}>> $2'

  'DynamicSegTree':
    'prefix':'DynamicSegTree'
    'body':"""
    template<typename S, auto op, auto e, int n> struct DynamicSegTree {
     private:
      struct Node;
      using Node_ptr = unique_ptr<Node>;
      struct Node {
        int idx;
        S val, prod;
        Node_ptr l, r;
        Node(int idx, S val): idx(idx), val(val), prod(val), l(nullptr), r(nullptr) {}
        void update() { prod = op(op(l ? l->prod : e(), val), r ? r->prod : e()); }
      };
      Node_ptr root;
      void set(Node_ptr &t, int a, int b, int p, S x) const {
        if(!t) {
          t = make_unique<Node>(p, x);
          return;
        }
        if(t->idx == p) {
          t->val = x;
          t->update();
          return;
        }
        int c = (a + b) >> 1;
        if(p < c) {
          if(t->idx < p) {
            swap(t->idx, p);
            swap(t->val, x);
          }
          set(t->l, a, c, p, x);
        }
        else {
          if(t->idx > p) {
            swap(t->idx, p);
            swap(t->val, x);
          }
          set(t->r, c, b, p, x);
        }
        t->update();
      }
      S get(const Node_ptr &t, int a, int b, int p) const {
        if(!t) { return e(); }
        if(t->idx == p) { return t->val; }
        int c = (a + b) >> 1;
        if(p < c) { return get(t->l, a, c, p); }
        else { return get(t->r, c, b, p); }
      }
      S prod(const Node_ptr &t, int a, int b, int l, int r) const {
        if(!t || b <= l || r <= a) { return e(); }
        if(l <= a && b <= r) { return t->prod; }
        int c = (a + b) >> 1;
        S res = prod(t->l, a, c, l, r);
        if(l <= t->idx && t->idx < r) { res = op(res, t->val); }
        return op(res, prod(t->r, c, b, l, r));
      }
      void reset(Node_ptr &t, int a, int b, int l, int r) const {
        if(!t || b <= l || r <= a) { return; }
        if(l <= a && b <= r) {
          t->reset();
          return;
        }
        int c = (a + b) >> 1;
        reset(t->l, a, c, l, r);
        reset(t->r, c, b, l, r);
        t->update();
      }
      template<typename F> int max_right(const Node_ptr &t, int a, int b, int l, const F &f, S &p) const {
        if(!t || b <= l) { return n; }
        if(f(op(p, t->prod))) {
          p = op(p, t->prod);
          return n;
        }
        int c = (a + b) >> 1;
        int res = max_right(t->l, a, c, l, f, p);
        if(res != n) { return res; }
        if(l <= t->idx) {
          p = op(p, t->val);
          if(!f(p)) { return t->idx; }
        }
        return max_right(t->r, c, b, l, f, p);
      }
      template<typename F> int min_left(const Node_ptr &t, int a, int b, int r, const F &f, S &p) const {
        if(!t || r <= a) { return 0; }
        if(f(op(p, t->prod))) {
          p = op(p, t->prod);
          return 0;
        }
        int c = (a + b) >> 1;
        int res = min_left(t->r, c, b, r, f, p);
        if(res) { return res; }
        if(t->idx < r) {
          p = op(p, t->val);
          if(!f(p)) { return t->idx + 1; }
        }
        return min_left(t->l, a, c, r, f, p);
      }

     public:
      DynamicSegTree(): root(nullptr) {}
      void set(int i, S x) { set(root, 0, n, i, x); }
      S get(int i) const { return get(root, 0, n, i); }
      S prod(int l, int r) const { return prod(root, 0, n, l, r); }
      S all_prod() const { return root ? root->prod : e(); }
      void reset(int l, int r) { reset(root, 0, n, l, r); }
      template<auto f> int max_right(int l) const {
        return max_right(l, [](S x) { return f(x); });
      }
      template<typename F> int max_right(int l, const F &f) const {
        S p = e();
        return max_right(root, 0, n, l, f, p);
      }
      template<auto f> int min_left(int r) const {
        return min_left(r, [](S x) { return f(x); });
      }
      template<typename F> int min_left(int r, const F &f) const {
        S p = e();
        return min_left(root, 0, n, r, f, p);
      }
    };
    """

  'dynamicsegtree':
    'prefix':'dynamicsegtree'
    'body':'DynamicSegTree<S,op,e,$1> seg;$2'

  'vb':
    'prefix':'vb'
    'body':'vector<bool> '

  'DualBIT':
    'prefix':'DualBIT'
    'body':"""
    template<typename T> struct DualBIT {
      fenwick_tree<T> f1, f2;
      DualBIT(int N): f1(N + 1), f2(N + 1) {}
      void add(int i, T x) { add(i, i + 1, x); }
      void add(int l, int r, T x) {
        f1.add(l, x), f1.add(r, -x);
        f2.add(l, -x * (l - 1)), f2.add(r, x * (r - 1));
      }
      T sum(int i) { return f1.sum(0, i) * (i - 1) + f2.sum(0, i); }
      T sum(int l, int r) { return sum(r) - sum(l); }
      T operator[](int i) { return sum(i + 1) - sum(i); }
    };
    """

  'dualBIT':
    'prefix':'dualBIT'
    'body':'DualBIT<ll>'

  'OfflineDynamicConnectivity':
    'prefix':'OfflineDynamicConnectivity'
    'body':"""
    template<typename S, auto op, auto e> struct RollbackUnionfind {
     private:
      vector<int> par;
      vector<S> val;
      stack<tuple<int, int, S, int>> history;
      int snap, cnt;

     public:
      RollbackUnionfind() = default;
      RollbackUnionfind(int n): RollbackUnionfind(vector<S>(n, e())) {}
      RollbackUnionfind(const vector<S> &v): par(v.size(), -1), val(v), snap(0), cnt(v.size()) {}
      int root(int v) const {
        if(par[v] < 0) { return v; }
        return root(par[v]);
      }
      void unite(int u, int v) {
        u = root(u), v = root(v);
        history.emplace(-1, 0, e(), cnt);
        history.emplace(u, par[u], val[u], cnt);
        history.emplace(v, par[v], val[v], cnt);
        if(u == v) { return; }
        if(par[u] > par[v]) { swap(u, v); }
        par[u] += par[v];
        par[v] = u;
        val[u] = op(val[u], val[v]);
        cnt--;
      }
      void undo() {
        assert(!history.empty());
        while(true) {
          auto [v, p, x, c] = history.top();
          history.pop();
          if(v == -1) { break; }
          par[v] = p;
          val[v] = x;
          cnt = c;
        }
      }
      bool same(int u, int v) const { return root(u) == root(v); }
      int size(int v) const { return -par[root(v)]; }
      int count() const { return cnt; }
      S prod(int v) const { return val[root(v)]; }
      void update(int v, const S &x) {
        v = root(v);
        history.emplace(-1, 0, e(), cnt);
        history.emplace(v, par[v], val[v], cnt);
        val[v] = op(val[x], x);
      }
      int state() const { return history.size(); }
      void snapshot() { snap = history.size(); }
      void rollback(int p = -1) {
        if(p == -1) { p = snap; }
        while(p < (int)history.size()) { undo(); }
      }
    };

    template<typename S, auto op, auto e> struct OfflineDynamicConnectivity {
     private:
      int idx;
      multimap<pair<int, int>, int> open;
      vector<tuple<int, int, int, int>> closed;
      vector<tuple<int, int, S>> query_update;
      map<int, pair<int, int>> query_same;
      map<int, int> query_prod, query_size;
      vector<int> query_count;
      vector<S> val;

     public:
      OfflineDynamicConnectivity() = default;
      OfflineDynamicConnectivity(int n): OfflineDynamicConnectivity(vector<S>(n, e())) {}
      OfflineDynamicConnectivity(const vector<S> &v): val(v), idx(0) {}
      void unite(int u, int v) {
        auto edge = minmax(u, v);
        open.emplace(edge, ++idx);
      }
      void cut(int u, int v) {
        auto edge = minmax(u, v);
        auto it = open.find(edge);
        assert(it != open.end());
        closed.emplace_back(edge.first, edge.second, it->second, ++idx);
        open.erase(it);
      }
      void update(int v, const S &x) { query_update.emplace_back(++idx, v, x); }
      void same(int u, int v) { query_same[++idx] = {u, v}; }
      void prod(int v) { query_prod[++idx] = v; }
      void size(int v) { query_size[++idx] = v; }
      void count() { query_count.emplace_back(++idx); }
      vector<pair<int, S>> build() {
        idx++;
        for(auto &[edge, s] : open) { closed.emplace_back(edge.first, edge.second, s, idx); }
        int size = bit_ceil((unsigned)idx);
        vector<vector<pair<int, int>>> edges(size << 1);
        vector<vector<pair<int, S>>> updates(size << 1);
        for(auto &[u, v, s, t] : closed) {
          for(s += size, t += size; s < t; s >>= 1, t >>= 1) {
            if(s & 1) { edges[s++].emplace_back(u, v); }
            if(t & 1) { edges[--t].emplace_back(u, v); }
          }
        }
        for(auto &[s, v, x] : query_update) {
          int t = size;
          for(s += size, t += size; s < t; s >>= 1, t >>= 1) {
            if(s & 1) { updates[s++].emplace_back(v, x); }
            if(t & 1) { updates[--t].emplace_back(v, x); }
          }
        }
        RollbackUnionfind<S, op, e> uf(val);
        vector<pair<int, S>> r;
        auto dfs = [&](auto &&dfs, int k) -> void {
          for(auto &[u, v] : edges[k]) { uf.unite(u, v); }
          for(auto &[v, x] : updates[k]) { uf.update(v, x); }
          if(k < size) {
            dfs(dfs, 2 * k);
            dfs(dfs, 2 * k + 1);
          }
          else if(k < size + idx) {
            if(query_same.contains(k - size)) {
              auto [u, v] = query_same[k - size];
              r.emplace_back(uf.same(u, v), e());
            }
            if(query_prod.contains(k - size)) { r.emplace_back(false, uf.prod(query_prod[k - size])); }
            if(query_size.contains(k - size)) { r.emplace_back(uf.size(query_size[k - size]), e()); }
            if(ranges::binary_search(query_count, k - size)) { r.emplace_back(uf.count(), e()); }
          }
          for(int i = 0; i < (int)(edges[k].size() + updates[k].size()); i++) { uf.undo(); }
        };
        dfs(dfs, 1);
        return r;
      }
    };
    """

  'offlinedynamicconnectivity':
    'prefix':'offlinedynamicconnectivity'
    'body':'OfflineDynamicConnectivity<S,op,e> u(N);'

  'stringcontains':
    'prefix':'stringcontains'
    'body':"""
    bool contains(const string &s, const string &t) {
      int n = s.size(), m = t.size();
      auto z = z_algorithm(t + s);
      for(int i = m; i <= n; i++) {
        if(z[i] >= m) { return true; }
      }
      return false;
    }
    """

  'TravelingSalesmanProblem':
    'prefix':'TravelingSalesmanProblem'
    'body':"""
    vector<vector<ll>> dp(1 << N, vector<ll>(N, 1e18));
    for(int i = 0; i < N; i++) { dp[1 << i][i] = 0; }
    for(int i = 0; i < 1 << N; i++) {
      for(int j = 0; j < N; j++) {
        if(~i >> j & 1) { continue; }
        for(int k = 0; k < N; k++) {
          if(i >> k & 1) { continue; }
          dp[i | 1 << k][k] = min(dp[i | 1 << k][k], dp[i][j] + d[j][k]);
        }
      }
    }
    """

  'fast_set':
    'prefix':'fast_set'
    'body':"""
    struct fast_set {
     private:
      static constexpr int B = 64;
      int n, cnt;
      vector<vector<uint64_t>> d;
      static int bsf(uint64_t x) { return __builtin_ctzll(x); }
      static int bsr(uint64_t x) { return 63 - __builtin_clzll(x); }

     public:
      fast_set(int n): n(n), cnt(0) {
        do {
          n = (n + B - 1) / B;
          d.emplace_back(vector<uint64_t>(n));
        } while(n > 1);
      }
      bool contains(int i) const { return (d[0][i / B] >> (i % B)) & 1; }
      void insert(int i) {
        if(contains(i)) { return; }
        ++cnt;
        for(auto &v : d) {
          bool f = v[i / B];
          v[i / B] |= 1ULL << (i % B);
          i /= B;
          if(f) { break; }
        }
      }
      void erase(int i) {
        if(!contains(i)) { return; }
        --cnt;
        for(auto &v : d) {
          v[i / B] &= ~(1ULL << (i % B));
          i /= B;
          if(v[i]) { break; }
        }
      }
      int next(int i) const {
        for(auto itr = d.cbegin(); itr != d.cend(); ++itr, i = i / B + 1) {
          if(i / B >= int(itr->size())) { break; }
          if(auto t = itr->at(i / B) >> (i % B); t) {
            i += bsf(t);
            while(itr != d.cbegin()) { i = i * B + bsf((--itr)->at(i)); }
            return i;
          }
        }
        return n;
      }
      int prev(int i) const {
        for(auto itr = d.cbegin(); itr != d.cend() && i >= 0; ++itr, i = i / B - 1) {
          if(auto t = itr->at(i / B) << (B - 1 - i % B); t) {
            i += bsr(t) - (B - 1);
            while(itr != d.cbegin()) { i = i * B + bsr((--itr)->at(i)); }
            return i;
          }
        }
        return -1;
      }
      int min() const { return next(0); }
      int max() const { return prev(n - 1); }
      int size() const { return cnt; }
      bool empty() const { return cnt == 0; }
      void clear() {
        if(!cnt) { return; }
        cnt = 0;
        auto rec = [&](auto &&self, int t, int x) -> void {
          if(t) {
            for(auto m = d[t][x]; m;) {
              int i = bsf(m);
              m -= 1ULL << i;
              self(self, t - 1, x * B + i);
            }
          }
          d[t][x] = 0;
        };
        rec(rec, d.size() - 1, 0);
      }
    };
    """

  'ProjectSelectionProblem':
    'prefix':'ProjectSelectionProblem'
    'body':"""
    struct ProjectSelectionProblem {
      int N, S, G;
      ll offset;
      vector<tuple<int, int, ll>> e;
      mf_graph<ll> g;
      ProjectSelectionProblem(int n): N(n + 2), S(n), G(n + 1), offset(0) {}
      void cost0(int i, ll c) { e.emplace_back(i, G, c); }
      void cost1(int i, ll c) { e.emplace_back(S, i, c); }
      void get0(int i, ll c) {
        offset += c;
        e.emplace_back(S, i, c);
      }
      void get1(int i, ll c) {
        offset += c;
        e.emplace_back(i, G, c);
      }
      void cost01(int i, int j, ll c) { e.emplace_back(i, j, c); }
      void cost10(int i, int j, ll c) { e.emplace_back(j, i, c); }
      void get00(int i, int j, ll c) {
        offset += c;
        e.emplace_back(S, N, c);
        e.emplace_back(N, i, 1e18);
        e.emplace_back(N, j, 1e18);
        N++;
      }
      void get11(int i, int j, ll c) {
        offset += c;
        e.emplace_back(N, G, c);
        e.emplace_back(i, N, 1e18);
        e.emplace_back(j, N, 1e18);
        N++;
      }
      template<typename T> void getall0(vector<T> &v, ll c) {
        offset += c;
        e.emplace_back(S, N, c);
        for(auto &i : v) { e.emplace_back(N, i, 1e18); }
        N++;
      }
      template<typename T> void getall1(vector<T> &v, ll c) {
        offset += c;
        e.emplace_back(N, G, c);
        for(auto &i : v) { e.emplace_back(i, N, 1e18); }
        N++;
      }
      ll build() {
        g = mf_graph<ll>(N);
        for(auto &[s, t, c] : e) { g.add_edge(s, t, c); }
        return g.flow(S, G) - offset;
      }
      vector<bool> restore() {
        auto r = g.min_cut(S);
        for(int i = 0; i < N; i++) { r[i] = !r[i]; }
        return r;
      }
    };
    """

  'ManhattanMST':
    'prefix':'ManhattanMST'
    'body':"""
    template<typename T> vector<tuple<T, int, int>> ManhattanMST(vector<T> &xs, vector<T> &ys) {
      const int N = xs.size();
      vector<int> idx(N);
      iota(idx.begin(), idx.end(), 0);
      vector<tuple<T, int, int>> tmp, ret;
      for(int s = 0; s < 2; s++) {
        for(int t = 0; t < 2; t++) {
          ranges::sort(idx, [&](int i, int j) { return xs[i] + ys[i] < xs[j] + ys[j]; });
          map<T, int> sweep;
          for(auto &i : idx) {
            for(auto it = sweep.lower_bound(-ys[i]); it != sweep.end(); it = sweep.erase(it)) {
              int j = it->second;
              if(xs[i] - xs[j] < ys[i] - ys[j]) { break; }
              tmp.emplace_back(abs(xs[i] - xs[j]) + abs(ys[i] - ys[j]), i, j);
            }
            sweep[-ys[i]] = i;
          }
          swap(xs, ys);
        }
        for(auto &x : xs) { x = -x; }
      }
      ranges::sort(tmp);
      dsu u(N);
      for(auto &[w, a, b] : tmp) {
        if(u.same(a, b)) { continue; }
        u.merge(a, b);
        ret.emplace_back(w, a, b);
      }
      return ret;
    }
    """

  'DequeAggregation':
    'prefix':'DequeAggregation'
    'body':"""
    template<typename T, auto op, auto e> struct DequeAggregation {
      static_assert(is_convertible_v<decltype(op), function<T(T, T)>>);
      static_assert(is_convertible_v<decltype(e), function<T()>>);

     private:
      struct Itr {
        vector<pair<T, T>>::const_reverse_iterator it_l;
        vector<pair<T, T>>::const_reverse_iterator it_l_end;
        vector<pair<T, T>>::const_iterator it_r;
        vector<pair<T, T>>::const_iterator it_r_begin;
        Itr &operator++() {
          it_l == it_l_end ? it_r++ : it_l++;
          return *this;
        }
        Itr operator++(int) {
          Itr ret = *this;
          ++(*this);
          return ret;
        }
        Itr &operator--() {
          it_r == it_r_begin ? it_l-- : it_r--;
          return *this;
        }
        Itr operator--(int) {
          Itr ret = *this;
          --(*this);
          return ret;
        }
        Itr &operator+=(int diff) {
          if(diff < 0) { return *this -= -diff; }
          if(int d = it_l_end - it_l; d < diff) {
            it_l = it_l_end;
            it_r += diff - d;
          }
          else { it_l += diff; }
          return *this;
        }
        friend Itr operator+(Itr it, int diff) {
          it += diff;
          return it;
        }
        friend Itr operator+(int diff, Itr it) {
          it += diff;
          return it;
        }
        Itr &operator-=(int diff) {
          if(diff < 0) { return *this += -diff; }
          if(int d = it_r - it_r_begin; d < diff) {
            it_r = it_r_begin;
            it_l -= diff - d;
          }
          else { it_r -= diff; }
          return *this;
        }
        friend Itr operator-(Itr it, int diff) {
          it -= diff;
          return it;
        }
        int operator-(const Itr &r) const {
          int d1 = it_l == it_l_end ? it_r - it_r_begin : it_l - it_l_end;
          int d2 = r.it_l == r.it_l_end ? r.it_r - r.it_r_begin : r.it_l - r.it_l_end;
          return d1 - d2;
        }
        const T &operator[](int i) const { return *((*this) + i); }
        const T &operator*() const { return it_l == it_l_end ? it_r->first : it_l->first; }
        bool operator!=(const Itr &r) const { return it_l != r.it_l || it_r != r.it_r; }
        bool operator==(const Itr &r) const { return !(*this != r); }
        bool operator<(const Itr &r) const { return (*this) - r < 0; }
        bool operator<=(const Itr &r) const { return (*this) - r <= 0; }
        bool operator>(const Itr &r) const { return (*this) - r > 0; }
        bool operator>=(const Itr &r) const { return (*this) - r >= 0; }
      };

      vector<pair<T, T>> st_l, st_r;
      T prod(const vector<pair<T, T>> &st) const { return st.empty() ? e() : st.back().second; }

     public:
      DequeAggregation() = default;
      template<typename InputItr, enable_if_t<is_constructible_v<T, typename InputItr::T>, nullptr_t> = nullptr>
      DequeAggregation(InputItr first, InputItr last) {
        for(; first != last; first++) { push_back(*first); }
      }
      template<typename Container, enable_if_t<is_constructible_v<T, typename Container::T>, nullptr_t> = nullptr>
      DequeAggregation(const Container &c): DequeAggregation(begin(c), end(c)) {}
      T prod() const { return op(prod(st_l), prod(st_r)); }
      void push_back(const T &val) { st_r.emplace_back(val, op(prod(st_r), val)); }
      void push_front(const T &val) { st_l.emplace_back(val, op(val, prod(st_l))); }
      void pop_back() {
        if(st_r.size()) { return st_r.pop_back(); }
        const int sz = st_l.size();
        const int l = sz >> 1, r = sz - l;
        for(int i = r - 1; i; i--) { push_back(move(st_l[i].first)); }
        st_l.erase(st_l.begin(), st_l.begin() + r);
        if(!l) { return; }
        st_l[0].second = st_l[0].first;
        for(int i = 1; i < l; i++) { st_l[i].second = op(st_l[i].first, st_l[i - 1].second); }
      }
      void pop_front() {
        if(st_l.size()) { return st_l.pop_back(); }
        const int sz = st_r.size();
        const int r = sz >> 1, l = sz - r;
        for(int i = l - 1; i; i--) { push_front(move(st_r[i].first)); }
        st_r.erase(st_r.begin(), st_r.begin() + l);
        if(!r) { return; }
        st_r[0].second = st_r[0].first;
        for(int i = 1; i < r; i++) { st_r[i].second = op(st_r[i - 1].second, st_r[i].first); }
      }
      const T &front() const { return st_l.size() ? st_l.back().first : st_r.front().first; }
      const T &back() const { return st_r.size() ? st_r.back().first : st_l.front().first; }
      const T &operator[](int i) const {
        const int k = i - st_l.size();
        return k < 0 ? st_l[~k].first : st_r[k].first;
      }
      int size() const { return st_l.size() + st_r.size(); }
      void clear() {
        st_l.clear();
        st_r.clear();
      }
      void shrink() {
        st_l.shrink_to_fit();
        st_r.shrink_to_fit();
      }
      Itr begin() const { return Itr{st_l.rbegin(), st_l.rend(), st_r.begin(), st_r.begin()}; }
      Itr end() const { return Itr{st_l.rend(), st_l.rend(), st_r.begin(), st_r.end()}; }
      Itr cbegin() const { return begin(); }
      Itr cend() const { return end(); }
    };
    """

  'SubstringSet':
    'prefix':'SubstringSet'
    'body':"""
    template<typename T, typename SequenceType> struct SuffixAutomatonBase {
      struct Node {
        map<T, int> nxt;
        int link, len;
        bool cloned;
        int index;
      };

      vector<Node> nodes;
      int last;

      SuffixAutomatonBase() {
        nodes.push_back({{}, -1, 0, false, -1});
        last = 0;
      }
      SuffixAutomatonBase(const SequenceType &s): SuffixAutomatonBase() {
        for(const T &c : s) { append(c); }
      }

      void append(const T &c) {
        const int new_node = nodes.size();
        const int new_node_index = nodes[last].index + 1;
        nodes.push_back({{}, -1, nodes[last].len + 1, false, new_node_index});
        int p = last;
        for(; p != -1 && !nodes[p].nxt.count(c); p = nodes[p].link) { nodes[p].nxt[c] = new_node; }
        const int q = p == -1 ? 0 : nodes[p].nxt[c];
        if(p == -1 || nodes[p].len + 1 == nodes[q].len) { nodes[new_node].link = q; }
        else {
          const int clone_node = nodes.size();
          nodes.push_back({nodes[q].nxt, nodes[q].link, nodes[p].len + 1, true, new_node_index});
          for(; p != -1 && nodes[p].nxt[c] == q; p = nodes[p].link) { nodes[p].nxt[c] = clone_node; }
          nodes[new_node].link = nodes[q].link = clone_node;
        }
        last = new_node;
      }
      SuffixAutomatonBase &operator+=(const T &c) {
        append(c);
        return *this;
      }

      int transition(const SequenceType &t, int invalid_state = -1) const {
        int cur = 0;
        for(const auto &c : t) {
          auto it = nodes[cur].nxt.find(c);
          if(it == nodes[cur].nxt.end()) { return invalid_state; }
          cur = it->second;
        }
        return cur;
      }

      bool accept(const SequenceType &t) const { return transition(t) != -1; }

      struct SubstringCounter {
       public:
        SubstringCounter(const SuffixAutomatonBase *sa): sa(sa), n(sa->nodes.size()), dp(n, 0) {
          const vector<Node> &nodes = sa->nodes;
          for(const int u : sa->topological_order(true)) {
            dp[u] += !nodes[u].cloned;
            const int p = nodes[u].link;
            if(p >= 0) { dp[p] += dp[u]; }
          }
        }
        long long count(const SequenceType &t) const {
          const int state = sa->transition(t);
          return state == -1 ? 0 : dp[state];
        }

       private:
        const SuffixAutomatonBase *sa;
        int n;
        vector<long long> dp;
      };

      SubstringCounter substring_counter() const & { return SubstringCounter{this}; }
      SubstringCounter substring_counter() const && = delete;

      struct SuffixLinkTree {
       public:
        SuffixLinkTree(const SuffixAutomatonBase *sa): sa(sa), g(sa->nodes.size()) {
          const int n = g.size();
          for(int i = 1; i < n; i++) { g[sa->nodes[i].link].push_back(i); }
        }
        int size() const { return g.size(); }
        const vector<int> &operator[](int i) const { return g[i]; }

       private:
        const SuffixAutomatonBase *sa;
        vector<vector<int>> g;
      };

      SuffixLinkTree suffix_link_tree() const & { return SuffixLinkTree(this); }
      SuffixLinkTree suffix_link_tree() const && = delete;

      struct OccurrenceEnumerator {
       public:
        OccurrenceEnumerator(const SuffixAutomatonBase *sa): sa(sa), t(sa->suffix_link_tree()) {}

        // returns vector of i s.t. S[i:i+|t|] = t
        vector<int> enumerate_all_occurrence(const SequenceType &pattern) const {
          const int state = sa->transition(pattern);
          if(state == -1) { return {}; }
          const vector<Node> &nodes = sa->nodes;
          const int l = pattern.size();
          vector<int> res;
          auto dfs = [&](auto self, int u) -> void {
            if(!nodes[u].cloned) { res.push_back(nodes[u].len - l); }
            for(const int v : t[u]) { self(self, v); }
          };
          dfs(dfs, state);
          return res;
        }

       private:
        const SuffixAutomatonBase *sa;
        SuffixLinkTree t;
      };

      OccurrenceEnumerator occurrence_enumerator() const & { return OccurrenceEnumerator(this); }
      OccurrenceEnumerator occurrence_enumerator() const && = delete;

      struct FirstOccurenceSearcher {
       public:
        FirstOccurenceSearcher(const SuffixAutomatonBase *sa): sa(sa) {
          const vector<Node> &nodes = sa->nodes;
          dp.resize(nodes.size(), numeric_limits<int>::max());
          for(const int u : sa->topological_order(true)) {
            if(!nodes[u].cloned) { dp[u] = nodes[u].len; }
            const int p = nodes[u].link;
            if(p >= 0 && nodes[p].cloned) { dp[p] = min(dp[p], dp[u]); }
          }
        }

        // returns min { i | S[i:i+|t|] = t }. if such i does !exist, returns -1.
        int first_occurrence(const SequenceType &t) const {
          const int state = sa->transition(t);
          if(state == -1) { return -1; }
          return dp[state] - t.size();
        }

       private:
        const SuffixAutomatonBase *sa;
        vector<int> dp;
      };

      FirstOccurenceSearcher first_occurence_searcher() const & { return FirstOccurenceSearcher(this); }
      FirstOccurenceSearcher first_occurence_searcher() const && = delete;

      // returns { start_s, start_t, len } s.t. lcs = s[start_s: start_s+len] t[start_t: start_t+len]
      tuple<int, int, int> longest_common_substring(const SequenceType &t) const {
        if(t.size() == 0) { return {0, 0, 0}; }
        const Node *v = &nodes[0];
        int l = 0, max_len = 0, s_end_pos = 0, t_end_pos = 0;
        for(int i = 0; i < (int)t.size(); i++) {
          while(v->link != -1 && !v->nxt.count(t[i])) {
            v = &nodes[v->link];
            l = v->len;
          }
          auto it = v->nxt.find(t[i]);
          if(it != v->nxt.end()) {
            v = &nodes[it->second];
            l++;
          }
          if(l > max_len) {
            max_len = l;
            t_end_pos = i;
            s_end_pos = v->index;
          }
        }
        if(max_len == 0) { return {0, 0, 0}; }
        return {s_end_pos - max_len + 1, t_end_pos - max_len + 1, max_len};
      }

      vector<int> topological_order(bool reversed = false) const {
        const int n = nodes.size();
        vector<int> in(n, 0);
        for(const auto &node : nodes) {
          for(const auto &p : node.nxt) { in[p.second]++; }
        }
        deque<int> dq;
        for(int i = 0; i < n; i++) {
          if(!in[i]) { dq.push_back(i); }
        }
        vector<int> res;
        while(dq.size()) {
          int u = dq.front();
          dq.pop_front();
          res.push_back(u);
          for(const auto &p : nodes[u].nxt) {
            if(!--in[p.second]) { dq.push_back(p.second); }
          }
        }
        if(reversed) { ranges::reverse(res); }
        assert((int)res.size() == n);
        return res;
      }
    };

    template<typename T> struct SuffixAutomaton : public SuffixAutomatonBase<T, vector<T>> {
      using SuffixAutomatonBase<T, vector<T>>::SuffixAutomatonBase;
      using value_type = T;
      using sequence_type = vector<T>;
    };

    template<typename T> SuffixAutomaton(vector<T>) -> SuffixAutomaton<T>;

    template<> struct SuffixAutomaton<char> : public SuffixAutomatonBase<char, string> {
      using SuffixAutomatonBase<char, string>::SuffixAutomatonBase;
      using value_type = char;
      using sequence_type = string;
    };

    SuffixAutomaton(string) -> SuffixAutomaton<char>;

    template<typename T> struct SubstringSet {
     public:
      using value_type = typename SuffixAutomaton<T>::sequence_type;
      using size_type = long long;
      using difference_type = size_type;

      // create empty set
      SubstringSet(): SubstringSet(value_type{}) {}
      // create set of all substrings in `s`
      SubstringSet(const value_type &s) { build(s); }
      // build set of all substrings in `s`
      void build(const value_type &s) {
        sa = SuffixAutomaton(s);
        dp.resize(sa.nodes.size(), size_type(1));
        for(const int u : sa.topological_order(true)) {
          for(const auto &p : sa.nodes[u].nxt) { dp[u] += dp[p.second]; }
        }
      }
      size_type size() const { return dp[0]; }
      bool contains(const value_type &t) const { return sa.accept(t); }
      // the k'th lexicographically smallest substring, O(|return value|).
      value_type operator[](size_type k) const {
        assert(0 <= k && k < dp[0]);
        int cur = 0;
        value_type res;
        while(k--) {
          for(const auto &[e, v] : sa.nodes[cur].nxt) {
            if(k < dp[v]) {
              res.push_back(e);
              cur = v;
              break;
            }
            else { k -= dp[v]; }
          }
        }
        return res;
      }
      // the k'th lexicographically smallest substring, O(|return value|).
      value_type kth_element(size_type k) const { return (*this)[k]; }
      // number of { s | s < t, s is in this set }, O(|min(t, max_substr_len)|).
      size_type count_lt(const value_type &t) const {
        size_type res = 0;
        int cur = 0;
        for(const T &c : t) {
          res++;
          auto it_r = sa.nodes[cur].nxt.lower_bound(c);
          for(auto it_l = sa.nodes[cur].nxt.begin(); it_l != it_r; it_l++) { res += dp[it_l->second]; }
          if(it_r == sa.nodes[cur].nxt.end() || it_r->first != c) { break; }
          cur = it_r->second;
        }
        return res;
      }
      // number of { s | s <= t, s is in this set }, O(min(|t|, max_substr_len)).
      size_type count_leq(const value_type &t) const { return count_lt(t) + contains(t); }
      // number of { s | s > t, s is in this set }, O(min(|t|, max_substr_len)).
      size_type count_gt(const value_type &t) const { return size() - count_leq(t); }
      // number of { s | s >= t, s is in this set }, O(min(|t|, max_substr_len)).
      size_type count_geq(const value_type &t) const { return size() - count_lt(t); }
      // number of { s | l <= s <= r, s is in this set }, O(min(|t|, max_substr_len)).
      size_type count_range(const value_type &l, const value_type &r) const { return l >= r ? 0 : count_lt(r) - count_lt(l); }

      // min { s | s >= t, s is in this set }, O(|return value| + min(|t|, max_substr_len))
      value_type min_geq(const value_type &t) const { return (*this)[count_lt(t)]; }
      // min { s | s > t, s is in this set }, O(|return value| + min(|t|, max_substr_len))
      value_type min_gt(const value_type &t) const { return (*this)[count_leq(t)]; }
      // max { s | s < t, s is in this set }, O(|return value| + min(|t|, max_substr_len))
      value_type max_lt(const value_type &t) const { return (*this)[count_lt(t) - 1]; }
      // max { s | s <= t, s is in this set }, O(|return value| + min(|t|, max_substr_len))
      value_type max_leq(const value_type &t) const { return (*this)[count_leq(t) - 1]; }

      // iterator

      // operator*: O(|return value|), other operations: O(1).
      struct SubstringSetIterator {
       public:
        SubstringSetIterator(const SubstringSet *st, size_type k): st(st), k(k) {}
        value_type operator*() const { return st->kth_substring(k); }
        auto &operator=(const SubstringSetIterator &other) {
          st = other.st;
          k = other.k;
          return *this;
        }
        auto &operator++() {
          k++;
          return *this;
        }
        auto &operator--() {
          k--;
          return *this;
        }
        auto &operator+=(difference_type d) {
          k += d;
          return *this;
        }
        auto &operator-=(difference_type d) {
          k -= d;
          return *this;
        }
        auto operator+(difference_type d) { return SubstringSetIterator{st, k + d}; }
        auto operator-(difference_type d) { return SubstringSetIterator{st, k - d}; }
        difference_type operator-(const SubstringSetIterator &other) { return k - other.k; }
        bool operator==(const SubstringSetIterator &other) const { return k == other.k; }
        bool operator!=(const SubstringSetIterator &other) const { return k != other.k; }
        bool operator<(const SubstringSetIterator &other) const { return k < other.k; }
        bool operator<=(const SubstringSetIterator &other) const { return k <= other.k; }
        bool operator>(const SubstringSetIterator &other) const { return k > other.k; }
        bool operator>=(const SubstringSetIterator &other) const { return k >= other.k; }

       protected:
        const SubstringSet *st;
        size_type k;
      };

      // operator*: O(|return value|), other operations: O(1).
      struct ReversedSubstringSetIterator : public SubstringSetIterator {
        using SubstringSetIterator::SubstringSetIterator;
        value_type operator*() const { return this->st->kth_element(this->st->size() - this->k - 1); }
      };
      using iterator = SubstringSetIterator;
      using reverse_iterator = ReversedSubstringSetIterator;
      using const_iterator = iterator;
      using const_reverse_iterator = reverse_iterator;
      auto begin() const { return iterator{this, 0LL}; }
      auto end() const { return iterator{this, size()}; }
      auto cbegin() const { return begin(); }
      auto cend() const { return end(); }
      auto rbegin() const { return reverse_iterator{this, 0LL}; }
      auto rend() const { return reverse_iterator{this, size()}; }
      auto crbegin() const { return rbegin(); }
      auto crend() const { return rend(); }
      // O(|min(t, max_substr_len)|).
      auto lower_bound(const value_type &t) const { return iterator{this, count_lt(t)}; }
      // O(|min(t, max_substr_len)|).
      auto upper_bound(const value_type &t) const { return iterator{this, count_leq(t)}; }
      // O(|min(t, max_substr_len)|).
      auto find(const value_type &t) const {
        auto it = lower_bound(t);
        if(it == end() || t != *it) { return end(); }
        return it;
      }

     private:
      SuffixAutomaton<T> sa;
      std::vector<size_type> dp;
    };

    template<typename T> SubstringSet(std::vector<T>) -> SubstringSet<T>;

    SubstringSet(std::string) -> SubstringSet<char>;
    """

  'MinMaxPlusConvolution':
    'prefix':'MinMaxPlusConvolution'
    'body':"""
    namespace SMAWKImpl {
    constexpr int M = 1 << 20, N = 1 << 20;
    int is0[2 * M], js0[max(2 * M, N)];
    template<typename F> struct SMAWK {
      const int m, n;
      const F f;
      vector<int> v;
      SMAWK(int m, int n, F f): m(m), n(n), f(f) {
        for(int i = 0; i < m; i++) { is0[i] = i; }
        for(int j = 0; j < n; j++) { js0[j] = j; }
        v.assign(m, -1);
        rec(is0, m, js0, n);
      }
      void rec(int *is, int il, int *js, int jl) {
        if(!il || !jl) { return; }
        if(il < jl) {
          int len = 0;
          for(int y = 0; y < jl; y++) {
            const int j = js[y];
            for(; len && f(is[len - 1], js[len - 1], j); len--) {}
            if(len != il) { js[len++] = j; }
          }
          jl = len;
        }
        int *iis = is + il, *jjs = js + jl, iil = 0;
        for(int x = 1; x < il; x += 2) { iis[iil++] = is[x]; }
        for(int y = 0; y < jl; y++) { jjs[y] = js[y]; }
        rec(iis, iil, jjs, jl);
        for(int x = 0, y = 0; x < il; x += 2) {
          const int i = is[x];
          const int j1 = (x + 1 < il) ? v[is[x + 1]] : js[jl - 1];
          for(;;) {
            const int j = js[y];
            if(!~v[i] || f(i, v[i], j)) { v[i] = j; }
            if(j == j1) { break; }
            y++;
          }
        }
      }
    };
    }  // namespace SMAWKImpl

    template<typename F> vector<int> SMAWK(int m, int n, F f) { return SMAWKImpl::SMAWK<F>(m, n, f).v; }

    // C[k] = min[i+j=k] (A[i] + B[j]), A : 下に凸
    template<typename T> vector<T> MinPlusConvolution(const vector<T> &A, const vector<T> &B) {
      const int a = A.size(), b = B.size();
      if(!a || !b) { return {}; }
      const auto v = SMAWK(a + b - 1, b, [&](int i, int j, int k) -> bool {
        if(i - j >= a) { return true; }
        if(i - k < 0) { return false; }
        return A[i - j] + B[j] > A[i - k] + B[k];
      });
      vector<T> C(a + b - 1);
      for(int i = 0; i < a + b - 1; i++) { C[i] = A[i - v[i]] + B[v[i]]; }
      return C;
    }

    // C[k] = max[i+j=k] (A[i] + B[j]), A : 上に凸
    template<typename T> vector<T> MaxPlusConvolution(const vector<T> &A, const vector<T> &B) {
      const int a = A.size(), b = B.size();
      if(!a || !b) { return {}; }
      const auto v = SMAWK(a + b - 1, b, [&](int i, int j, int k) -> bool {
        if(i - j >= a) { return true; }
        if(i - k < 0) { return false; }
        return A[i - j] + B[j] < A[i - k] + B[k];
      });
      vector<T> C(a + b - 1);
      for(int i = 0; i < a + b - 1; i++) { C[i] = A[i - v[i]] + B[v[i]]; }
      return C;
    }
    """

  'DisjointSparseTable':
    'prefix':'DisjointSparseTable'
    'body':"""
    template<typename S, auto op, auto e> struct DisjointSparseTable {
      vector<vector<S>> t;
      DisjointSparseTable() {}
      DisjointSparseTable(const vector<S> &v) {
        const int N = v.size() + 2;
        const int H = 32 - __builtin_clz(N - 1);
        t.assign(H, vector<S>(N, e()));
        for(int k = 1; k < H; k++) {
          auto &s = t[k];
          const int W = 1 << k;
          for(int i = W; i < N; i += W * 2) {
            for(int j = i - 1; j > i - W; j--) { s[j - 1] = op(v[j - 1], s[j]); }
            const int M = min(i + W - 1, N - 1);
            for(int j = i; j < M; j++) { s[j + 1] = op(s[j], v[j - 1]); }
          }
        }
      }
      S get(int i) const { return prod(i, i + 1); }
      S prod(int l, int r) const {
        assert(0 <= l && l <= r && r <= ssize(t[0]) - 2);
        r++;
        const auto &s = t[31 - __builtin_clz(l ^ r)];
        return op(s[l], s[r]);
      }
    };
    """

  'disjointsparsetable':
    'prefix':'disjointsparsetable'
    'body':'DisjointSparseTable<S,op,e> S($1)'

  'RangeCountDistinct':
    'prefix':'RangeCountDistinct'
    'body':"""
    template<typename T> struct RangeCountDistinct {
     private:
      int N, Q;
      vector<T> v;
      vector<pair<int, int>> qs;

     public:
      RangeCountDistinct(): RangeCountDistinct(vector<T>{}) {}
      explicit RangeCountDistinct(const vector<T> &v): N(v.size()), Q(0), v(v) {}
      void reserve(int Q) { qs.reserve(Q); }
      int query(int l, int r) {
        assert(0 <= l && l <= r && r <= N);
        qs.emplace_back(l, r);
        return Q++;
      }
      vector<int> solve() const {
        unordered_map<T, int> last;
        vector<int> prv(N), idx(N + 2), iq(Q), ans(Q);
        for(int i = 0; i < N; i++) { prv[i] = exchange(last[v[i]], i + 1); }
        for(auto &[l, r] : qs) { idx[r]++; }
        for(int i = 1; i <= N; i++) { idx[i] += idx[i - 1]; }
        idx[N + 1] = Q;
        for(int i = 0; i < Q; i++) { iq[--idx[qs[i].second]] = i; }
        fenwick_tree<int> f(N + 1);
        for(int r = 0; r <= N; r++) {
          for(int i = idx[r]; i < idx[r + 1]; i++) {
            const int id = iq[i], l = qs[id].first;
            ans[id] = f.sum(0, l + 1) - l;
          }
          if(r < N) { f.add(prv[r], 1); }
        }
        return ans;
      }
    };
    """

  'rangecountdistinct':
    'prefix':'rangecountdistinct'
    'body':'RangeCountDistinct S($1);$2'

  'CompressedRectangleSum':
    'prefix':'CompressedRectangleSum'
    'body':"""
    template<typename S, typename T> struct CompressedRectangleSum {
      struct P {
        S x, y;
        T w;
      };
      struct Q1 {
        S lx, ly, rx, ry;
      };
      vector<P> ps;
      vector<Q1> Qs;
      CompressedRectangleSum() = default;
      CompressedRectangleSum(int N, int Q) {
        ps.reserve(N);
        Qs.reserve(Q);
      }
      void add(S x, S y, T w) { ps.emplace_back(P{x, y, w}); }
      void sum(S lx, S rx, S ly, S ry) { Qs.emplace_back(Q1{lx, ly, rx, ry}); }
      vector<T> solve() {
        int N = ps.size(), Q = Qs.size();
        ranges::sort(ps, [](const P &a, const P &b) { return a.y < b.y; });
        vector<S> ys;
        ys.reserve(N);
        for(P &p : ps) {
          if(ys.empty() || ys.back() != p.y) { ys.emplace_back(p.y); }
          p.y = ys.size() - 1;
        }
        ys.shrink_to_fit();
        struct Q2 {
          S x, ly, ry;
          bool type;
          int idx;
        };
        vector<Q2> qs;
        qs.reserve(Q + Q);
        for(int i = 0; i < Q; i++) {
          auto &q = Qs[i];
          int d = ranges::lower_bound(ys, q.ly) - ys.begin(), u = ranges::lower_bound(ys, q.ry) - ys.begin();
          qs.emplace_back(Q2{q.lx, d, u, false, i});
          qs.emplace_back(Q2{q.rx, d, u, true, i});
        }
        ranges::sort(ps, [](const P &a, const P &b) { return a.x < b.x; });
        ranges::sort(qs, [](const Q2 &a, const Q2 &b) { return a.x < b.x; });
        vector<T> ans(Q);
        int j = 0;
        fenwick_tree<T> f(ys.size());
        for(auto &q : qs) {
          while(j < N && ps[j].x < q.x) {
            f.add(ps[j].y, ps[j].w);
            j++;
          }
          if(q.type) { ans[q.idx] += f.sum(q.ly, q.ry); }
          else { ans[q.idx] -= f.sum(q.ly, q.ry); }
        }
        return ans;
      }
    };
    """

  'compressedrectanglesum':
    'prefix':'compressedrectanglesum'
    'body':'CompressedRectangleSum<ll,ll> S'

  'CompressedInverseBIT2D':
    'prefix':'CompressedInverseBIT2D'
    'body':"""
    template<typename S, typename T> struct CompressedInverseBIT2D {
     private:
      vector<array<S, 4>> rs;
      vector<T> ws;
      vector<array<S, 2>> ps;
      vector<int> ts;
      static int p2(int x) { return 1 << (31 - __builtin_clz(x)); }

     public:
      CompressedInverseBIT2D() = default;
      CompressedInverseBIT2D(int N, int Q) {
        rs.reserve(N);
        ws.reserve(N);
        ps.reserve(Q);
        ts.reserve(Q);
      }
      void add(S lx, S rx, S ly, S ry, T w) {
        assert(lx <= rx && ly <= ry);
        if(lx == rx || ly == ry) return;
        rs.push_back({lx, rx, ly, ry});
        ws.push_back(w);
      }
      void get(S x, S y) {
        ps.push_back({x, y});
        ts.push_back(rs.size());
      }
      vector<T> solve() const {
        vector<T> ans(ps.size());
        const int N = rs.size();
        using Key = pair<S, int>;
        constexpr auto comp = [](const Key &k1, const Key &k2) { return k1.first < k2.first; };
        vector<Key> esx(2 * N), esy(2 * N);
        for(int i = 0; i < N; i++) {
          esx[2 * i] = Key{rs[i][0], 2 * i};
          esx[2 * i + 1] = Key{rs[i][1], 2 * i + 1};
          esy[2 * i] = Key{rs[i][2], 2 * i};
          esy[2 * i + 1] = Key{rs[i][3], 2 * i + 1};
        }
        vector<vector<Key>> psx(N), psy(N);
        for(int pid = 0; pid < (int)ps.size(); pid++)
          if(ts[pid]) {
            const int r = p2(ts[pid]);
            psx[r - 1].emplace_back(ps[pid][0], pid);
            psy[r - 1].emplace_back(ps[pid][1], pid);
          }
        vector<int> pscy(ps.size()), escy(2 * N);
        for(int r = 1; r <= N; r++) {
          const int w = -r & r, l = r - w;
          for(int t = 1; t < w; t <<= 1) {
            auto irx = esx.begin() + 2 * r, imx = irx - 2 * t, ilx = imx - 2 * t;
            inplace_merge(ilx, imx, irx, comp);
            auto iry = esy.begin() + 2 * r, imy = iry - 2 * t, ily = imy - 2 * t;
            inplace_merge(ily, imy, iry, comp);
          }
          const int n = psx[r - 1].size();
          if(!n) { continue; }
          if(r == (-r & r)) {
            ranges::sort(psx[r - 1], comp);
            ranges::sort(psy[r - 1], comp);
          }
          int ny = 0;
          {
            vector<Key> mixy(esy.begin() + 2 * l, esy.begin() + 2 * r);
            const int msiz = mixy.size(), siz = msiz + n;
            mixy.reserve(siz);
            for(const auto &[y, pid] : psy[r - 1]) { mixy.emplace_back(y, ~pid); }
            inplace_merge(mixy.begin(), mixy.begin() + msiz, mixy.end(), comp);
            for(int t = 0; t < siz; t++) {
              const Key pkey = t ? mixy[t - 1] : Key{0, 0}, key = mixy[t];
              ny += t && comp(pkey, key) && (pkey.second < 0) && (key.second >= 0);
              const int i = key.second;
              (i >= 0 ? escy[i] : pscy[~i]) = ny;
            }
            ny++;
          }
          fenwick_tree<T> f(ny);
          for(int j = 0, i = 2 * l; j < n; j++) {
            const auto &[px, pid] = psx[r - 1][j];
            for(; i < 2 * r; i++) {
              const auto &[ex, eid] = esx[i];
              if(px < ex) { break; }
              const T &w = ws[eid >> 1];
              f.add(escy[eid & ~1], (eid & 1) ? -w : +w);
              f.add(escy[eid | 1], (eid & 1) ? +w : -w);
            }
            ans[pid] += f.sum(0, pscy[pid] + 1);
          }
          for(Key &key : psx[r - 1]) {
            if(int d = ts[key.second] - r) { psx[r + p2(d) - 1].push_back(move(key)); }
          }
          psx[r - 1].clear();
          psx[r - 1].shrink_to_fit();
          for(Key &key : psy[r - 1]) {
            if(int d = ts[key.second] - r) { psy[r + p2(d) - 1].push_back(move(key)); }
          }
          psy[r - 1].clear();
          psy[r - 1].shrink_to_fit();
        }
        return ans;
      }
    };
    """

  'compressedinverseBIT2D':
    'prefix':'compressedinverseBIT2D'
    'body':'CompressedInverseBIT2D<ll,ll> S'

  'StaticCompressedDualBIT2D':
    'prefix':'StaticCompressedDualBIT2D'
    'body':"""
    template<typename S, typename T> struct StaticCompressedDualBIT2D {
      vector<tuple<S, S, S, S, T>> Add;
      vector<tuple<S, S, S, S>> Sum;
      StaticCompressedDualBIT2D() = default;
      StaticCompressedDualBIT2D(int N, int Q) {
        Add.reserve(N);
        Sum.reserve(Q);
      }
      void add(S lx, S rx, S ly, S ry, T w) { Add.emplace_back(lx, rx, ly, ry, w); }
      void sum(S lx, S rx, S ly, S ry) { Sum.emplace_back(lx, rx, ly, ry); }
      vector<T> solve() {
        vector<S> ys;
        vector<tuple<S, S, T>> add;
        for(const auto &[lx, rx, ly, ry, w] : Add) {
          ys.emplace_back(ly), ys.emplace_back(ry);
          add.emplace_back(lx, ly, w), add.emplace_back(rx, ly, -w);
          add.emplace_back(lx, ry, -w), add.emplace_back(rx, ry, w);
        }
        ranges::sort(ys);
        ys.erase(unique(ys.begin(), ys.end()), ys.end());
        auto id = [&ys](S y) -> int { return ranges::lower_bound(ys, y) - ys.begin(); };
        vector<tuple<S, S, int, bool>> sum;
        for(int i = 0; i < (int)Sum.size(); i++) {
          const auto &[lx, rx, ly, ry] = Sum[i];
          sum.emplace_back(lx, ly, i, true), sum.emplace_back(rx, ly, i, false);
          sum.emplace_back(lx, ry, i, false), sum.emplace_back(rx, ry, i, true);
        }
        static constexpr auto comp = [](const auto &q1, const auto &q2) { return get<0>(q1) < get<0>(q2); };
        ranges::sort(add, comp);
        ranges::sort(sum, comp);
        fenwick_tree<T> f[4];
        for(int i = 0; i < 4; i++) { f[i] = fenwick_tree<T>(ys.size()); }
        vector<T> ans(Sum.size(), T{0});
        const int N = add.size(), M = sum.size();
        for(int i = 0, j = 0; i < N || j < M;) {
          if(j == M || (i < N && get<0>(add[i]) < get<0>(sum[j]))) {
            const auto [lx, ly, w] = add[i++];
            int idy = id(ly);
            f[0].add(idy, w);
            f[1].add(idy, -w * ly);
            f[2].add(idy, -w * lx);
            f[3].add(idy, w * lx * ly);
          }
          else {
            const auto &[x, y, qid, plus] = sum[j++];
            T s[4];
            for(int i = 0, idy = id(y); i < 4; i++) { s[i] = f[i].sum(0, idy); }
            const T tmp = s[0] * x * y + s[1] * x + s[2] * y + s[3];
            ans[qid] += (plus ? tmp : -tmp);
          }
        }
        return ans;
      }
    };
    """

  'staticcompresseddualBIT2D':
    'prefix':'staticcompresseddualBIT2D'
    'body':'StaticCompressedDualBIT2D<ll,ll> S'

  'CompressedDualBIT2D':
    'prefix':'CompressedDualBIT2D'
    'body':"""
    namespace std {
    template<typename T> tuple<T, T, T, T> operator+=(tuple<T, T, T, T> &l, tuple<T, T, T, T> r) {
      return l = make_tuple(get<0>(l) + get<0>(r), get<1>(l) + get<1>(r), get<2>(l) + get<2>(r), get<3>(l) + get<3>(r));
    }
    template<typename T> tuple<T, T, T, T> operator-(tuple<T, T, T, T> l, tuple<T, T, T, T> r) {
      return make_tuple(get<0>(l) - get<0>(r), get<1>(l) - get<1>(r), get<2>(l) - get<2>(r), get<3>(l) - get<3>(r));
    }
    template<typename T> tuple<T, T, T, T> operator-=(tuple<T, T, T, T> &l, tuple<T, T, T, T> r) {
      return l = l - r;
    }
    }  // namespace std

    template<typename S, typename T> struct CompressedBIT2D {
     private:
      struct BIT {
       private:
        int n;
        vector<T> data;
        T sum(int r) {
          T s = {0, 0, 0, 0};
          for(; r > 0; r -= r & -r) { s += data[r - 1]; }
          return s;
        }

       public:
        BIT() = default;
        explicit BIT(int n): n(n), data(n) {}
        void add(int p, T x) {
          for(++p; p <= n; p += p & -p) { data[p - 1] += T(x); }
        }
        T sum(int l, int r) { return sum(r) - sum(l); }
      };
      int N;
      vector<BIT> bit;
      vector<vector<S>> ys;
      vector<pair<S, S>> ps;
      int id(S x) const {
        return ranges::lower_bound(ps, make_pair(x, S()), [](const pair<S, S> &a, const pair<S, S> &b) { return a.first < b.first; }) - ps.begin();
      }
      int id(int i, S y) const { return ranges::lower_bound(ys[i], y) - ys[i].begin(); }

     public:
      CompressedBIT2D() = default;
      CompressedBIT2D(int N) { ps.reserve(N); }
      void use(S x, S y) { ps.emplace_back(x, y); }
      void build() {
        ranges::sort(ps);
        ps.erase(unique(ps.begin(), ps.end()), ps.end());
        N = ps.size();
        bit.resize(N + 1);
        ys.resize(N + 1);
        for(int i = 0; i <= N; ++i) {
          for(int j = i + 1; j <= N; j += j & -j) { ys[j].emplace_back(ps[i].second); }
          ranges::sort(ys[i]);
          ys[i].erase(unique(ys[i].begin(), ys[i].end()), ys[i].end());
          bit[i] = BIT(ys[i].size() + 1);
        }
      }
      void add(S x, S y, T a) {
        int i = ranges::lower_bound(ps, make_pair(x, y)) - ps.begin();
        assert(ps[i] == make_pair(x, y));
        for(++i; i <= N; i += i & -i) { bit[i].add(id(i, y), a); }
      }
      T sum(S x, S y) {
        T r = T();
        for(int a = id(x); a; a -= a & -a) { r += bit[a].sum(0, id(a, y)); }
        return r;
      }
      T sum(S lx, S rx, S ly, S ry) {
        T r = T();
        int a = id(lx), b = id(rx);
        while(a != b) {
          if(a < b) {
            r += bit[b].sum(id(b, ly), id(b, ry));
            b -= b & -b;
          }
          else {
            r -= bit[a].sum(id(a, ly), id(a, ry));
            a -= a & -a;
          }
        }
        return r;
      }
    };

    template<typename S, typename T> struct CompressedDualBIT2D {
     private:
      CompressedBIT2D<S, tuple<T, T, T, T>> B;
      static constexpr S inf = numeric_limits<S>::max();
      void add(S lx, S ly, const T &w) {
        B.add(lx, ly, make_tuple(w, -w * ly, -w * lx, w * lx * ly));
      }
      T sum(S x, S y) {
        auto [a, b, c, d] = B.sum(-inf, x, -inf, y);
        return a * x * y + b * x + c * y + d;
      }

     public:
      CompressedDualBIT2D() = default;
      void use(S lx, S rx, S ly, S ry) {
        B.use(lx, ly), B.use(rx, ly);
        B.use(lx, ry), B.use(rx, ry);
      }
      void build() { B.build(); }
      void add(S lx, S rx, S ly, S ry, const T &val) {
        add(lx, ly, val), add(rx, ly, -val);
        add(lx, ry, -val), add(rx, ry, val);
      }
      T sum(S lx, S rx, S ly, S ry) { return sum(rx, ry) - sum(rx, ly) - sum(lx, ry) + sum(lx, ly); }
    };
    """

  'compresseddualBIT2D':
    'prefix':'compresseddualBIT2D'
    'body':'CompressedDualBIT2D<ll,ll> S'

  'DoubleEndedPriorityQueue':
    'prefix':'DoubleEndedPriorityQueue'
    'body':"""
    template<typename T> struct DualPriorityQueue {
     private:
      inline int par(int i) { return (i - 4 + (i & 3)) / 2; }

      void down(int i) {
        int n = dat.size();
        if(i % 2 == 0) {
          while(true) {
            if(i + 1 < n && dat[i] > dat[i + 1]) { swap(dat[i], dat[i + 1]); }
            int j = i, l = 2 * i + 2, r = 2 * i + 4;
            if(l < n && dat[l] < dat[j]) { j = l; }
            if(r < n && dat[r] < dat[j]) { j = r; }
            if(i == j) { break; }
            swap(dat[i], dat[j]);
            i = j;
          }
        }
        else {
          while(true) {
            if(dat[i - 1] > dat[i]) { swap(dat[i - 1], dat[i]); }
            int j = i, l = 2 * i + 1, r = 2 * i + 3;
            if(r >= n) { --r; }
            if(l >= n) { --l; }
            if(l < n && dat[l] > dat[j]) { j = l; }
            if(r < n && dat[r] > dat[j]) { j = r; }
            if(i == j) { break; }
            swap(dat[i], dat[j]);
            i = j;
            if(i % 2 == 0) { break; }
          }
        }
      }

      void up() {
        int i = dat.size() - 1;
        if(2 <= i && i % 2 == 0) {
          int p = par(i) ^ 1;
          if(dat[p] < dat[i]) { swap(dat[i], dat[p]), i = p; }
        }
        if(i % 2 == 1 && dat[i - 1] > dat[i]) { swap(dat[i - 1], dat[i]), --i; }
        if(i % 2 == 0) {
          while(i >= 2) {
            int p = par(i);
            if(dat[p] <= dat[i]) { break; }
            swap(dat[p], dat[i]);
            i = p;
          }
          return;
        }
        while(i >= 3) {
          int p = par(i);
          if(dat[p] >= dat[i]) { break; }
          swap(dat[p], dat[i]);
          i = p;
        }
      }

     public:
      vector<T> dat;
      Double_End_Queue() {}
      Double_End_Queue(vector<T> &A) {
        dat = A;
        int n = dat.size();
        for(int i = n - 1; i >= 0; i--) { down(i); }
      }
      int size() { return dat.size(); }
      bool empty() { return dat.empty(); }
      T min() { return dat[0]; }
      T max() { return dat.size() == 1 ? dat[0] : dat[1]; }
      void push(T x) {
        dat.emplace_back(x);
        up();
      }
      T pop_min() {
        assert(!dat.empty());
        swap(dat[0], dat.back());
        T res = dat.back();
        dat.pop_back();
        down(0);
        return res;
      }
      T pop_max() {
        assert(!dat.empty());
        if(dat.size() <= 2) {
          T res = dat.back();
          dat.pop_back();
          return res;
        }
        swap(dat[1], dat.back());
        T res = dat.back();
        dat.pop_back();
        down(1);
        return res;
      }
    };
    """

  '__int128_t_option':
    'prefix':'__int128_t_option'
    'body':"""
    istream &operator>>(istream &is, __int128_t &v) {
      string s;
      is >> s;
      v = 0;
      for(const auto &i : s) {
        if(isdigit(i)) { v = v * 10 + i - '0'; }
      }
      if(s[0] == '-') { v = -v; }
      return is;
    }

    ostream &operator<<(ostream &os, const __int128_t &v) {
      if(!v) { return (os << "0"); }
      __int128_t n = v;
      if(v < 0) {
        os << '-';
        n = -n;
      }
      string s;
      for(; n; n /= 10) { s += (n % 10) + '0'; }
      ranges::reverse(s);
      return (os << s);
    }
    """

  'gradient':
    'prefix':'gradient'
    'body':"""
    void grd(ll &dx, ll &dy) {
      ll g = gcd(dx, dy);
      dx /= g, dy /= g;
      if(dx < 0) { dx *= -1, dy *= -1; }
      if(!dx) { dy = 1; }
      if(!dy) { dx = 1; }
    };
    """

  'mod_sqrt':
    'prefix':'mod_sqrt'
    'body':"""
    ll mod_sqrt(const ll &a, const ll &MOD = 998244353) {
      modint::set_mod(MOD);
      ll m = MOD - 1, e = 0;
      if(!a) { return 0; }
      if(MOD == 2) { return a; }
      if(mint(a).pow(m >> 1) != 1) { return -1; }
      mint b = 1;
      while(b.pow(m >> 1) == 1) { b++; }
      while(~m & 1) {
        m >>= 1;
        e++;
      }
      mint x = mint(a).pow((m - 1) >> 1), y = mint(a) * x * x, z = mint(b).pow(m);
      x *= a;
      while(y != 1) {
        ll j = 0;
        mint t = y;
        while(t != 1) {
          j++;
          t *= t;
        }
        z = z.pow(1LL << (e - j - 1));
        x *= z;
        z *= z;
        y *= z;
        e = j;
      }
      return x.val();
    }
    """

  'RangeModeQuery':
    'prefix':'RangeModeQuery'
    'body':"""
    template<typename T> struct RangeModeQuery {
     private:
      int len, bs, bn;
      vector<T> sorted;
      vector<int> a, pos, posinv, start;
      vector<pair<int, int>> modebs;

      const auto &querybs(int lb, int rb) const { return modebs[lb * (bn + 1) + rb]; }
      auto &querybs(int lb, int rb) { return modebs[lb * (bn + 1) + rb]; }
      int checkl(int v, int posid, int l) const { return start[v] <= posid && l <= pos[posid]; }
      int checkr(int v, int posid, int r) const { return posid < start[v + 1] && pos[posid] < r; }
      static int cld(int num, int den) { return (num + den - 1) / den; }
      static int fld(int num, int den) { return num / den; }

     public:
      RangeModeQuery() = default;
      explicit RangeModeQuery(const vector<T> &v): len(v.size()), bs(sqrt(len)), bn(cld(len, bs)) {
        sorted = v;
        ranges::sort(sorted);
        sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());
        const int k = sorted.size();
        a.resize(len);
        start.assign(k + 1, 0);
        for(int i = 0; i < len; i++) {
          a[i] = ranges::lower_bound(sorted, v[i]) - sorted.begin();
          start[a[i]]++;
        }
        for(int i = 0; i < k; i++) { start[i + 1] += start[i]; }
        pos.resize(len);
        posinv.resize(len);
        for(int i = len - 1; i >= 0; i--) {
          const int posid = --start[a[i]];
          pos[posid] = i;
          posinv[i] = posid;
        }
        modebs.assign((bn + 1) * (bn + 1), {0, 0});
        vector<int> freq(k);
        for(int lb = 0; lb <= bn; lb++) {
          freq.assign(k, 0);
          pair<int, int> mode{0, 0};
          for(int rb = lb + 1; rb <= bn; rb++) {
            const int lid = (rb - 1) * bs, rid = min(len, rb * bs);
            for(int i = lid; i < rid; i++) { mode = max(mode, {++freq[a[i]], a[i]}); }
            querybs(lb, rb) = mode;
          }
        }
      }

      pair<T, int> query(const int l, const int r) const {
        assert(0 <= l && l < r && r <= len);
        const int lb = cld(l, bs), rb = fld(r, bs);
        auto [freq, mode] = querybs(lb, rb);
        for(int i = l; i < min(r, lb * bs); ++i) {
          const int v = a[i], posid = posinv[i];
          if(!checkr(v, posid + freq, r)) { continue; }
          do { ++freq; } while(checkr(v, posid + freq, r));
          mode = v;
        }
        for(int i = r - 1; i >= max(l, rb * bs); --i) {
          const int v = a[i], posid = posinv[i];
          if(!checkl(v, posid - freq, l)) { continue; }
          do { ++freq; } while(checkl(v, posid - freq, l));
          mode = v;
        }
        return {sorted[mode], freq};
      }
      pair<T, int> operator()(int l, int r) const { return query(l, r); }
    };
    """

  'RangeUnionFind':
    'prefix':'RangeUnionFind'
    'body':"""
    struct RangeUnionFind {
      vector<int> data, L, R;
      RangeUnionFind(int N): data(N, -1), L(N), R(N) {
        iota(L.begin(), L.end(), 0);
        iota(R.begin(), R.end(), 1);
      }
      int find(int k) { return data[k] < 0 ? k : data[k] = find(data[k]); }
      int unite(int x, int y) {
        if((x = find(x)) == (y = find(y))) { return false; }
        if(data[x] > data[y]) { swap(x, y); }
        data[x] += data[y];
        data[y] = x;
        L[x] = min(L[x], L[y]);
        R[x] = max(R[x], R[y]);
        return true;
      }
      void range_unite(int l, int r) {  // unite [l, r)
        if((l = max(l, 0)) >= (r = min(r, (int)data.size()))) { return; }
        int m;
        while((m = R[find(l)]) < r) { unite(l, m); }
      }
      int size(int k) { return -data[find(k)]; }
      int same(int x, int y) { return find(x) == find(y); }
    };
    """

  'Fail':
    'prefix':'Fail'
    'body':"""
    void Fail() {
      cout << ${1:-1} << "\\\\n";
      exit(0);
    }$2
    """
